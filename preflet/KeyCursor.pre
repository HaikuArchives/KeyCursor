



extern const unsigned char B_HAND_CURSOR[];
extern const unsigned char B_I_BEAM_CURSOR[];



class BCursor;
extern const BCursor *B_CURSOR_SYSTEM_DEFAULT;
extern const BCursor *B_CURSOR_I_BEAM;




enum system_message_code {
 B_ABOUT_REQUESTED = '_ABR',
 B_WINDOW_ACTIVATED = '_ACT',
 B_APP_ACTIVATED = '_ACT',
 B_ARGV_RECEIVED = '_ARG',
 B_QUIT_REQUESTED = '_QRQ',
 B_CLOSE_REQUESTED = '_QRQ',
 B_CANCEL = '_CNC',
 B_INVALIDATE = '_IVL',
 B_KEY_DOWN = '_KYD',
 B_KEY_UP = '_KYU',
 B_UNMAPPED_KEY_DOWN = '_UKD',
 B_UNMAPPED_KEY_UP = '_UKU',
 B_KEY_MAP_LOADED = '_KML',
 B_LAYOUT_WINDOW = '_LAY',
 B_MODIFIERS_CHANGED = '_MCH',
 B_MINIMIZE = '_WMN',
 B_MOUSE_DOWN = '_MDN',
 B_MOUSE_MOVED = '_MMV',
 B_MOUSE_ENTER_EXIT = '_MEX',
 B_MOUSE_IDLE = '_MSI',
 B_MOUSE_UP = '_MUP',
 B_MOUSE_WHEEL_CHANGED = '_MWC',
 B_OPEN_IN_WORKSPACE = '_OWS',
 B_PACKAGE_UPDATE = '_PKU',
 B_PRINTER_CHANGED = '_PCH',
 B_PULSE = '_PUL',
 B_READY_TO_RUN = '_RTR',
 B_REFS_RECEIVED = '_RRC',
 B_RELEASE_OVERLAY_LOCK = '_ROV',
 B_ACQUIRE_OVERLAY_LOCK = '_AOV',
 B_SCREEN_CHANGED = '_SCH',
 B_VALUE_CHANGED = '_VCH',
 B_TRANSLATOR_ADDED = '_ART',
 B_TRANSLATOR_REMOVED = '_RRT',
 B_DELETE_TRANSLATOR = '_DRT',
 B_VIEW_MOVED = '_VMV',
 B_VIEW_RESIZED = '_VRS',
 B_WINDOW_MOVED = '_WMV',
 B_WINDOW_RESIZED = '_WRS',
 B_WORKSPACES_CHANGED = '_WCG',
 B_WORKSPACE_ACTIVATED = '_WAC',
 B_ZOOM = '_WZM',
 B_COLORS_UPDATED = '_CLU',
 B_FONTS_UPDATED = '_FNU',
 B_TRACKER_ADDON_MESSAGE = '_TAM',
 _APP_MENU_ = '_AMN',
 _BROWSER_MENUS_ = '_BRM',
 _MENU_EVENT_ = '_MEV',
 _PING_ = '_PBL',
 _QUIT_ = '_QIT',
 _VOLUME_MOUNTED_ = '_NVL',
 _VOLUME_UNMOUNTED_ = '_VRM',
 _MESSAGE_DROPPED_ = '_MDP',
 _DISPOSE_DRAG_ = '_DPD',
 _MENUS_DONE_ = '_MND',
 _SHOW_DRAG_HANDLES_ = '_SDH',
 _EVENTS_PENDING_ = '_EVP',
 _UPDATE_ = '_UPD',
 _UPDATE_IF_NEEDED_ = '_UPN',
 _PRINTER_INFO_ = '_PIN',
 _SETUP_PRINTER_ = '_SUP',
 _SELECT_PRINTER_ = '_PSL'

};



enum command_code {
 B_SET_PROPERTY = 'PSET',
 B_GET_PROPERTY = 'PGET',
 B_CREATE_PROPERTY = 'PCRT',
 B_DELETE_PROPERTY = 'PDEL',
 B_COUNT_PROPERTIES = 'PCNT',
 B_EXECUTE_PROPERTY = 'PEXE',
 B_GET_SUPPORTED_SUITES = 'SUIT',
 B_UNDO = 'UNDO',
 B_REDO = 'REDO',
 B_CUT = 'CCUT',
 B_COPY = 'COPY',
 B_PASTE = 'PSTE',
 B_SELECT_ALL = 'SALL',
 B_SAVE_REQUESTED = 'SAVE',
 B_MESSAGE_NOT_UNDERSTOOD = 'MNOT',
 B_NO_REPLY = 'NONE',
 B_REPLY = 'RPLY',
 B_SIMPLE_DATA = 'DATA',
 B_MIME_DATA = 'MIME',
 B_ARCHIVED_OBJECT = 'ARCV',
 B_UPDATE_STATUS_BAR = 'SBUP',
 B_RESET_STATUS_BAR = 'SBRS',
 B_NODE_MONITOR = 'NDMN',
 B_QUERY_UPDATE = 'QUPD',
 B_ENDORSABLE = 'ENDO',
 B_COPY_TARGET = 'DDCP',
 B_MOVE_TARGET = 'DDMV',
 B_TRASH_TARGET = 'DDRM',
 B_LINK_TARGET = 'DDLN',
 B_INPUT_DEVICES_CHANGED = 'IDCH',
 B_INPUT_METHOD_EVENT = 'IMEV',
 B_WINDOW_MOVE_TO = 'WDMT',
 B_WINDOW_MOVE_BY = 'WDMB',
 B_SILENT_RELAUNCH = 'AREL',
 B_OBSERVER_NOTICE_CHANGE = 'NTCH',
 B_CONTROL_INVOKED = 'CIVK',
 B_CONTROL_MODIFIED = 'CMOD'


};






typedef signed char __haiku_std_int8;
typedef unsigned char __haiku_std_uint8;
typedef signed short __haiku_std_int16;
typedef unsigned short __haiku_std_uint16;
typedef signed int __haiku_std_int32;
typedef unsigned int __haiku_std_uint32;

typedef signed long __haiku_std_int64;
typedef unsigned long __haiku_std_uint64;





typedef __haiku_std_int8 __haiku_int8;
typedef __haiku_std_uint8 __haiku_uint8;
typedef __haiku_std_int16 __haiku_int16;
typedef __haiku_std_uint16 __haiku_uint16;




typedef __haiku_std_int32 __haiku_int32;
typedef __haiku_std_uint32 __haiku_uint32;

typedef __haiku_std_int64 __haiku_int64;
typedef __haiku_std_uint64 __haiku_uint64;


typedef signed long int __haiku_saddr_t;
typedef unsigned long int __haiku_addr_t;


 typedef __haiku_int64 __haiku_phys_saddr_t;
 typedef __haiku_uint64 __haiku_phys_addr_t;
 typedef __haiku_addr_t __haiku_generic_addr_t;


extern "C" {


int _to_positive_error(int error);
int _to_negative_error(int error);


}

typedef __haiku_std_int8 int8_t;
typedef __haiku_std_uint8 uint8_t;

typedef __haiku_std_int16 int16_t;
typedef __haiku_std_uint16 uint16_t;

typedef __haiku_std_int32 int32_t;
typedef __haiku_std_uint32 uint32_t;

typedef __haiku_std_int64 int64_t;
typedef __haiku_std_uint64 uint64_t;


typedef int8_t int_least8_t;
typedef uint8_t uint_least8_t;

typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;

typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;

typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;


typedef int32_t int_fast8_t;
typedef uint32_t uint_fast8_t;

typedef int32_t int_fast16_t;
typedef uint32_t uint_fast16_t;

typedef int32_t int_fast32_t;
typedef uint32_t uint_fast32_t;

typedef int64_t int_fast64_t;
typedef uint64_t uint_fast64_t;


typedef __haiku_saddr_t intptr_t;
typedef __haiku_addr_t uintptr_t;


typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
typedef uint8_t u_int8_t;
typedef uint16_t u_int16_t;
typedef uint32_t u_int32_t;
typedef uint64_t u_int64_t;


typedef struct {
 intmax_t quot;
 intmax_t rem;
} imaxdiv_t;
extern "C" {


extern intmax_t imaxabs(intmax_t num);
extern imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);

extern intmax_t strtoimax(const char *string, char **_end, int base);
extern uintmax_t strtoumax(const char *string, char **_end, int base);




}
typedef unsigned long u_long;
typedef unsigned int u_int;
typedef unsigned short u_short;
typedef unsigned char u_char;



typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned char unchar;


typedef __haiku_int64 blkcnt_t;
typedef __haiku_std_int32 blksize_t;
typedef __haiku_int64 fsblkcnt_t;
typedef __haiku_int64 fsfilcnt_t;
typedef __haiku_int64 off_t;
typedef __haiku_int64 ino_t;
typedef __haiku_std_int32 cnt_t;
typedef __haiku_int32 dev_t;
typedef __haiku_int32 pid_t;
typedef __haiku_int32 id_t;

typedef __haiku_std_uint32 uid_t;
typedef __haiku_std_uint32 gid_t;
typedef __haiku_std_uint32 mode_t;
typedef __haiku_std_uint32 umode_t;
typedef __haiku_std_int32 nlink_t;




 typedef off_t daddr_t;

typedef char* caddr_t;

typedef __haiku_addr_t addr_t;
typedef __haiku_int32 key_t;

typedef __haiku_std_int32 clockid_t;
typedef struct __timer_t* timer_t;




typedef struct _pthread_thread *pthread_t;
typedef struct _pthread_attr *pthread_attr_t;
typedef struct _pthread_barrier pthread_barrier_t;
typedef struct _pthread_barrierattr *pthread_barrierattr_t;
typedef struct _pthread_mutex pthread_mutex_t;
typedef struct _pthread_mutexattr *pthread_mutexattr_t;
typedef struct _pthread_cond pthread_cond_t;
typedef struct _pthread_condattr *pthread_condattr_t;
typedef int pthread_key_t;
typedef struct _pthread_once pthread_once_t;
typedef struct _pthread_rwlock pthread_rwlock_t;
typedef struct _pthread_rwlockattr *pthread_rwlockattr_t;
typedef struct _pthread_spinlock pthread_spinlock_t;

struct _pthread_mutex {
 __haiku_std_uint32 flags;
 __haiku_std_int32 lock;
 __haiku_std_int32 unused;
 __haiku_std_int32 owner;
 __haiku_std_int32 owner_count;
};

struct _pthread_barrier {
 __haiku_std_uint32 flags;
 __haiku_std_int32 lock;
 __haiku_std_int32 mutex;
 __haiku_std_int32 waiter_count;
 __haiku_std_int32 waiter_max;
};

struct _pthread_cond {
 __haiku_std_uint32 flags;
 __haiku_std_int32 unused;
 pthread_mutex_t* mutex;
 __haiku_std_int32 waiter_count;
 __haiku_std_int32 lock;
};

struct _pthread_once {
 __haiku_std_int32 state;
};

struct _pthread_rwlock {
 __haiku_std_uint32 flags;
 __haiku_std_int32 owner;
 union {
  struct {
   __haiku_std_int32 mutex;
   __haiku_std_int32 unused;
   __haiku_std_int32 reader_count;
   __haiku_std_int32 writer_count;
   void* waiters[2];
  } local;
  struct {
   __haiku_std_int32 sem;
  } shared;
 } u;
};

struct _pthread_spinlock {
 __haiku_std_int32 lock;
};


typedef long int ptrdiff_t;
typedef long unsigned int size_t;
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;






  typedef decltype(nullptr) nullptr_t;





typedef long signed int ssize_t;
typedef void* locale_t;


struct sigevent;


typedef __haiku_int32 clock_t;
typedef __haiku_int32 suseconds_t;
typedef __haiku_uint32 useconds_t;




typedef __haiku_int64 time_t;
struct timespec {
 time_t tv_sec;
 long tv_nsec;
};

struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};

struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 int tm_gmtoff;
 char *tm_zone;
};



extern char *tzname[2];
extern int daylight;
extern long timezone;



extern "C" {


extern clock_t clock(void);
extern double difftime(time_t time1, time_t time2);
extern time_t mktime(struct tm *tm);
extern time_t time(time_t *timer);
extern char *asctime(const struct tm *tm);
extern char *asctime_r(const struct tm *timep, char *buffer);
extern char *ctime(const time_t *timer);
extern char *ctime_r(const time_t *timer, char *buffer);
extern struct tm *gmtime(const time_t *timer);
extern struct tm *gmtime_r(const time_t *timer, struct tm *tm);
extern struct tm *localtime(const time_t *timer);
extern struct tm *localtime_r(const time_t *timer, struct tm *tm);
extern int nanosleep(const struct timespec *, struct timespec *);
extern size_t strftime(char *buffer, size_t maxSize, const char *format,
      const struct tm *tm);
extern size_t strftime_l(char *buffer, size_t maxSize, const char *format,
      const struct tm *tm, locale_t locale);
extern char *strptime(const char *buf, const char *format, struct tm *tm);


int clock_getres(clockid_t clockID, struct timespec* resolution);
int clock_gettime(clockid_t clockID, struct timespec* _time);
int clock_settime(clockid_t clockID, const struct timespec* _time);
int clock_nanosleep(clockid_t clockID, int flags,
   const struct timespec* _time, struct timespec* remainingTime);
int clock_getcpuclockid(pid_t pid, clockid_t* _clockID);


int timer_create(clockid_t clockID, struct sigevent* event,
   timer_t* timerID);
int timer_delete(timer_t timerID);
int timer_gettime(timer_t timerID, struct itimerspec* value);
int timer_settime(timer_t timerID, int flags,
   const struct itimerspec* value, struct itimerspec* oldValue);
int timer_getoverrun(timer_t timerID);


int timespec_get(struct timespec *ts, int base);


extern void tzset(void);


extern int stime(const time_t *t);


}






extern "C" {


time_t timelocal(struct tm *tm);
time_t timegm(struct tm *tm);


}



typedef __haiku_int8 int8;
typedef __haiku_uint8 uint8;
typedef __haiku_int16 int16;
typedef __haiku_uint16 uint16;
typedef __haiku_int32 int32;
typedef __haiku_uint32 uint32;
typedef __haiku_int64 int64;
typedef __haiku_uint64 uint64;


typedef volatile int8 vint8;
typedef volatile uint8 vuint8;
typedef volatile int16 vint16;
typedef volatile uint16 vuint16;
typedef volatile int32 vint32;
typedef volatile uint32 vuint32;
typedef volatile int64 vint64;
typedef volatile uint64 vuint64;

typedef volatile long vlong;
typedef volatile int vint;
typedef volatile short vshort;
typedef volatile char vchar;

typedef volatile unsigned long vulong;
typedef volatile unsigned int vuint;
typedef volatile unsigned short vushort;
typedef volatile unsigned char vuchar;

typedef unsigned char uchar;


typedef int32 status_t;
typedef int64 bigtime_t;
typedef int64 nanotime_t;
typedef uint32 type_code;
typedef uint32 perform_code;

typedef __haiku_phys_addr_t phys_addr_t;
typedef phys_addr_t phys_size_t;

typedef __haiku_generic_addr_t generic_addr_t;
typedef generic_addr_t generic_size_t;
extern const char *B_EMPTY_STRING;
extern "C" {



extern void* get_stack_frame(void);


}
static __inline__ void
atomic_set(int32* value, int32 newValue)
{
 __atomic_store_n(value, newValue, 3);
}


static __inline__ int32
atomic_get_and_set(int32* value, int32 newValue)
{
 return __atomic_exchange_n(value, newValue, 5);
}


static __inline__ int32
atomic_test_and_set(int32* value, int32 newValue, int32 testAgainst)
{
 __atomic_compare_exchange_n(value, &testAgainst, newValue, 1,
  5, 5);
 return testAgainst;
}


static __inline__ int32
atomic_add(int32* value, int32 addValue)
{
 return __atomic_fetch_add(value, addValue, 5);
}


static __inline__ int32
atomic_and(int32* value, int32 andValue)
{
 return __atomic_fetch_and(value, andValue, 5);
}


static __inline__ int32
atomic_or(int32* value, int32 orValue)
{
 return __atomic_fetch_or(value, orValue, 5);
}


static __inline__ int32
atomic_get(int32* value)
{
 return __atomic_load_n(value, 2);
}


static __inline__ void
atomic_set64(int64* value, int64 newValue)
{
 __atomic_store_n(value, newValue, 3);
}


static __inline__ int64
atomic_get_and_set64(int64* value, int64 newValue)
{
 return __atomic_exchange_n(value, newValue, 5);
}


static __inline__ int64
atomic_test_and_set64(int64* value, int64 newValue, int64 testAgainst)
{
 __atomic_compare_exchange_n(value, &testAgainst, newValue, 1,
  5, 5);
 return testAgainst;
}


static __inline__ int64
atomic_add64(int64* value, int64 addValue)
{
 return __atomic_fetch_add(value, addValue, 5);
}


static __inline__ int64
atomic_and64(int64* value, int64 andValue)
{
 return __atomic_fetch_and(value, andValue, 5);
}


static __inline__ int64
atomic_or64(int64* value, int64 orValue)
{
 return __atomic_fetch_or(value, orValue, 5);
}


static __inline__ int64
atomic_get64(int64* value)
{
 return __atomic_load_n(value, 2);
}



typedef struct pattern {
 uint8 data[8];
} pattern;



inline bool
operator==(const pattern& a, const pattern& b)
{
 uint64* pa = (uint64*)a.data;
 uint64* pb = (uint64*)b.data;
 return (*pa == *pb);
}


inline bool
operator!=(const pattern& a, const pattern& b)
{
 return !(a == b);
}



extern const pattern B_SOLID_HIGH;
extern const pattern B_MIXED_COLORS;
extern const pattern B_SOLID_LOW;



typedef struct rgb_color {
 uint8 red;
 uint8 green;
 uint8 blue;
 uint8 alpha;



 inline rgb_color&
 set_to(uint8 r, uint8 g, uint8 b, uint8 a = 255)
 {
  red = r;
  green = g;
  blue = b;
  alpha = a;
  return *this;
 }

 int32 Brightness() const;

 inline bool
 operator==(const rgb_color& other) const
 {
  return *(const uint32 *)this == *(const uint32 *)&other;
 }

 inline bool
 operator!=(const rgb_color& other) const
 {
  return *(const uint32 *)this != *(const uint32 *)&other;
 }

 inline rgb_color&
 operator=(const rgb_color& other)
 {
  return set_to(other.red, other.green, other.blue, other.alpha);
 }

} rgb_color;



inline rgb_color
make_color(uint8 red, uint8 green, uint8 blue, uint8 alpha = 255)
{
 rgb_color color = {red, green, blue, alpha};
 return color;
}



rgb_color mix_color(rgb_color color1, rgb_color color2, uint8 amount);
rgb_color blend_color(rgb_color color1, rgb_color color2, uint8 amount);
rgb_color disable_color(rgb_color color, rgb_color background);


extern const rgb_color B_TRANSPARENT_COLOR;
extern const uint8 B_TRANSPARENT_MAGIC_CMAP8;
extern const uint16 B_TRANSPARENT_MAGIC_RGBA15;
extern const uint16 B_TRANSPARENT_MAGIC_RGBA15_BIG;
extern const uint32 B_TRANSPARENT_MAGIC_RGBA32;
extern const uint32 B_TRANSPARENT_MAGIC_RGBA32_BIG;
extern const uint8 B_TRANSPARENT_8_BIT;
extern const rgb_color B_TRANSPARENT_32_BIT;



typedef struct color_map {
 int32 id;
 rgb_color color_list[256];
 uint8 inversion_map[256];
 uint8 index_map[32768];
} color_map;



typedef struct overlay_rect_limits {
 uint16 horizontal_alignment;
 uint16 vertical_alignment;
 uint16 width_alignment;
 uint16 height_alignment;
 uint16 min_width;
 uint16 max_width;
 uint16 min_height;
 uint16 max_height;
 uint32 reserved[8];
} overlay_rect_limits;


typedef struct overlay_restrictions {
 overlay_rect_limits source;
 overlay_rect_limits destination;
 float min_width_scale;
 float max_width_scale;
 float min_height_scale;
 float max_height_scale;
 uint32 reserved[8];
} overlay_restrictions;



struct screen_id { int32 id; };
extern const struct screen_id B_MAIN_SCREEN_ID;



typedef enum {
 B_NO_COLOR_SPACE = 0x0000,


 B_RGBA64 = 0x2012,
 B_RGB48 = 0x0011,
 B_RGB32 = 0x0008,
 B_RGBA32 = 0x2008,
 B_RGB24 = 0x0003,
 B_RGB16 = 0x0005,
 B_RGB15 = 0x0010,
 B_RGBA15 = 0x2010,
 B_CMAP8 = 0x0004,
 B_GRAY8 = 0x0002,
 B_GRAY1 = 0x0001,


 B_RGBA64_BIG = 0x3012,
 B_RGB48_BIG = 0x1011,
 B_RGB32_BIG = 0x1008,
 B_RGBA32_BIG = 0x3008,
 B_RGB24_BIG = 0x1003,
 B_RGB16_BIG = 0x1005,
 B_RGB15_BIG = 0x1010,
 B_RGBA15_BIG = 0x3010,


 B_RGBA64_LITTLE = B_RGBA64,
 B_RGB48_LITTLE = B_RGB48,
 B_RGB32_LITTLE = B_RGB32,
 B_RGBA32_LITTLE = B_RGBA32,
 B_RGB24_LITTLE = B_RGB24,
 B_RGB16_LITTLE = B_RGB16,
 B_RGB15_LITTLE = B_RGB15,
 B_RGBA15_LITTLE = B_RGBA15,
 B_YCbCr422 = 0x4000,

 B_YCbCr411 = 0x4001,


 B_YCbCr444 = 0x4003,
 B_YCbCr420 = 0x4004,
 B_YUV422 = 0x4020,

 B_YUV411 = 0x4021,

 B_YUV444 = 0x4023,
 B_YUV420 = 0x4024,


 B_YUV9 = 0x402C,
 B_YUV12 = 0x402D,

 B_UVL24 = 0x4030,
 B_UVL32 = 0x4031,
 B_UVLA32 = 0x6031,


 B_LAB24 = 0x4032,
 B_LAB32 = 0x4033,
 B_LABA32 = 0x6033,


 B_HSI24 = 0x4040,
 B_HSI32 = 0x4041,
 B_HSIA32 = 0x6041,

 B_HSV24 = 0x4042,
 B_HSV32 = 0x4043,
 B_HSVA32 = 0x6043,

 B_HLS24 = 0x4044,
 B_HLS32 = 0x4045,
 B_HLSA32 = 0x6045,

 B_CMY24 = 0xC001,
 B_CMY32 = 0xC002,
 B_CMYA32 = 0xE002,
 B_CMYK32 = 0xC003,


 B_MONOCHROME_1_BIT = B_GRAY1,
 B_GRAYSCALE_8_BIT = B_GRAY8,
 B_COLOR_8_BIT = B_CMAP8,
 B_RGB_32_BIT = B_RGB32,
 B_RGB_16_BIT = B_RGB15,
 B_BIG_RGB_32_BIT = B_RGB32_BIG,
 B_BIG_RGB_16_BIT = B_RGB15_BIG
} color_space;



enum {
 B_VIEWS_SUPPORT_DRAW_BITMAP = 0x1,
 B_BITMAPS_SUPPORT_ATTACHED_VIEWS = 0x2,
 B_BITMAPS_SUPPORT_OVERLAY = 0x4
};


bool bitmaps_support_space(color_space space, uint32* _supportFlags);


status_t get_pixel_size_for(color_space space, size_t* _pixelChunk,
 size_t* _rowAlignment, size_t* _pixelsPerChunk);


enum buffer_orientation {
 B_BUFFER_TOP_TO_BOTTOM,
 B_BUFFER_BOTTOM_TO_TOP
};


enum buffer_layout {
 B_BUFFER_NONINTERLEAVED = 1
};



enum drawing_mode {
 B_OP_COPY,
 B_OP_OVER,
 B_OP_ERASE,
 B_OP_INVERT,
 B_OP_ADD,
 B_OP_SUBTRACT,
 B_OP_BLEND,
 B_OP_MIN,
 B_OP_MAX,
 B_OP_SELECT,
 B_OP_ALPHA
};


enum source_alpha {
 B_PIXEL_ALPHA = 0,
 B_CONSTANT_ALPHA
};


enum alpha_function {
 B_ALPHA_OVERLAY = 0,
 B_ALPHA_COMPOSITE,
 B_ALPHA_COMPOSITE_SOURCE_OVER = B_ALPHA_COMPOSITE,
 B_ALPHA_COMPOSITE_SOURCE_IN,
 B_ALPHA_COMPOSITE_SOURCE_OUT,
 B_ALPHA_COMPOSITE_SOURCE_ATOP,
 B_ALPHA_COMPOSITE_DESTINATION_OVER,
 B_ALPHA_COMPOSITE_DESTINATION_IN,
 B_ALPHA_COMPOSITE_DESTINATION_OUT,
 B_ALPHA_COMPOSITE_DESTINATION_ATOP,
 B_ALPHA_COMPOSITE_XOR,
 B_ALPHA_COMPOSITE_CLEAR,
 B_ALPHA_COMPOSITE_DIFFERENCE,
 B_ALPHA_COMPOSITE_LIGHTEN,
 B_ALPHA_COMPOSITE_DARKEN
};



enum {
 B_8_BIT_640x480 = 0x00000001,
 B_8_BIT_800x600 = 0x00000002,
 B_8_BIT_1024x768 = 0x00000004,
 B_8_BIT_1280x1024 = 0x00000008,
 B_8_BIT_1600x1200 = 0x00000010,
 B_16_BIT_640x480 = 0x00000020,
 B_16_BIT_800x600 = 0x00000040,
 B_16_BIT_1024x768 = 0x00000080,
 B_16_BIT_1280x1024 = 0x00000100,
 B_16_BIT_1600x1200 = 0x00000200,
 B_32_BIT_640x480 = 0x00000400,
 B_32_BIT_800x600 = 0x00000800,
 B_32_BIT_1024x768 = 0x00001000,
 B_32_BIT_1280x1024 = 0x00002000,
 B_32_BIT_1600x1200 = 0x00004000,
 B_8_BIT_1152x900 = 0x00008000,
 B_16_BIT_1152x900 = 0x00010000,
 B_32_BIT_1152x900 = 0x00020000,
 B_15_BIT_640x480 = 0x00040000,
 B_15_BIT_800x600 = 0x00080000,
 B_15_BIT_1024x768 = 0x00100000,
 B_15_BIT_1280x1024 = 0x00200000,
 B_15_BIT_1600x1200 = 0x00400000,
 B_15_BIT_1152x900 = 0x00800000,
 B_8_BIT_640x400 = 0x80000000
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;



struct stat {
 dev_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 nlink_t st_nlink;
 uid_t st_uid;
 gid_t st_gid;
 off_t st_size;
 dev_t st_rdev;
 blksize_t st_blksize;
 struct timespec st_atim;
 struct timespec st_mtim;
 struct timespec st_ctim;
 struct timespec st_crtim;
 __haiku_uint32 st_type;
 blkcnt_t st_blocks;
};
extern "C" {


extern int chmod(const char *path, mode_t mode);
extern int fchmod(int fd, mode_t mode);
extern int fchmodat(int fd, const char *path, mode_t mode, int flag);
extern int stat(const char *path, struct stat *st);
extern int fstat(int fd, struct stat *st);
extern int lstat(const char *path, struct stat *st);
extern int fstatat(int fd, const char *path, struct stat *st, int flag);
extern int mkdir(const char *path, mode_t mode);
extern int mkdirat(int fd, const char *path, mode_t mode);
extern int mkfifo(const char *path, mode_t mode);
extern int mkfifoat(int fd, const char *path, mode_t mode);
extern int mknod(const char *name, mode_t mode, dev_t dev);
extern int mknodat(int fd, const char *name, mode_t mode, dev_t dev);
extern mode_t umask(mode_t cmask);

extern int utimensat(int fd, const char *path,
     const struct timespec times[2], int flag);
extern int futimens(int fd, const struct timespec times[2]);


}
extern "C" {



extern int access(const char *path, int accessMode);
extern int faccessat(int fd, const char *path, int accessMode, int flag);

extern int chdir(const char *path);
extern int fchdir(int fd);
extern char *getcwd(char *buffer, size_t size);

extern int pipe(int fildes[2]);
extern int dup(int fd);
extern int dup2(int fd1, int fd2);
extern int close(int fd);
extern int link(const char *toPath, const char *path);
extern int linkat(int toFD, const char *toPath, int pathFD,
     const char *path, int flag);
extern int unlink(const char *name);
extern int unlinkat(int fd, const char *path, int flag);
extern int rmdir(const char *path);

extern ssize_t readlink(const char *path, char *buffer, size_t bufferSize);
extern ssize_t readlinkat(int fd, const char *path, char *buffer,
     size_t bufferSize);
extern int symlink(const char *toPath, const char *symlinkPath);
extern int symlinkat(const char *toPath, int fd, const char *symlinkPath);

extern int ftruncate(int fd, off_t newSize);
extern int truncate(const char *path, off_t newSize);
struct ioctl_args {
    void* argument;
    size_t size;
};
int __ioctl(int fd, ulong cmd, struct ioctl_args args);






inline int
ioctl(int fd, unsigned long op, void* argument = __null, size_t size = 0)
{
 return __ioctl(fd, op, (struct ioctl_args){ argument, size });
}


extern ssize_t read(int fd, void *buffer, size_t count);
extern ssize_t read_pos(int fd, off_t pos, void *buffer, size_t count);
extern ssize_t pread(int fd, void *buffer, size_t count, off_t pos);
extern ssize_t write(int fd, const void *buffer, size_t count);
extern ssize_t write_pos(int fd, off_t pos, const void *buffer,size_t count);
extern ssize_t pwrite(int fd, const void *buffer, size_t count, off_t pos);
extern off_t lseek(int fd, off_t offset, int whence);

extern void sync(void);
extern int fsync(int fd);

extern int chown(const char *path, uid_t owner, gid_t group);
extern int fchown(int fd, uid_t owner, gid_t group);
extern int lchown(const char *path, uid_t owner, gid_t group);
extern int fchownat(int fd, const char *path, uid_t owner, gid_t group,
     int flag);

extern int getpagesize(void);
extern int getdtablesize(void);
extern long sysconf(int name);
extern long fpathconf(int fd, int name);
extern long pathconf(const char *path, int name);
extern size_t confstr(int name, char *buf, size_t len);
extern int lockf(int fd, int function, off_t size);


extern pid_t fork(void);
extern pid_t vfork(void);
extern int execve(const char *path, char * const argv[],
     char *const environment[]);
extern int execl(const char *path, const char *arg, ...);
extern int execv(const char *path, char *const argv[]);
extern int execlp(const char *file, const char *arg, ...);
extern int execle(const char *path, const char *arg , ... );
extern int execvp(const char *file, char *const argv[]);
extern int execvpe(const char *file, char *const argv[],
     char *const environment[]);

extern void _exit(int status) __attribute__ ((noreturn));

extern pid_t tcgetpgrp(int fd);
extern int tcsetpgrp(int fd, pid_t pgrpid);

extern int brk(void *addr);
extern void *sbrk(intptr_t increment);

extern unsigned int alarm(unsigned int seconds);
extern useconds_t ualarm(useconds_t microSeconds, useconds_t interval);
extern unsigned int sleep(unsigned int seconds);
extern int usleep(unsigned int microSeconds);
extern int pause(void);


extern pid_t getpid(void);
extern pid_t getpgrp(void);
extern pid_t getppid(void);
extern pid_t getsid(pid_t pid);
extern pid_t getpgid(pid_t pid);

extern pid_t setsid(void);
extern int setpgid(pid_t pid, pid_t pgid);
extern pid_t setpgrp(void);

extern int chroot(const char *path);

extern int nice(int incr);


extern gid_t getegid(void);
extern uid_t geteuid(void);
extern gid_t getgid(void);
extern uid_t getuid(void);

extern int setgid(gid_t gid);
extern int setuid(uid_t uid);
extern int setegid(gid_t gid);
extern int seteuid(uid_t uid);
extern int setregid(gid_t rgid, gid_t egid);
extern int setreuid(uid_t ruid, uid_t euid);

extern int getgrouplist(const char* user, gid_t baseGroup,
     gid_t* groupList, int* groupCount);
extern int getgroups(int groupCount, gid_t groupList[]);
extern int initgroups(const char* user, gid_t baseGroup);
extern int setgroups(int groupCount, const gid_t* groupList);

extern char *getlogin(void);
extern int getlogin_r(char *name, size_t nameSize);


extern int sethostname(const char *hostName, size_t nameSize);
extern int gethostname(char *hostName, size_t nameSize);


extern int isatty(int fd);
extern char *ttyname(int fd);
extern int ttyname_r(int fd, char *buffer, size_t bufferSize);


extern char *crypt(const char *key, const char *salt);
extern void encrypt(char block[64], int edflag);
extern int getopt(int argc, char *const *argv, const char *shortOpts);
extern void swab(const void *src, void *dest, ssize_t nbytes);


extern char *optarg;
extern int optind, opterr, optopt;


}
extern "C" {


void endusershell(void);
char *getpass(const char *prompt);
char *getusershell(void);
int issetugid(void);
void setusershell(void);

int getentropy(void *buf, size_t buflen);


}
struct flock {
 short l_type;
 short l_whence;
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
};



extern "C" {


extern int creat(const char *path, mode_t mode);
extern int open(const char *path, int openMode, ...);


extern int openat(int fd, const char *path, int openMode, ...);

extern int fcntl(int fd, int op, ...);

extern int posix_fadvise(int fd, off_t offset, off_t len, int advice);
extern int posix_fallocate(int fd, off_t offset, off_t len);


}
enum node_flavor {
 B_FILE_NODE = 0x01,
 B_SYMLINK_NODE = 0x02,
 B_DIRECTORY_NODE = 0x04,
 B_ANY_NODE = 0x07
};



extern "C" {
enum {
 B_TIMEOUT = 0x8,
 B_RELATIVE_TIMEOUT = 0x8,

 B_ABSOLUTE_TIMEOUT = 0x10,



 B_TIMEOUT_REAL_TIME_BASE = 0x40,
 B_ABSOLUTE_REAL_TIME_TIMEOUT = B_ABSOLUTE_TIMEOUT
          | B_TIMEOUT_REAL_TIME_BASE
};




typedef int32 area_id;
typedef int32 port_id;
typedef int32 sem_id;
typedef int32 team_id;
typedef int32 thread_id;




typedef struct area_info {
 area_id area;
 char name[32];
 size_t size;
 uint32 lock;
 uint32 protection;
 team_id team;
 uint32 ram_size;
 uint32 copy_count;
 uint32 in_count;
 uint32 out_count;
 void *address;
} area_info;
extern area_id create_area(const char *name, void **startAddress,
      uint32 addressSpec, size_t size, uint32 lock,
      uint32 protection);
extern area_id clone_area(const char *name, void **destAddress,
      uint32 addressSpec, uint32 protection, area_id source);
extern area_id find_area(const char *name);
extern area_id area_for(void *address);
extern status_t delete_area(area_id id);
extern status_t resize_area(area_id id, size_t newSize);
extern status_t set_area_protection(area_id id, uint32 newProtection);


extern status_t _get_area_info(area_id id, area_info *areaInfo, size_t size);
extern status_t _get_next_area_info(team_id team, ssize_t *cookie,
      area_info *areaInfo, size_t size);
typedef struct port_info {
 port_id port;
 team_id team;
 char name[32];
 int32 capacity;
 int32 queue_count;
 int32 total_count;
} port_info;

extern port_id create_port(int32 capacity, const char *name);
extern port_id find_port(const char *name);
extern ssize_t read_port(port_id port, int32 *code, void *buffer,
      size_t bufferSize);
extern ssize_t read_port_etc(port_id port, int32 *code, void *buffer,
      size_t bufferSize, uint32 flags, bigtime_t timeout);
extern status_t write_port(port_id port, int32 code, const void *buffer,
      size_t bufferSize);
extern status_t write_port_etc(port_id port, int32 code, const void *buffer,
      size_t bufferSize, uint32 flags, bigtime_t timeout);
extern status_t close_port(port_id port);
extern status_t delete_port(port_id port);

extern ssize_t port_buffer_size(port_id port);
extern ssize_t port_buffer_size_etc(port_id port, uint32 flags,
      bigtime_t timeout);
extern ssize_t port_count(port_id port);
extern status_t set_port_owner(port_id port, team_id team);


extern status_t _get_port_info(port_id port, port_info *portInfo,
      size_t portInfoSize);
extern status_t _get_next_port_info(team_id team, int32 *cookie,
      port_info *portInfo, size_t portInfoSize);
typedef struct port_message_info {
 size_t size;
 uid_t sender;
 gid_t sender_group;
 team_id sender_team;
} port_message_info;


extern status_t _get_port_message_info_etc(port_id port,
      port_message_info *info, size_t infoSize, uint32 flags,
      bigtime_t timeout);







typedef struct sem_info {
 sem_id sem;
 team_id team;
 char name[32];
 int32 count;
 thread_id latest_holder;
} sem_info;


enum {
 B_CAN_INTERRUPT = 0x01,

 B_CHECK_PERMISSION = 0x04,

 B_KILL_CAN_INTERRUPT = 0x20,





 B_DO_NOT_RESCHEDULE = 0x02,
 B_RELEASE_ALL = 0x08,

 B_RELEASE_IF_WAITING_ONLY = 0x10

};

extern sem_id create_sem(int32 count, const char *name);
extern status_t delete_sem(sem_id id);
extern status_t acquire_sem(sem_id id);
extern status_t acquire_sem_etc(sem_id id, int32 count, uint32 flags,
      bigtime_t timeout);
extern status_t release_sem(sem_id id);
extern status_t release_sem_etc(sem_id id, int32 count, uint32 flags);


extern status_t switch_sem(sem_id semToBeReleased, sem_id id);
extern status_t switch_sem_etc(sem_id semToBeReleased, sem_id id,
      int32 count, uint32 flags, bigtime_t timeout);
extern status_t get_sem_count(sem_id id, int32 *threadCount);
extern status_t set_sem_owner(sem_id id, team_id team);


extern status_t _get_sem_info(sem_id id, struct sem_info *info,
      size_t infoSize);
extern status_t _get_next_sem_info(team_id team, int32 *cookie,
      struct sem_info *info, size_t infoSize);
typedef struct {
 team_id team;
 int32 thread_count;
 int32 image_count;
 int32 area_count;
 thread_id debugger_nub_thread;
 port_id debugger_nub_port;
 int32 argc;
 char args[64];
 uid_t uid;
 gid_t gid;


 uid_t real_uid;
 gid_t real_gid;
 pid_t group_id;
 pid_t session_id;
 team_id parent;
 char name[32];
 bigtime_t start_time;
} team_info;




extern status_t kill_team(team_id team);



extern status_t _get_team_info(team_id id, team_info *info, size_t size);
extern status_t _get_next_team_info(int32 *cookie, team_info *info,
      size_t size);
typedef struct {
 bigtime_t user_time;
 bigtime_t kernel_time;
} team_usage_info;

enum {

 B_TEAM_USAGE_SELF = 0,
 B_TEAM_USAGE_CHILDREN = -1
};


extern status_t _get_team_usage_info(team_id team, int32 who,
      team_usage_info *info, size_t size);







typedef enum {
 B_THREAD_RUNNING = 1,
 B_THREAD_READY,
 B_THREAD_RECEIVING,
 B_THREAD_ASLEEP,
 B_THREAD_SUSPENDED,
 B_THREAD_WAITING
} thread_state;

typedef struct {
 thread_id thread;
 team_id team;
 char name[32];
 thread_state state;
 int32 priority;
 sem_id sem;
 bigtime_t user_time;
 bigtime_t kernel_time;
 void *stack_base;
 void *stack_end;
} thread_info;
typedef status_t (*thread_func)(void *);



extern thread_id spawn_thread(thread_func, const char *name, int32 priority,
      void *data);
extern status_t kill_thread(thread_id thread);
extern status_t resume_thread(thread_id thread);
extern status_t suspend_thread(thread_id thread);

extern status_t rename_thread(thread_id thread, const char *newName);
extern status_t set_thread_priority(thread_id thread, int32 newPriority);
extern void exit_thread(status_t status);
extern status_t wait_for_thread(thread_id thread, status_t *returnValue);
extern status_t wait_for_thread_etc(thread_id id, uint32 flags, bigtime_t timeout,
      status_t *_returnCode);
extern status_t on_exit_thread(void (*callback)(void *), void *data);

extern thread_id find_thread(const char *name);

extern status_t send_data(thread_id thread, int32 code, const void *buffer,
      size_t bufferSize);
extern int32 receive_data(thread_id *sender, void *buffer,
      size_t bufferSize);
extern bool has_data(thread_id thread);

extern status_t snooze(bigtime_t amount);
extern status_t snooze_etc(bigtime_t amount, int timeBase, uint32 flags);
extern status_t snooze_until(bigtime_t time, int timeBase);


extern status_t _get_thread_info(thread_id id, thread_info *info, size_t size);
extern status_t _get_next_thread_info(team_id team, int32 *cookie,
      thread_info *info, size_t size);
extern thread_id get_pthread_thread_id(pthread_t thread);
extern unsigned long real_time_clock(void);
extern void set_real_time_clock(unsigned long secsSinceJan1st1970);
extern bigtime_t real_time_clock_usecs(void);
extern bigtime_t system_time(void);

extern nanotime_t system_time_nsecs(void);




enum {
 B_ONE_SHOT_ABSOLUTE_ALARM = 1,
 B_ONE_SHOT_RELATIVE_ALARM,
 B_PERIODIC_ALARM
};

extern bigtime_t set_alarm(bigtime_t when, uint32 flags);




extern void debugger(const char *message);
extern int disable_debugger(int state);


extern void debug_printf(const char *format, ...)
      __attribute__ ((format (__printf__, 1, 2)));
extern void debug_vprintf(const char *format, va_list args);
extern void ktrace_printf(const char *format, ...)
      __attribute__ ((format (__printf__, 1, 2)));
extern void ktrace_vprintf(const char *format, va_list args);




typedef struct {
 bigtime_t active_time;
 bool enabled;
 uint64 current_frequency;
} cpu_info;

typedef struct {
 bigtime_t boot_time;

 uint32 cpu_count;

 uint64 max_pages;
 uint64 used_pages;
 uint64 cached_pages;
 uint64 block_cache_pages;
 uint64 ignored_pages;

 uint64 needed_memory;
 uint64 free_memory;

 uint64 max_swap_pages;
 uint64 free_swap_pages;

 uint32 page_faults;

 uint32 max_sems;
 uint32 used_sems;

 uint32 max_ports;
 uint32 used_ports;

 uint32 max_threads;
 uint32 used_threads;

 uint32 max_teams;
 uint32 used_teams;

 char kernel_name[(256)];
 char kernel_build_date[32];
 char kernel_build_time[32];

 int64 kernel_version;
 uint32 abi;
} system_info;

enum topology_level_type {
 B_TOPOLOGY_UNKNOWN,
 B_TOPOLOGY_ROOT,
 B_TOPOLOGY_SMT,
 B_TOPOLOGY_CORE,
 B_TOPOLOGY_PACKAGE
};

enum cpu_platform {
 B_CPU_UNKNOWN,
 B_CPU_x86,
 B_CPU_x86_64,
 B_CPU_PPC,
 B_CPU_PPC_64,
 B_CPU_M68K,
 B_CPU_ARM,
 B_CPU_ARM_64,
 B_CPU_ALPHA,
 B_CPU_MIPS,
 B_CPU_SH,
 B_CPU_SPARC,
 B_CPU_RISC_V
};

enum cpu_vendor {
 B_CPU_VENDOR_UNKNOWN,
 B_CPU_VENDOR_AMD,
 B_CPU_VENDOR_CYRIX,
 B_CPU_VENDOR_IDT,
 B_CPU_VENDOR_INTEL,
 B_CPU_VENDOR_NATIONAL_SEMICONDUCTOR,
 B_CPU_VENDOR_RISE,
 B_CPU_VENDOR_TRANSMETA,
 B_CPU_VENDOR_VIA,
 B_CPU_VENDOR_IBM,
 B_CPU_VENDOR_MOTOROLA,
 B_CPU_VENDOR_NEC,
 B_CPU_VENDOR_HYGON,
 B_CPU_VENDOR_SUN,
 B_CPU_VENDOR_FUJITSU
};

typedef struct {
 enum cpu_platform platform;
} cpu_topology_root_info;

typedef struct {
 enum cpu_vendor vendor;
 uint32 cache_line_size;
} cpu_topology_package_info;

typedef struct {
 uint32 model;
 uint64 default_frequency;
} cpu_topology_core_info;

typedef struct {
 uint32 id;
 enum topology_level_type type;
 uint32 level;

 union {
  cpu_topology_root_info root;
  cpu_topology_package_info package;
  cpu_topology_core_info core;
 } data;
} cpu_topology_node_info;


extern status_t get_system_info(system_info* info);
extern status_t _get_cpu_info_etc(uint32 firstCPU, uint32 cpuCount,
      cpu_info* info, size_t size);



extern status_t get_cpu_topology_info(cpu_topology_node_info* topologyInfos,
      uint32* topologyInfoCount);


typedef union {
 struct {
  uint32 max_eax;
  char vendor_id[12];
 } eax_0;

 struct {
  uint32 stepping : 4;
  uint32 model : 4;
  uint32 family : 4;
  uint32 type : 2;
  uint32 reserved_0 : 2;
  uint32 extended_model : 4;
  uint32 extended_family : 8;
  uint32 reserved_1 : 4;

  uint32 brand_index : 8;
  uint32 clflush : 8;
  uint32 logical_cpus : 8;
  uint32 apic_id : 8;

  uint32 features;
  uint32 extended_features;
 } eax_1;

 struct {
  uint8 call_num;
  uint8 cache_descriptors[15];
 } eax_2;

 struct {
  uint32 reserved[2];
  uint32 serial_number_high;
  uint32 serial_number_low;
 } eax_3;

 char as_chars[16];

 struct {
  uint32 eax;
  uint32 ebx;
  uint32 edx;
  uint32 ecx;
 } regs;
} cpuid_info;

extern status_t get_cpuid(cpuid_info *info, uint32 eaxRegister,
      uint32 cpuNum);



extern int32 is_computer_on(void);
extern double is_computer_on_fire(void);



int send_signal(thread_id threadID, unsigned int signal);
void set_signal_stack(void* base, size_t size);




enum {
 B_OBJECT_TYPE_FD = 0,
 B_OBJECT_TYPE_SEMAPHORE = 1,
 B_OBJECT_TYPE_PORT = 2,
 B_OBJECT_TYPE_THREAD = 3
};

enum {
 B_EVENT_READ = 0x0001,
 B_EVENT_WRITE = 0x0002,
 B_EVENT_ERROR = 0x0004,
 B_EVENT_PRIORITY_READ = 0x0008,
 B_EVENT_PRIORITY_WRITE = 0x0010,
 B_EVENT_HIGH_PRIORITY_READ = 0x0020,
 B_EVENT_HIGH_PRIORITY_WRITE = 0x0040,
 B_EVENT_DISCONNECTED = 0x0080,

 B_EVENT_ACQUIRE_SEMAPHORE = 0x0001,

 B_EVENT_INVALID = 0x1000,


};

typedef struct object_wait_info {
 int32 object;
 uint16 type;
 uint16 events;
} object_wait_info;
extern ssize_t wait_for_objects(object_wait_info* infos, int numInfos);
extern ssize_t wait_for_objects_etc(object_wait_info* infos, int numInfos,
      uint32 flags, bigtime_t timeout);



}
extern "C" {




extern void *memchr(const void *source, int value, size_t length);
extern int memcmp(const void *buffer1, const void *buffer2, size_t length);
extern void *memcpy(void *dest, const void *source, size_t length);
extern void *memccpy(void *dest, const void *source, int stopByte, size_t length);
extern void *memmove(void *dest, const void *source, size_t length);
extern void *memset(void *dest, int value, size_t length);






extern char *strcpy(char *dest, const char *source);
extern char *strncpy(char *dest, const char *source, size_t length);
extern char *strcat(char *dest, const char *source);
extern char *strncat(char *dest, const char *source, size_t length);

extern size_t strlen(const char *string);
extern int strcmp(const char *string1, const char *string2);
extern int strncmp(const char *string1, const char *string2, size_t length);

extern char *strchr(const char *string, int character);
extern char *strrchr(const char *string, int character);
extern char *strstr(const char *string, const char *searchString);





extern char *strpbrk(const char *string, const char *set);
extern char *strtok(char *string, const char *set);
extern char *strtok_r(char *string, const char *set, char **savePointer);
extern size_t strspn(const char *string, const char *set);
extern size_t strcspn(const char *string, const char *set);

extern int strcoll(const char *string1, const char *string2);
extern size_t strxfrm(char *string1, const char *string2, size_t length);

extern char *strerror(int errorCode);
extern int strerror_r(int errorCode, char *buffer, size_t bufferSize);

extern char *strcasestr(const char *string, const char *searchString);

extern char *strdup(const char *string);
extern char *strndup(const char* string, size_t size);
extern char *stpcpy(char *dest, const char *source);
extern char *stpncpy(char *dest, const char *source, size_t size);

extern size_t strlcat(char *dest, const char *source, size_t length);
extern size_t strlcpy(char *dest, const char *source, size_t length);

extern size_t strnlen(const char *string, size_t count);

extern char *strlwr(char *string);
extern char *strupr(char *string);



extern const char *strsignal(int signum);


extern int strcoll_l(const char *string1, const char *string2, locale_t locale);
extern char *strerror_l(int errorCode, locale_t locale);
extern size_t strxfrm_l(char *string1, const char *string2, size_t length, locale_t locale);


extern "C" {


static __inline__ int ffs(int i) { return __builtin_ffs(i); }

extern int strcasecmp(const char *string1, const char *string2);
extern int strncasecmp(const char *string1, const char *string2,
 size_t length);

extern int strcasecmp_l(const char *string1, const char *string2, locale_t locale);
extern int strncasecmp_l(const char *string1, const char *string2,
 size_t length, locale_t locale);






extern char *index(const char *s, int c);
extern char *rindex(char const *s, int c);


}



}







extern "C" {


char* strsep(char** string, const char* delimiters);
void explicit_bzero(void *buf, size_t len);


}




class BStringList;
class BStringRef;


class BString {
public:
       BString();
       BString(const char* string);
       BString(const BString& string);
       BString(const char* string, int32 maxLength);

       BString(BString&& string) noexcept;

       ~BString();


   const char* String() const;
   int32 Length() const;
   int32 CountChars() const;
   int32 CountBytes(int32 fromCharOffset,
        int32 charCount) const;
   bool IsEmpty() const;

   uint32 HashValue() const;
 static uint32 HashValue(const char* string);


   BString& operator=(const BString& string);
   BString& operator=(const char* string);
   BString& operator=(char c);

   BString& operator=(BString&& string) noexcept;


   BString& SetTo(const char* string);
   BString& SetTo(const char* string, int32 maxLength);

   BString& SetTo(const BString& string);
   BString& Adopt(BString& from);

   BString& SetTo(const BString& string, int32 maxLength);
   BString& Adopt(BString& from, int32 maxLength);

   BString& SetTo(char c, int32 count);

   BString& SetToChars(const char* string, int32 charCount);
   BString& SetToChars(const BString& string, int32 charCount);
   BString& AdoptChars(BString& from, int32 charCount);

   BString& SetToFormat(const char* format, ...)
        __attribute__((__format__(__printf__, 2, 3)));
   BString& SetToFormatVarArgs(const char* format,
        va_list args)
        __attribute__((__format__(__printf__, 2, 0)));

   int ScanWithFormat(const char* format, ...)
        __attribute__((__format__(__scanf__, 2, 3)));
   int ScanWithFormatVarArgs(const char* format,
        va_list args)
        __attribute__((__format__(__scanf__, 2, 0)));


   BString& CopyInto(BString& into, int32 fromOffset,
        int32 length) const;
   void CopyInto(char* into, int32 fromOffset,
        int32 length) const;

   BString& CopyCharsInto(BString& into, int32 fromCharOffset,
        int32 charCount) const;
   bool CopyCharsInto(char* into, int32* intoLength,
        int32 fromCharOffset, int32 charCount) const;

   bool Split(const char* separator, bool noEmptyStrings,
        BStringList& _list) const;


   BString& operator+=(const BString& string);
   BString& operator+=(const char* string);
   BString& operator+=(char c);

   BString& Append(const BString& string);
   BString& Append(const char* string);

   BString& Append(const BString& string, int32 length);
   BString& Append(const char* string, int32 length);
   BString& Append(char c, int32 count);

   BString& AppendChars(const BString& string, int32 charCount);
   BString& AppendChars(const char* string, int32 charCount);


   BString& Prepend(const char* string);
   BString& Prepend(const BString& string);
   BString& Prepend(const char* string, int32 length);
   BString& Prepend(const BString& string, int32 length);
   BString& Prepend(char c, int32 count);

   BString& PrependChars(const char* string, int32 charCount);
   BString& PrependChars(const BString& string,
        int32 charCount);


   BString& Insert(const char* string, int32 position);
   BString& Insert(const char* string, int32 length,
        int32 position);
   BString& Insert(const char* string, int32 fromOffset,
        int32 length, int32 position);
   BString& Insert(const BString& string, int32 position);
   BString& Insert(const BString& string, int32 length,
        int32 position);
   BString& Insert(const BString& string, int32 fromOffset,
        int32 length, int32 position);
   BString& Insert(char c, int32 count, int32 position);

   BString& InsertChars(const char* string, int32 charPosition);
   BString& InsertChars(const char* string, int32 charCount,
        int32 charPosition);
   BString& InsertChars(const char* string,
        int32 fromCharOffset, int32 charCount,
        int32 charPosition);
   BString& InsertChars(const BString& string,
        int32 charPosition);
   BString& InsertChars(const BString& string, int32 charCount,
        int32 charPosition);
   BString& InsertChars(const BString& string,
        int32 fromCharOffset, int32 charCount,
        int32 charPosition);


   BString& Truncate(int32 newLength, bool lazy = true);
   BString& TruncateChars(int32 newCharCount, bool lazy = true);

   BString& Remove(int32 from, int32 length);
   BString& RemoveChars(int32 fromCharOffset, int32 charCount);

   BString& RemoveFirst(const BString& string);
   BString& RemoveLast(const BString& string);
   BString& RemoveAll(const BString& string);

   BString& RemoveFirst(const char* string);
   BString& RemoveLast(const char* string);
   BString& RemoveAll(const char* string);

   BString& RemoveSet(const char* setOfBytesToRemove);
   BString& RemoveCharsSet(const char* setOfCharsToRemove);

   BString& MoveInto(BString& into, int32 from, int32 length);
   void MoveInto(char* into, int32 from, int32 length);

   BString& MoveCharsInto(BString& into, int32 fromCharOffset,
        int32 charCount);
   bool MoveCharsInto(char* into, int32* intoLength,
        int32 fromCharOffset, int32 charCount);


   bool operator<(const BString& string) const;
   bool operator<=(const BString& string) const;
   bool operator==(const BString& string) const;
   bool operator>=(const BString& string) const;
   bool operator>(const BString& string) const;
   bool operator!=(const BString& string) const;

   bool operator<(const char* string) const;
   bool operator<=(const char* string) const;
   bool operator==(const char* string) const;
   bool operator>=(const char* string) const;
   bool operator>(const char* string) const;
   bool operator!=(const char* string) const;

       operator const char*() const;


   int Compare(const BString& string) const;
   int Compare(const char* string) const;
   int Compare(const BString& string, int32 length) const;
   int Compare(const char* string, int32 length) const;

   int CompareAt(size_t offset, const BString& string,
        int32 length) const;

   int CompareChars(const BString& string,
        int32 charCount) const;
   int CompareChars(const char* string,
        int32 charCount) const;

   int ICompare(const BString& string) const;
   int ICompare(const char* string) const;
   int ICompare(const BString& string, int32 length) const;
   int ICompare(const char* string, int32 length) const;


   int32 FindFirst(const BString& string) const;
   int32 FindFirst(const char* string) const;
   int32 FindFirst(const BString& string,
        int32 fromOffset) const;
   int32 FindFirst(const char* string,
        int32 fromOffset) const;
   int32 FindFirst(char c) const;
   int32 FindFirst(char c, int32 fromOffset) const;

   int32 FindFirstChars(const BString& string,
        int32 fromCharOffset) const;
   int32 FindFirstChars(const char* string,
        int32 fromCharOffset) const;

   int32 FindLast(const BString& string) const;
   int32 FindLast(const char* string) const;
   int32 FindLast(const BString& string,
        int32 beforeOffset) const;
   int32 FindLast(const char* string,
        int32 beforeOffset) const;
   int32 FindLast(char c) const;
   int32 FindLast(char c, int32 beforeOffset) const;

   int32 FindLastChars(const BString& string,
        int32 beforeCharOffset) const;
   int32 FindLastChars(const char* string,
        int32 beforeCharOffset) const;

   int32 IFindFirst(const BString& string) const;
   int32 IFindFirst(const char* string) const;
   int32 IFindFirst(const BString& string,
        int32 fromOffset) const;
   int32 IFindFirst(const char* string,
        int32 fromOffset) const;

   int32 IFindLast(const BString& string) const;
   int32 IFindLast(const char* string) const;
   int32 IFindLast(const BString& string,
        int32 beforeOffset) const;
   int32 IFindLast(const char* string,
        int32 beforeOffset) const;

   bool StartsWith(const BString& string) const;
   bool StartsWith(const char* string) const;
   bool StartsWith(const char* string, int32 length) const;

   bool IStartsWith(const BString& string) const;
   bool IStartsWith(const char* string) const;
   bool IStartsWith(const char* string, int32 length) const;

   bool EndsWith(const BString& string) const;
   bool EndsWith(const char* string) const;
   bool EndsWith(const char* string, int32 length) const;

   bool IEndsWith(const BString& string) const;
   bool IEndsWith(const char* string) const;
   bool IEndsWith(const char* string, int32 length) const;


   BString& ReplaceFirst(char replaceThis, char withThis);
   BString& ReplaceLast(char replaceThis, char withThis);
   BString& ReplaceAll(char replaceThis, char withThis,
        int32 fromOffset = 0);
   BString& Replace(char replaceThis, char withThis,
        int32 maxReplaceCount, int32 fromOffset = 0);
   BString& ReplaceFirst(const char* replaceThis,
        const char* withThis);
   BString& ReplaceLast(const char* replaceThis,
        const char* withThis);
   BString& ReplaceAll(const char* replaceThis,
        const char* withThis, int32 fromOffset = 0);
   BString& Replace(const char* replaceThis,
        const char* withThis, int32 maxReplaceCount,
        int32 fromOffset = 0);

   BString& ReplaceAllChars(const char* replaceThis,
        const char* withThis, int32 fromCharOffset);
   BString& ReplaceChars(const char* replaceThis,
        const char* withThis, int32 maxReplaceCount,
        int32 fromCharOffset);

   BString& IReplaceFirst(char replaceThis, char withThis);
   BString& IReplaceLast(char replaceThis, char withThis);
   BString& IReplaceAll(char replaceThis, char withThis,
        int32 fromOffset = 0);
   BString& IReplace(char replaceThis, char withThis,
        int32 maxReplaceCount, int32 fromOffset = 0);
   BString& IReplaceFirst(const char* replaceThis,
        const char* withThis);
   BString& IReplaceLast(const char* replaceThis,
        const char* withThis);
   BString& IReplaceAll(const char* replaceThis,
        const char* withThis, int32 fromOffset = 0);
   BString& IReplace(const char* replaceThis,
        const char* withThis, int32 maxReplaceCount,
        int32 fromOffset = 0);

   BString& ReplaceSet(const char* setOfBytes, char with);
   BString& ReplaceSet(const char* setOfBytes,
        const char* with);

   BString& ReplaceCharsSet(const char* setOfChars,
        const char* with);


   char operator[](int32 index) const;






   char ByteAt(int32 index) const;
   const char* CharAt(int32 charIndex, int32* bytes = __null) const;
   bool CharAt(int32 charIndex, char* buffer,
        int32* bytes) const;


   char* LockBuffer(int32 maxLength);
   BString& UnlockBuffer(int32 length = -1);
   BString& SetByteAt(int32 pos, char to);


   BString& ToLower();
   BString& ToUpper();

   BString& Capitalize();
   BString& CapitalizeEachWord();


   BString& CharacterEscape(const char* original,
        const char* setOfCharsToEscape,
        char escapeWith);
   BString& CharacterEscape(const char* setOfCharsToEscape,
        char escapeWith);
   BString& CharacterDeescape(const char* original,
        char escapeChar);
   BString& CharacterDeescape(char escapeChar);


   BString& Trim();


   BString& operator<<(const char* string);
   BString& operator<<(const BString& string);
   BString& operator<<(char c);
   BString& operator<<(bool value);
   BString& operator<<(int value);
   BString& operator<<(unsigned int value);
   BString& operator<<(unsigned long value);
   BString& operator<<(long value);
   BString& operator<<(unsigned long long value);
   BString& operator<<(long long value);

   BString& operator<<(float value);
   BString& operator<<(double value);

public:
   class Private;
   friend class Private;

private:
   class PosVect;
   friend class BStringRef;

   enum PrivateDataTag {
    PRIVATE_DATA
   };

private:
       BString(char* privateData, PrivateDataTag tag);


   status_t _MakeWritable();
   status_t _MakeWritable(int32 length, bool copy);
 static char* _Allocate(int32 length);
   char* _Resize(int32 length);
   void _Init(const char* src, int32 length);
   char* _Clone(const char* data, int32 length);
   char* _OpenAtBy(int32 offset, int32 length);
   char* _ShrinkAtBy(int32 offset, int32 length);


   void _SetLength(int32 length);
   bool _DoAppend(const char* string, int32 length);
   bool _DoPrepend(const char* string, int32 length);
   bool _DoInsert(const char* string, int32 offset,
        int32 length);


   int32 _ShortFindAfter(const char* string,
        int32 length) const;
   int32 _FindAfter(const char* string, int32 offset,
        int32 length) const;
   int32 _IFindAfter(const char* string, int32 offset,
        int32 length) const;
   int32 _FindBefore(const char* string, int32 offset,
        int32 length) const;
   int32 _IFindBefore(const char* string, int32 offset,
        int32 length) const;


   BString& _DoCharacterEscape(const char* string,
        const char* setOfCharsToEscape, char escapeChar);
   BString& _DoCharacterDeescape(const char* string,
        char escapeChar);


   BString& _DoReplace(const char* findThis,
        const char* replaceWith, int32 maxReplaceCount,
        int32 fromOffset, bool ignoreCase);
   void _ReplaceAtPositions(const PosVect* positions,
        int32 searchLength, const char* with,
        int32 withLength);

private:
   int32& _ReferenceCount();
   const int32& _ReferenceCount() const;
   bool _IsShareable() const;
   void _FreePrivateData();
   void _ReleasePrivateData();

   char* fPrivateData;
};



bool operator<(const char* a, const BString& b);
bool operator<=(const char* a, const BString& b);
bool operator==(const char* a, const BString& b);
bool operator>(const char* a, const BString& b);
bool operator>=(const char* a, const BString& b);
bool operator!=(const char* a, const BString& b);



int Compare(const BString& a, const BString& b);
int ICompare(const BString& a, const BString& b);
int Compare(const BString* a, const BString* b);
int ICompare(const BString* a, const BString* b);


inline int32
BString::Length() const
{


 return fPrivateData ? (*(((int32*)fPrivateData) - 1) & 0x7fffffff) : 0;
}


inline bool
BString::IsEmpty() const
{
 return !Length();
}


inline const char*
BString::String() const
{
 if (!fPrivateData)
  return "";
 return fPrivateData;
}


inline uint32
BString::HashValue() const
{
 return HashValue(String());
}


inline BString&
BString::SetTo(const char* string)
{
 return operator=(string);
}


inline char
BString::operator[](int32 index) const
{
 return fPrivateData[index];
}


inline char
BString::ByteAt(int32 index) const
{
 if (!fPrivateData || index < 0 || index >= Length())
  return 0;
 return fPrivateData[index];
}


inline BString&
BString::operator+=(const BString& string)
{
 _DoAppend(string.String(), string.Length());
 return *this;
}


inline BString&
BString::Append(const BString& string)
{
 _DoAppend(string.String(), string.Length());
 return *this;
}


inline BString&
BString::Append(const char* string)
{
 return operator+=(string);
}


inline bool
BString::operator==(const BString& string) const
{
 return strcmp(String(), string.String()) == 0;
}


inline bool
BString::operator<(const BString& string) const
{
 return strcmp(String(), string.String()) < 0;
}


inline bool
BString::operator<=(const BString& string) const
{
 return strcmp(String(), string.String()) <= 0;
}


inline bool
BString::operator>=(const BString& string) const
{
 return strcmp(String(), string.String()) >= 0;
}


inline bool
BString::operator>(const BString& string) const
{
 return strcmp(String(), string.String()) > 0;
}


inline bool
BString::operator!=(const BString& string) const
{
 return strcmp(String(), string.String()) != 0;
}


inline bool
BString::operator!=(const char* string) const
{
 return !operator==(string);
}


inline
BString::operator const char*() const
{
 return String();
}


inline bool
operator<(const char* str, const BString& string)
{
 return string > str;
}


inline bool
operator<=(const char* str, const BString& string)
{
 return string >= str;
}


inline bool
operator==(const char* str, const BString& string)
{
 return string == str;
}


inline bool
operator>(const char* str, const BString& string)
{
 return string < str;
}


inline bool
operator>=(const char* str, const BString& string)
{
 return string <= str;
}


inline bool
operator!=(const char* str, const BString& string)
{
 return string != str;
}


class BBitmap;
class BMessage;
class BPoint;
class BRect;
struct key_info {
 uint32 modifiers;
 uint8 key_states[16];
};

enum {
 B_BACKSPACE = 0x08,
 B_RETURN = 0x0a,
 B_ENTER = 0x0a,
 B_SPACE = 0x20,
 B_TAB = 0x09,
 B_ESCAPE = 0x1b,
 B_SUBSTITUTE = 0x1a,

 B_LEFT_ARROW = 0x1c,
 B_RIGHT_ARROW = 0x1d,
 B_UP_ARROW = 0x1e,
 B_DOWN_ARROW = 0x1f,

 B_INSERT = 0x05,
 B_DELETE = 0x7f,
 B_HOME = 0x01,
 B_END = 0x04,
 B_PAGE_UP = 0x0b,
 B_PAGE_DOWN = 0x0c,

 B_FUNCTION_KEY = 0x10,


 B_KATAKANA_HIRAGANA = 0xf2,
 B_HANKAKU_ZENKAKU = 0xf3,
 B_HANGUL = 0xf0,
 B_HANGUL_HANJA = 0xf1
};

enum {
 B_F1_KEY = 0x02,
 B_F2_KEY = 0x03,
 B_F3_KEY = 0x04,
 B_F4_KEY = 0x05,
 B_F5_KEY = 0x06,
 B_F6_KEY = 0x07,
 B_F7_KEY = 0x08,
 B_F8_KEY = 0x09,
 B_F9_KEY = 0x0a,
 B_F10_KEY = 0x0b,
 B_F11_KEY = 0x0c,
 B_F12_KEY = 0x0d,
 B_PRINT_KEY = 0x0e,
 B_SCROLL_KEY = 0x0f,
 B_PAUSE_KEY = 0x10
};

struct key_map {
 uint32 version;
 uint32 caps_key;
 uint32 scroll_key;
 uint32 num_key;
 uint32 left_shift_key;
 uint32 right_shift_key;
 uint32 left_command_key;
 uint32 right_command_key;
 uint32 left_control_key;
 uint32 right_control_key;
 uint32 left_option_key;
 uint32 right_option_key;
 uint32 menu_key;
 uint32 lock_settings;
 int32 control_map[128];
 int32 option_caps_shift_map[128];
 int32 option_caps_map[128];
 int32 option_shift_map[128];
 int32 option_map[128];
 int32 caps_shift_map[128];
 int32 caps_map[128];
 int32 shift_map[128];
 int32 normal_map[128];
 int32 acute_dead_key[32];
 int32 grave_dead_key[32];
 int32 circumflex_dead_key[32];
 int32 dieresis_dead_key[32];
 int32 tilde_dead_key[32];
 uint32 acute_tables;
 uint32 grave_tables;
 uint32 circumflex_tables;
 uint32 dieresis_tables;
 uint32 tilde_tables;
};

enum {
 B_CONTROL_TABLE = 0x00000001,
 B_OPTION_CAPS_SHIFT_TABLE = 0x00000002,
 B_OPTION_CAPS_TABLE = 0x00000004,
 B_OPTION_SHIFT_TABLE = 0x00000008,
 B_OPTION_TABLE = 0x00000010,
 B_CAPS_SHIFT_TABLE = 0x00000020,
 B_CAPS_TABLE = 0x00000040,
 B_SHIFT_TABLE = 0x00000080,
 B_NORMAL_TABLE = 0x00000100
};


enum {
 B_SHIFT_KEY = 0x00000001,
 B_COMMAND_KEY = 0x00000002,
 B_CONTROL_KEY = 0x00000004,
 B_CAPS_LOCK = 0x00000008,
 B_SCROLL_LOCK = 0x00000010,
 B_NUM_LOCK = 0x00000020,
 B_OPTION_KEY = 0x00000040,
 B_MENU_KEY = 0x00000080,
 B_LEFT_SHIFT_KEY = 0x00000100,
 B_RIGHT_SHIFT_KEY = 0x00000200,
 B_LEFT_COMMAND_KEY = 0x00000400,
 B_RIGHT_COMMAND_KEY = 0x00000800,
 B_LEFT_CONTROL_KEY = 0x00001000,
 B_RIGHT_CONTROL_KEY = 0x00002000,
 B_LEFT_OPTION_KEY = 0x00004000,
 B_RIGHT_OPTION_KEY = 0x00008000
};




struct mouse_map {
 uint32 button[16];
};

enum mode_mouse {
 B_NORMAL_MOUSE = 0,
 B_CLICK_TO_FOCUS_MOUSE = -1,
 B_FOCUS_FOLLOWS_MOUSE = 1
};

enum mode_focus_follows_mouse {
 B_NORMAL_FOCUS_FOLLOWS_MOUSE = 0,
 B_WARP_FOCUS_FOLLOWS_MOUSE = 1,
 B_INSTANT_WARP_FOCUS_FOLLOWS_MOUSE = 2
};




enum border_style {
 B_PLAIN_BORDER,
 B_FANCY_BORDER,
 B_NO_BORDER
};

enum orientation {
 B_HORIZONTAL,
 B_VERTICAL
};

enum button_width {
 B_WIDTH_AS_USUAL,
 B_WIDTH_FROM_WIDEST,
 B_WIDTH_FROM_LABEL
};

struct scroll_bar_info {
 bool proportional;
 bool double_arrows;
 int32 knob;
 int32 min_knob_size;
};

enum alignment {
 B_ALIGN_LEFT,
 B_ALIGN_RIGHT,
 B_ALIGN_CENTER,

 B_ALIGN_HORIZONTAL_CENTER = B_ALIGN_CENTER,

 B_ALIGN_HORIZONTAL_UNSET = -1L,
 B_ALIGN_USE_FULL_WIDTH = -2L
};

enum vertical_alignment {
 B_ALIGN_TOP = 0x10L,
 B_ALIGN_MIDDLE = 0x20,
 B_ALIGN_BOTTOM = 0x30,

 B_ALIGN_VERTICAL_CENTER = B_ALIGN_MIDDLE,

 B_ALIGN_VERTICAL_UNSET = -1L,
 B_ALIGN_NO_VERTICAL = B_ALIGN_VERTICAL_UNSET,
 B_ALIGN_USE_FULL_HEIGHT = -2L
};





enum {
 B_USE_DEFAULT_SPACING = -1002,
 B_USE_ITEM_SPACING = -1003,
 B_USE_ITEM_INSETS = B_USE_ITEM_SPACING,
 B_USE_HALF_ITEM_SPACING = -1004,
 B_USE_HALF_ITEM_INSETS = B_USE_HALF_ITEM_SPACING,
 B_USE_WINDOW_SPACING = -1005,
 B_USE_WINDOW_INSETS = B_USE_WINDOW_SPACING,
 B_USE_SMALL_SPACING = -1006,
 B_USE_SMALL_INSETS = B_USE_SMALL_SPACING,
 B_USE_CORNER_SPACING = -1007,
 B_USE_CORNER_INSETS = B_USE_CORNER_SPACING,
 B_USE_BIG_SPACING = -1008,
 B_USE_BIG_INSETS = B_USE_BIG_SPACING,
 B_USE_BORDER_SPACING = -1009,
 B_USE_BORDER_INSETS = B_USE_BORDER_SPACING,
};




enum join_mode {
 B_ROUND_JOIN = 0,
 B_MITER_JOIN,
 B_BEVEL_JOIN,
 B_BUTT_JOIN,
 B_SQUARE_JOIN
};

enum cap_mode {
 B_ROUND_CAP = B_ROUND_JOIN,
 B_BUTT_CAP = B_BUTT_JOIN,
 B_SQUARE_CAP = B_SQUARE_JOIN
};

const float B_DEFAULT_MITER_LIMIT = 10.0F;




enum {
 B_EVEN_ODD = 0,
 B_NONZERO
};




enum bitmap_tiling {
 B_TILE_BITMAP_X = 0x00000001,
 B_TILE_BITMAP_Y = 0x00000002,
 B_TILE_BITMAP = 0x00000003
};

enum overlay_options {
 B_OVERLAY_FILTER_HORIZONTAL = 0x00010000,
 B_OVERLAY_FILTER_VERTICAL = 0x00020000,
 B_OVERLAY_MIRROR = 0x00040000,
 B_OVERLAY_TRANSFER_CHANNEL = 0x00080000
};

enum bitmap_drawing_options {
 B_FILTER_BITMAP_BILINEAR = 0x00000100,

 B_WAIT_FOR_RETRACE = 0x00000800
};




enum color_which {
 B_NO_COLOR = 0,
 B_PANEL_BACKGROUND_COLOR = 1,
 B_PANEL_TEXT_COLOR = 10,
 B_DOCUMENT_BACKGROUND_COLOR = 11,
 B_DOCUMENT_TEXT_COLOR = 12,
 B_CONTROL_BACKGROUND_COLOR = 13,
 B_CONTROL_TEXT_COLOR = 14,
 B_CONTROL_BORDER_COLOR = 15,
 B_CONTROL_HIGHLIGHT_COLOR = 16,
 B_CONTROL_MARK_COLOR = 27,
 B_NAVIGATION_BASE_COLOR = 4,
 B_NAVIGATION_PULSE_COLOR = 17,
 B_SHINE_COLOR = 18,
 B_SHADOW_COLOR = 19,

 B_LINK_TEXT_COLOR = 33,
 B_LINK_HOVER_COLOR = 34,
 B_LINK_VISITED_COLOR = 35,
 B_LINK_ACTIVE_COLOR = 36,

 B_MENU_BACKGROUND_COLOR = 2,
 B_MENU_SELECTED_BACKGROUND_COLOR = 6,
 B_MENU_ITEM_TEXT_COLOR = 7,
 B_MENU_SELECTED_ITEM_TEXT_COLOR = 8,
 B_MENU_SELECTED_BORDER_COLOR = 9,

 B_LIST_BACKGROUND_COLOR = 28,
 B_LIST_SELECTED_BACKGROUND_COLOR = 29,
 B_LIST_ITEM_TEXT_COLOR = 30,
 B_LIST_SELECTED_ITEM_TEXT_COLOR = 31,

 B_SCROLL_BAR_THUMB_COLOR = 32,

 B_TOOL_TIP_BACKGROUND_COLOR = 20,
 B_TOOL_TIP_TEXT_COLOR = 21,

 B_STATUS_BAR_COLOR = 37,

 B_SUCCESS_COLOR = 100,
 B_FAILURE_COLOR = 101,

 B_WINDOW_TAB_COLOR = 3,
 B_WINDOW_TEXT_COLOR = 22,
 B_WINDOW_INACTIVE_TAB_COLOR = 23,
 B_WINDOW_INACTIVE_TEXT_COLOR = 24,

 B_WINDOW_BORDER_COLOR = 25,
 B_WINDOW_INACTIVE_BORDER_COLOR = 26,


 B_KEYBOARD_NAVIGATION_COLOR = B_NAVIGATION_BASE_COLOR,
 B_MENU_SELECTION_BACKGROUND_COLOR = B_MENU_SELECTED_BACKGROUND_COLOR,


 B_DESKTOP_COLOR = 5

};




const float B_LIGHTEN_MAX_TINT = 0.0f;
const float B_LIGHTEN_2_TINT = 0.385f;
const float B_LIGHTEN_1_TINT = 0.590f;

const float B_NO_TINT = 1.0f;

const float B_DARKEN_1_TINT = 1.147f;
const float B_DARKEN_2_TINT = 1.295f;
const float B_DARKEN_3_TINT = 1.407f;
const float B_DARKEN_4_TINT = 1.555f;
const float B_DARKEN_MAX_TINT = 2.0f;


const float B_DISABLED_LABEL_TINT = B_DARKEN_3_TINT;
const float B_HIGHLIGHT_BACKGROUND_TINT = B_DARKEN_2_TINT;
const float B_DISABLED_MARK_TINT = B_LIGHTEN_2_TINT;






enum {
 B_INACTIVE_ICON_BITMAP = 0x00,
 B_ACTIVE_ICON_BITMAP = 0x01,
 B_PARTIALLY_ACTIVATE_ICON_BITMAP = 0x02,


 B_DISABLED_ICON_BITMAP = 0x80,

};


enum {
 B_KEEP_ICON_BITMAP = 0x0001,

};


enum {
 B_TRIM_ICON_BITMAP = 0x0100,


 B_TRIM_ICON_BITMAP_KEEP_ASPECT = 0x0200,

 B_CREATE_ACTIVE_ICON_BITMAP = 0x0400,
 B_CREATE_PARTIALLY_ACTIVE_ICON_BITMAP = 0x0800,
 B_CREATE_DISABLED_ICON_BITMAPS = 0x1000,
};


status_t get_deskbar_frame(BRect* frame);

const color_map* system_colors();

status_t set_screen_space(int32 index, uint32 resolution,
     bool save = true);

status_t get_scroll_bar_info(scroll_bar_info* info);
status_t set_scroll_bar_info(scroll_bar_info* info);

status_t get_mouse_type(int32* type);
status_t get_mouse_type(const char* mouse_name, int32* type);
status_t set_mouse_type(const char* mouse_name, int32 type);
status_t get_mouse_map(mouse_map* map);
status_t set_mouse_map(mouse_map* map);
status_t get_click_speed(bigtime_t* speed);
status_t set_click_speed(bigtime_t speed);
status_t get_mouse_speed(int32* speed);
status_t get_mouse_speed(const char* mouse_name, int32* speed);
status_t set_mouse_speed(const char* mouse_name, int32 speed);
status_t get_mouse_acceleration(int32* speed);
status_t get_mouse_acceleration(const char* mouse_name, int32* speed);
status_t set_mouse_acceleration(const char* mouse_name, int32 speed);

status_t get_key_repeat_rate(int32* rate);
status_t set_key_repeat_rate(int32 rate);
status_t get_key_repeat_delay(bigtime_t* delay);
status_t set_key_repeat_delay(bigtime_t delay);

uint32 modifiers();
status_t get_key_info(key_info* info);
void get_key_map(key_map** _map, char** _keyBuffer);
status_t get_keyboard_id(uint16* _id);
status_t get_modifier_key(uint32 modifier, uint32 *key);
void set_modifier_key(uint32 modifier, uint32 key);
void set_keyboard_locks(uint32 modifiers);

rgb_color keyboard_navigation_color();

int32 count_workspaces();
void set_workspace_count(int32 count);
int32 current_workspace();
void activate_workspace(int32 workspace);

bigtime_t idle_time();

void run_select_printer_panel();
void run_add_printer_panel();
void run_be_about();

void set_focus_follows_mouse(bool follow);
bool focus_follows_mouse();

void set_mouse_mode(mode_mouse mode);
mode_mouse mouse_mode();

void set_focus_follows_mouse_mode(mode_focus_follows_mouse mode);
mode_focus_follows_mouse focus_follows_mouse_mode();

status_t get_mouse(BPoint* screenWhere, uint32* buttons);
status_t get_mouse_bitmap(BBitmap** bitmap, BPoint* hotspot);

void set_accept_first_click(bool acceptFirstClick);
bool accept_first_click();

rgb_color ui_color(color_which which);
const char* ui_color_name(color_which which);
color_which which_ui_color(const char* name);
void set_ui_color(const color_which& which, const rgb_color& color);
void set_ui_colors(const BMessage* colors);
rgb_color tint_color(rgb_color color, float tint);

extern "C" status_t _init_interface_kit_();
typedef int32 image_id;

typedef enum {
 B_APP_IMAGE = 1,
 B_LIBRARY_IMAGE,
 B_ADD_ON_IMAGE,
 B_SYSTEM_IMAGE
} image_type;

typedef struct {
 image_id id;
 image_type type;
 int32 sequence;
 int32 init_order;
 void (*init_routine)();
 void (*term_routine)();
 dev_t device;
 ino_t node;
 char name[(1024)];
 void *text;
 void *data;
 int32 text_size;
 int32 data_size;


 int32 api_version;
 int32 abi;
} image_info;



extern "C" {
void initialize_before(image_id self);
void initialize_after(image_id self);
void terminate_before(image_id self);
void terminate_after(image_id self);
thread_id load_image(int32 argc, const char **argv, const char **environ);
image_id load_add_on(const char *path);
status_t unload_add_on(image_id image);
status_t get_image_symbol(image_id image, const char *name, int32 symbolType,
    void **_symbolLocation);
status_t get_nth_image_symbol(image_id image, int32 n, char *nameBuffer,
    int32 *_nameLength, int32 *_symbolType, void **_symbolLocation);
void clear_caches(void *address, size_t length, uint32 flags);







status_t _get_image_info(image_id image, image_info *info, size_t size);
status_t _get_next_image_info(team_id team, int32 *cookie, image_info *info,
    size_t size);



}
       

namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;




  extern "C++" __attribute__ ((__noreturn__, __always_inline__))
  inline void __terminate() noexcept
  {
    void terminate() noexcept __attribute__ ((__noreturn__));
    terminate();
  }
}
namespace std
{




  constexpr inline bool
  __is_constant_evaluated() noexcept
  {





    return __builtin_is_constant_evaluated();



  }
}


       



extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };



}

}


extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };



  enum class align_val_t: size_t {};


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
[[__nodiscard__]] void* operator new(std::size_t)
  __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete(void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete[](void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));




[[__nodiscard__]] inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
[[__nodiscard__]] inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}


namespace std
{



  template<typename _Tp>
    [[nodiscard]] constexpr _Tp*
    launder(_Tp* __p) noexcept
    { return __builtin_launder(__p); }




  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args...) noexcept (_NE)) = delete;
  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args......) noexcept (_NE)) = delete;

  void launder(void*) = delete;
  void launder(const void*) = delete;
  void launder(volatile void*) = delete;
  void launder(const volatile void*) = delete;




  inline constexpr size_t hardware_destructive_interference_size = 64;
  inline constexpr size_t hardware_constructive_interference_size = 64;

}


class BDataIO {
public:
        BDataIO();
 virtual ~BDataIO();

 virtual ssize_t Read(void* buffer, size_t size);
 virtual ssize_t Write(const void* buffer, size_t size);

 virtual status_t Flush();

   status_t ReadExactly(void* buffer, size_t size,
         size_t* _bytesRead = __null);
   status_t WriteExactly(const void* buffer, size_t size,
         size_t* _bytesWritten = __null);

private:
        BDataIO(const BDataIO&);
   BDataIO& operator=(const BDataIO&);

 virtual void _ReservedDataIO2();
 virtual void _ReservedDataIO3();
 virtual void _ReservedDataIO4();
 virtual void _ReservedDataIO5();
 virtual void _ReservedDataIO6();
 virtual void _ReservedDataIO7();
 virtual void _ReservedDataIO8();
 virtual void _ReservedDataIO9();
 virtual void _ReservedDataIO10();
 virtual void _ReservedDataIO11();
 virtual void _ReservedDataIO12();

private:
   uint32 _reserved[2];
};


class BPositionIO : public BDataIO {
public:
        BPositionIO();
 virtual ~BPositionIO();


 virtual ssize_t Read(void* buffer, size_t size);
 virtual ssize_t Write(const void* buffer, size_t size);


 virtual ssize_t ReadAt(off_t position, void* buffer,
         size_t size) = 0;
 virtual ssize_t WriteAt(off_t position, const void* buffer,
         size_t size) = 0;

   status_t ReadAtExactly(off_t position, void* buffer,
         size_t size, size_t* _bytesRead = __null);
   status_t WriteAtExactly(off_t position,
         const void* buffer, size_t size,
         size_t* _bytesWritten = __null);

 virtual off_t Seek(off_t position, uint32 seekMode) = 0;
 virtual off_t Position() const = 0;

 virtual status_t SetSize(off_t size);
 virtual status_t GetSize(off_t* size) const;

private:
 virtual void _ReservedPositionIO2();
 virtual void _ReservedPositionIO3();
 virtual void _ReservedPositionIO4();
 virtual void _ReservedPositionIO5();
 virtual void _ReservedPositionIO6();
 virtual void _ReservedPositionIO7();
 virtual void _ReservedPositionIO8();
 virtual void _ReservedPositionIO9();
 virtual void _ReservedPositionIO10();
 virtual void _ReservedPositionIO11();
 virtual void _ReservedPositionIO12();

private:
   uint32 _reserved[2];
};


class BMemoryIO : public BPositionIO {
public:
        BMemoryIO(void* data, size_t length);
        BMemoryIO(const void* data, size_t length);
 virtual ~BMemoryIO();

 virtual ssize_t ReadAt(off_t position, void* buffer,
         size_t size);
 virtual ssize_t WriteAt(off_t position, const void* buffer,
         size_t size);

 virtual off_t Seek(off_t position, uint32 seekMode);
 virtual off_t Position() const;

 virtual status_t SetSize(off_t size);

private:
        BMemoryIO(const BMemoryIO&);
   BMemoryIO& operator=(const BMemoryIO&);

 virtual void _ReservedMemoryIO1();
 virtual void _ReservedMemoryIO2();

private:
   bool fReadOnly;
   char* fBuffer;
   size_t fLength;
   size_t fBufferSize;
   size_t fPosition;

   uint32 _reserved[1];
};


class BMallocIO : public BPositionIO {
public:
        BMallocIO();
 virtual ~BMallocIO();

 virtual ssize_t ReadAt(off_t position, void* buffer,
         size_t size);
 virtual ssize_t WriteAt(off_t position, const void* buffer,
         size_t size);

 virtual off_t Seek(off_t position, uint32 seekMode);
 virtual off_t Position() const;

 virtual status_t SetSize(off_t size);


   void SetBlockSize(size_t blockSize);

   const void* Buffer() const;
   size_t BufferLength() const;

private:
        BMallocIO(const BMallocIO&);
   BMallocIO& operator=(const BMallocIO&);

 virtual void _ReservedMallocIO1();
 virtual void _ReservedMallocIO2();

private:
   size_t fBlockSize;
   size_t fMallocSize;
   size_t fLength;
   char* fData;
   off_t fPosition;

   uint32 _reserved[1];
};
struct node_ref;
struct stat_beos;
class BVolume;


class BStatable {
public:

 virtual ~BStatable();


private:
 virtual status_t _GetStat(struct stat_beos* stat) const = 0;


public:
 virtual status_t GetStat(struct stat* stat) const = 0;

 bool IsFile() const;
 bool IsDirectory() const;
 bool IsSymLink() const;

 status_t GetNodeRef(node_ref* ref) const;

 status_t GetOwner(uid_t* owner) const;
 status_t SetOwner(uid_t owner);

 status_t GetGroup(gid_t* group) const;
 status_t SetGroup(gid_t group);

 status_t GetPermissions(mode_t* permissions) const;
 status_t SetPermissions(mode_t permissions);

 status_t GetSize(off_t* size) const;

 status_t GetModificationTime(time_t* mtime) const;
 status_t SetModificationTime(time_t mtime);

 status_t GetCreationTime(time_t* ctime) const;
 status_t SetCreationTime(time_t ctime);

 status_t GetAccessTime(time_t* atime) const;
 status_t SetAccessTime(time_t atime);

 status_t GetVolume(BVolume* volume) const;

 class Private;

private:
 friend class BEntry;
 friend class BNode;
 friend class Private;

 virtual void _OhSoStatable2();
 virtual void _OhSoStatable3();
 uint32 _reserved[4];

 virtual status_t set_stat(struct stat &st, uint32 what) = 0;
};


class BDirectory;
class BPath;


struct entry_ref {
        entry_ref();
        entry_ref(dev_t dev, ino_t dir,
         const char* name);
        entry_ref(const entry_ref& ref);
        ~entry_ref();

   status_t set_name(const char* name);

   bool operator==(const entry_ref& ref) const;
   bool operator!=(const entry_ref& ref) const;
   entry_ref& operator=(const entry_ref& ref);

   dev_t device;
   ino_t directory;
   char* name;
};


class BEntry : public BStatable {
public:
        BEntry();
        BEntry(const BDirectory* dir, const char* path,
         bool traverse = false);
        BEntry(const entry_ref* ref,
         bool traverse = false);
        BEntry(const char* path, bool traverse = false);
        BEntry(const BEntry& entry);
 virtual ~BEntry();

   status_t InitCheck() const;
   bool Exists() const;

   const char* Name() const;

 virtual status_t GetStat(struct stat* stat) const;

   status_t SetTo(const BDirectory* dir, const char* path,
           bool traverse = false);
   status_t SetTo(const entry_ref* ref,
         bool traverse = false);
   status_t SetTo(const char* path, bool traverse = false);
   void Unset();

   status_t GetRef(entry_ref* ref) const;
   status_t GetPath(BPath* path) const;
   status_t GetParent(BEntry* entry) const;
   status_t GetParent(BDirectory* dir) const;
   status_t GetName(char* buffer) const;

   status_t Rename(const char* path, bool clobber = false);
   status_t MoveTo(BDirectory* dir, const char* path = __null,
         bool clobber = false);
   status_t Remove();

   bool operator==(const BEntry& item) const;
   bool operator!=(const BEntry& item) const;

   BEntry& operator=(const BEntry& item);

private:
   friend class BDirectory;
   friend class BFile;
   friend class BNode;
   friend class BSymLink;

 virtual void _PennyEntry1();
 virtual void _PennyEntry2();
 virtual void _PennyEntry3();
 virtual void _PennyEntry4();
 virtual void _PennyEntry5();
 virtual void _PennyEntry6();


 virtual status_t set_stat(struct stat& stat, uint32 what);
   status_t _SetTo(int dir, const char* path,
         bool traverse);
   status_t _SetName(const char* name);

   status_t _Rename(BEntry& target, bool clobber);

   void _Dump(const char* name = __null);

   status_t _GetStat(struct stat* stat) const;
 virtual status_t _GetStat(struct stat_beos* stat) const;

private:
   int fDirFd;
   char* fName;
   status_t fCStatus;

   uint32 _reserved[4];
};


status_t get_ref_for_path(const char* path, entry_ref* ref);
bool operator<(const entry_ref& a, const entry_ref& b);
class BFlattenable {
public:
 virtual bool IsFixedSize() const = 0;
 virtual type_code TypeCode() const = 0;
 virtual ssize_t FlattenedSize() const = 0;
 virtual status_t Flatten(void* buffer, ssize_t size) const = 0;
 virtual bool AllowsTypeCode(type_code code) const;
 virtual status_t Unflatten(type_code code, const void* buffer,
         ssize_t size) = 0;

 virtual ~BFlattenable();

private:
   void _ReservedFlattenable1();
 virtual void _ReservedFlattenable2();
 virtual void _ReservedFlattenable3();
};

class BDirectory;
class BEntry;
class BString;
struct entry_ref;


struct node_ref {
 node_ref();
 node_ref(dev_t device, ino_t node);
 node_ref(const node_ref& other);

 bool operator==(const node_ref& other) const;
 bool operator!=(const node_ref& other) const;
 bool operator<(const node_ref& other) const;
 node_ref& operator=(const node_ref& other);

 dev_t device;
 ino_t node;
};


class BNode : public BStatable {
public:
        BNode();
        BNode(const entry_ref* ref);
        BNode(const BEntry* entry);
        BNode(const char* path);
        BNode(const BDirectory* dir, const char* path);
        BNode(const BNode& node);
 virtual ~BNode();

   status_t InitCheck() const;

 virtual status_t GetStat(struct stat* st) const;

   status_t SetTo(const entry_ref* ref);
   status_t SetTo(const BEntry* entry);
   status_t SetTo(const char* path);
   status_t SetTo(const BDirectory* dir, const char* path);
   void Unset();

   status_t Lock();
   status_t Unlock();

   status_t Sync();

   ssize_t WriteAttr(const char* name, type_code type,
         off_t offset, const void* buffer,
         size_t length);
   ssize_t ReadAttr(const char* name, type_code type,
         off_t offset, void* buffer,
         size_t length) const;
   status_t RemoveAttr(const char* name);
   status_t RenameAttr(const char* oldName,
         const char* newName);
   status_t GetAttrInfo(const char* name,
         struct attr_info* info) const;
   status_t GetNextAttrName(char* buffer);
   status_t RewindAttrs();
   status_t WriteAttrString(const char* name,
         const BString* data);
   status_t ReadAttrString(const char* name,
         BString* result) const;

   BNode& operator=(const BNode& node);
   bool operator==(const BNode& node) const;
   bool operator!=(const BNode& node) const;

   int Dup();


private:
 friend class BFile;
 friend class BDirectory;
 friend class BSymLink;

 virtual void _RudeNode1();
 virtual void _RudeNode2();
 virtual void _RudeNode3();
 virtual void _RudeNode4();
 virtual void _RudeNode5();
 virtual void _RudeNode6();

private:
   status_t set_fd(int fd);
 virtual void close_fd();
   void set_status(status_t newStatus);

   status_t _SetTo(int fd, const char* path, bool traverse);
   status_t _SetTo(const entry_ref* ref, bool traverse);

 virtual status_t set_stat(struct stat& stat, uint32 what);

   status_t _GetStat(struct stat* stat) const;
 virtual status_t _GetStat(struct stat_beos* stat) const;
   status_t InitAttrDir();

private:
   uint32 rudeData[4];
   int fFd;

   int fAttrFd;


   status_t fCStatus;

};
       



       
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
__extension__ template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; __extension__ template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  enum class byte : unsigned char;

  template<>
    struct __is_byte<byte>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename> struct iterator_traits;


  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable
    {
      enum { __value = __is_trivially_copyable(_Tp) };
    };




  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
    {
      enum { __value = 0 };
    };


  template<typename _OutputIter, typename _InputIter>
    struct __memcpyable
    {
      enum { __value = 0 };
    };

  template<typename _Tp>
    struct __memcpyable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcpyable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };






  template<typename _Iter1, typename _Iter2>
    struct __memcmpable
    {
      enum { __value = 0 };
    };


  template<typename _Tp>
    struct __memcmpable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<const _Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };







  template<typename _Tp, bool _TreatAsBytes =



 __is_byte<_Tp>::__value

    >
    struct __is_memcmp_ordered
    {
      static const bool __value = _Tp(-1) > _Tp(1);
    };

  template<typename _Tp>
    struct __is_memcmp_ordered<_Tp, false>
    {
      static const bool __value = false;
    };


  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
    struct __is_memcmp_ordered_with
    {
      static const bool __value = __is_memcmp_ordered<_Tp>::__value
 && __is_memcmp_ordered<_Up>::__value;
    };

  template<typename _Tp, typename _Up>
    struct __is_memcmp_ordered_with<_Tp, _Up, false>
    {
      static const bool __value = false;
    };
  template<>
    struct __is_memcmp_ordered_with<std::byte, std::byte, true>
    { static constexpr bool __value = true; };

  template<typename _Tp, bool _SameSize>
    struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize>
    { static constexpr bool __value = false; };

  template<typename _Up, bool _SameSize>
    struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize>
    { static constexpr bool __value = false; };





  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
   
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
       




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  constexpr bool
  __is_null_pointer(std::nullptr_t)
  { return true; }




  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };
  template<typename... _Tp>
    using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));



  template<typename _Tp, typename _Up>
    using __promote_2 = __promote<__promoted_t<_Tp, _Up>>;

  template<typename _Tp, typename _Up, typename _Vp>
    using __promote_3 = __promote<__promoted_t<_Tp, _Up, _Vp>>;

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    using __promote_4 = __promote<__promoted_t<_Tp, _Up, _Vp, _Wp>>;

}
}

 typedef float float_t;
 typedef double double_t;
struct __exception;
extern "C" int matherr(struct __exception *);
struct __exception {





 int type;
 char *name;
 double arg1;
 double arg2;
 double retval;
};
extern int signgam;



extern "C" {



extern float acosf(float x);
extern float acoshf(float x);
extern float asinf(float x);
extern float asinhf(float x);
extern float atan2f(float y, float x);
extern float atanf(float x);
extern float atanhf(float x);
extern float cbrtf(float x);
extern float ceilf(float x);
extern float copysignf(float x, float y);
extern float cosf(float x);
extern float coshf(float x);
extern float erfcf(float x);
extern float erff(float x);
extern float expf(float x);
extern float exp2f(float x);
extern float expm1f(float x);
extern float fabsf(float x);
extern float fdimf(float x, float y);
extern float floorf(float x);
extern float fmaf(float x, float y, float z);
extern float fmaxf(float x, float y);
extern float fminf(float x, float y);
extern float fmodf(float x, float y);
extern float frexpf(float x, int *_exponent);
extern float gammaf(float x);
extern float hypotf(float x, float y);
extern int ilogbf(float x);
extern float ldexpf(float x, int exponent);
extern float lgammaf(float x);
extern long long llrintf(float x);
extern long long llroundf(float x);
extern float log10f(float x);
extern float log1pf(float x);
extern float log2f(float x);
extern float logbf(float x);
extern float logf(float x);
extern long lrintf(float x);
extern long lroundf(float x);
extern float modff(float x, float *y);
extern float nanf(const char *tagp);
extern float nearbyintf(float x);
extern float nextafterf(float x, float y);
extern float nexttowardf(float x, long double y);
extern float powf(float x, float y);
extern float remainderf(float x, float y);
extern float remquof(float x, float y, int *quo);
extern float rintf(float x);
extern float roundf(float x);
extern float scalbf(float x, float n);
extern float scalblnf(float x, long n);
extern float scalbnf(float x, int n);
extern float sinf(float x);
extern float sinhf(float x);
extern float sqrtf(float x);
extern float tanf(float x);
extern float tanhf(float x);
extern float tgammaf(float x);
extern float truncf(float x);


extern double acos(double x);
extern double acosh(double x);
extern double asin(double x);
extern double asinh(double x);
extern double atan(double x);
extern double atan2(double x, double y);
extern double atanh(double x);
extern double cbrt(double x);
extern double ceil(double x);
extern double copysign(double x, double y);
extern double cos(double x);
extern double cosh(double x);
extern double erf(double x);
extern double erfc(double x);
extern double exp(double x);
extern double expm1(double x);
extern double exp2(double x);
extern double fabs(double x);
extern double fdim(double x, double y);
extern double floor(double x);
extern double fma(double x, double y, double z);
extern double fmax(double x, double y);
extern double fmin(double x, double y);
extern double fmod(double x, double y);
extern double frexp(double x, int *_exponent);
extern double gamma(double x);
extern double hypot(double x, double y);
extern int ilogb(double x);
extern double ldexp(double x, int exponent);
extern double lgamma(double x);
extern long long llrint(double x);
extern long long llround(double x);
extern double log(double x);
extern double log10(double x);
extern double log1p(double x);
extern double log2(double x);
extern double logb(double x);
extern long lrint(double x);
extern long lround(double x);
extern double modf(double x, double *y);
extern double nan(const char* tagp);
extern double nearbyint(double x);
extern double nextafter(double x, double y);
extern double nexttoward(double x, long double y);
extern double pow(double x, double y);
extern double remainder(double x, double y);
extern double remquo(double x, double y, int *quo);
extern double rint(double x);
extern double round(double x);
extern double scalb(double x, double y);
extern double scalbln(double x, long n);
extern double scalbn(double x, int y);
extern double sin(double x);
extern double sinh(double x);
extern double sqrt(double x);
extern double tan(double x);
extern double tanh(double x);
extern double tgamma(double x);
extern double trunc(double x);


extern long double acoshl(long double x);
extern long double acosl(long double x);
extern long double asinhl(long double x);
extern long double asinl(long double x);
extern long double atanhl(long double x);
extern long double atanl(long double x);
extern long double atan2l(long double y, long double x);
extern long double cbrtl(long double x);
extern long double ceill(long double x);
extern long double copysignl(long double x, long double y);
extern long double cosl(long double x);
extern long double coshl(long double x);
extern long double erfcl(long double x);
extern long double erfl(long double x);
extern long double expl(long double x);
extern long double expm1l(long double x);
extern long double exp2l(long double x);
extern long double fabsl(long double x);
extern long double fdiml(long double x, long double y);
extern long double floorl(long double x);
extern long double fmal(long double x, long double y, long double z);
extern long double fmaxl(long double x, long double y);
extern long double fminl(long double x, long double y);
extern long double fmodl(long double x, long double y);
extern long double frexpl(long double num, int *_exponent);
extern long double hypotl(long double x, long double y);
extern int ilogbl(long double x);
extern long double ldexpl(long double x, int exponent);
extern long double lgammal(long double x);
extern long long llrintl(long double x);
extern long long llroundl(long double x);
extern long double logbl(long double x);
extern long double logl(long double x);
extern long double log1pl(long double x);
extern long double log10l(long double x);
extern long double log2l(long double x);
extern long lrintl(long double x);
extern long lroundl(long double x);
extern long double modfl(long double value, long double *iptr);
extern long double nanl(const char* tagp);
extern long double nearbyintl(long double x);
extern long double nextafterl(long double x, long double y);
extern long double nexttowardl(long double x, long double y);
extern long double powl(long double x, long double y);
extern long double remainderl(long double x, long double y);
extern long double remquol(long double x, long double y, int *quo);
extern long double rintl(long double x);
extern long double roundl(long double x);
extern long double scalbnl(long double x, int n);
extern long double scalblnl(long double x, long n);
extern long double sinl(long double x);
extern long double sinhl(long double x);
extern long double sqrtl(long double x);
extern long double tanl(long double x);
extern long double tanhl(long double x);
extern long double tgammal(long double x);
extern long double truncl(long double x);


extern double j0(double x);
extern double j1(double x);
extern double jn(int x, double y);
extern double lgamma_r(double x, int *y);
extern double y0(double x);
extern double y1(double x);
extern double yn(int x, double y);


extern int isinff(float value);
extern int finitef(float value);
extern float dremf(float x, float y);
extern float significandf(float x);
extern int isnanf(float value);
extern double significand(double x);
extern double drem(double x, double y);
extern int finite(double x);
extern float j0f(float x);
extern float j1f(float x);
extern float jnf(int x, float y);
extern float y0f(float x);
extern float y1f(float x);
extern float ynf(int x, float y);
extern float lgammaf_r(float x, int *y);
}

       




extern "C" {


extern void * __alloca (size_t __size);
extern void * alloca (size_t __size);


}
typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;

typedef struct {
 long long quot;
 long long rem;
} lldiv_t;

typedef int sig_atomic_t;
typedef __haiku_uint64 sigset_t;
union sigval {
 int sival_int;
 void* sival_ptr;
};

struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);


 pthread_attr_t* sigev_notify_attributes;


};

typedef struct __siginfo_t {
 int si_signo;
 int si_code;
 int si_errno;

 pid_t si_pid;
 uid_t si_uid;
 void* si_addr;
 int si_status;
 long si_band;
 union sigval si_value;
} siginfo_t;



typedef void (*__sighandler_t)(int);
typedef void (*__siginfo_handler_t)(int, siginfo_t*, void*);


typedef __sighandler_t sighandler_t;





struct sigaction {
 union {
  __sighandler_t sa_handler;
  __siginfo_handler_t sa_sigaction;
 };
 sigset_t sa_mask;
 int sa_flags;
 void* sa_userdata;

};
typedef struct stack_t {
 void* ss_sp;
 size_t ss_size;
 int ss_flags;
} stack_t;
extern const char* const sys_siglist[(64 + 1)];




extern "C" {




__sighandler_t signal(int _signal, __sighandler_t signalHandler);
int sigaction(int _signal, const struct sigaction* action,
   struct sigaction* oldAction);
__sighandler_t sigset(int _signal, __sighandler_t signalHandler);
int sigignore(int _signal);
int siginterrupt(int _signal, int flag);

int sigprocmask(int how, const sigset_t* set, sigset_t* oldSet);
int pthread_sigmask(int how, const sigset_t* set, sigset_t* oldSet);
int sighold(int _signal);
int sigrelse(int _signal);


int raise(int _signal);
int kill(pid_t pid, int _signal);
int killpg(pid_t processGroupID, int _signal);
int sigqueue(pid_t pid, int _signal, const union sigval userValue);
int pthread_kill(pthread_t thread, int _signal);


int sigpending(sigset_t* set);
int sigsuspend(const sigset_t* mask);
int sigpause(int _signal);
int sigwait(const sigset_t* set, int* _signal);
int sigwaitinfo(const sigset_t* set, siginfo_t* info);
int sigtimedwait(const sigset_t* set, siginfo_t* info,
           const struct timespec* timeout);


int sigaltstack(const stack_t* stack, stack_t* oldStack);


int sigemptyset(sigset_t* set);
int sigfillset(sigset_t* set);
int sigaddset(sigset_t* set, int _signal);
int sigdelset(sigset_t* set, int _signal);
int sigismember(const sigset_t* set, int _signal);


void psiginfo(const siginfo_t* info, const char* message);
void psignal(int _signal, const char* message);


int __signal_get_sigrtmin();
int __signal_get_sigrtmax();



}
typedef struct vregs vregs;




struct x86_64_fp_register {
 unsigned char value[10];
 unsigned char reserved[6];
};


struct x86_64_xmm_register {
 unsigned char value[16];
};



struct fpu_state {
 unsigned short control;
 unsigned short status;
 unsigned short tag;
 unsigned short opcode;
 unsigned long rip;
 unsigned long rdp;
 unsigned int mxcsr;
 unsigned int mscsr_mask;

 union {
  struct x86_64_fp_register fp[8];
  struct x86_64_fp_register mmx[8];
 };

 struct x86_64_xmm_register xmm[16];
 unsigned char _reserved_416_511[96];
};


struct xstate_hdr {
 unsigned long bv;
 unsigned long xcomp_bv;
 unsigned char _reserved[48];
};




struct savefpu {
 struct fpu_state fp_fxsave;
 struct xstate_hdr fp_xstate;
 struct x86_64_xmm_register fp_ymm[16];


};





struct vregs {
 unsigned long rax;
 unsigned long rbx;
 unsigned long rcx;
 unsigned long rdx;
 unsigned long rdi;
 unsigned long rsi;
 unsigned long rbp;
 unsigned long r8;
 unsigned long r9;
 unsigned long r10;
 unsigned long r11;
 unsigned long r12;
 unsigned long r13;
 unsigned long r14;
 unsigned long r15;

 unsigned long rsp;
 unsigned long rip;
 unsigned long rflags;

 struct savefpu fpu;
};


typedef struct vregs mcontext_t;

typedef struct __ucontext_t {
 struct __ucontext_t* uc_link;
 sigset_t uc_sigmask;
 stack_t uc_stack;
 mcontext_t uc_mcontext;
} ucontext_t;
extern "C" {


int sigsetmask(int mask);
int sigblock(int mask);


}
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;



extern "C" {


extern pid_t wait(int *_status);
extern pid_t waitpid(pid_t pid, int *_status, int options);
extern int waitid(idtype_t idType, id_t id, siginfo_t *info, int options);


}






struct timeval {
 time_t tv_sec;
 suseconds_t tv_usec;
};

typedef __haiku_uint32 fd_mask;
typedef struct fd_set {
 fd_mask bits[(((1024) + (((sizeof(fd_mask) * 8)) - 1)) / ((sizeof(fd_mask) * 8)))];
} fd_set;
extern "C" {


extern int pselect(int numBits, struct fd_set *readBits, struct fd_set *writeBits,
   struct fd_set *errorBits, const struct timespec *timeout, const sigset_t *sigMask);
extern int select(int numBits, struct fd_set *readBits, struct fd_set *writeBits,
   struct fd_set *errorBits, struct timeval *timeout);


}





struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};

struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};







extern "C" {


extern int getitimer(int which, struct itimerval *value);
extern int setitimer(int which, const struct itimerval *value, struct itimerval *oldValue);
extern int gettimeofday(struct timeval *tv, void *tz);

extern int utimes(const char *path, const struct timeval times[2]);



}







extern "C" {


int lutimes(const char *path, const struct timeval times[2]);


}




typedef __haiku_addr_t rlim_t;

struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;


 long ru_maxrss;
 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;
};
extern "C" {

extern int getrusage(int who, struct rusage *rusage);

extern int getrlimit(int resource, struct rlimit * rlp);
extern int setrlimit(int resource, const struct rlimit * rlp);

extern int getpriority(int which, id_t who);
extern int setpriority(int which, id_t who, int priority);

};



extern "C" {


pid_t wait3(int *status, int options, struct rusage *rusage);

pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);


}







struct random_data {
    int *fptr;
    int *rptr;
    int *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int *end_ptr;
};

struct drand48_data {
    unsigned short int x[3];
    unsigned short int a[3];
    unsigned short int c;
    unsigned short int old_x[3];
    int init;
};



extern "C" {



extern void *calloc(size_t numElements, size_t size);
extern void free(void *pointer);
extern void *malloc(size_t size);
extern int posix_memalign(void **_pointer, size_t alignment, size_t size);
extern void *aligned_alloc(size_t alignment, size_t size) __attribute__((alloc_align(1)));
extern void *realloc(void *oldPointer, size_t newSize);


extern void abort(void) __attribute__((noreturn));
extern int atexit(void (*func)(void));
extern int atfork(void (*func)(void));
extern void exit(int) __attribute__((noreturn));
extern void _Exit(int) __attribute__((noreturn));


extern char *realpath(const char *path, char *resolved);

extern int system(const char *command);

extern char *mktemp(char *name);
extern char *mkdtemp(char *templat);
extern int mkstemp(char *templat);

extern char *ecvt(double value, int digits, int *_decimalPoint, int *_sign);
extern char *fcvt(double value, int precision, int *_decimalPoint,
     int *_sign);
extern char *gcvt(double value, int digits, char *buffer);

extern char *l64a(long n);
extern long a64l(const char *string);


extern char **environ;
extern int clearenv(void);
extern char *getenv(const char *name);
extern int putenv(char *string);
extern int setenv(char const *name, char const *value, int rewrite);
extern int unsetenv(const char *name);


extern double atof(const char *string);
extern int atoi(const char *string);
extern long atol(const char *string);
extern long long int atoll(const char *string);
extern unsigned int atoui(const char *string);
extern unsigned long atoul(const char *string);

extern double strtod(const char *string, char **end);
extern long double strtold(const char *string, char **end);
extern float strtof(const char *string, char **end);
extern long strtol(const char *string, char **end, int base);
extern unsigned long strtoul(const char *string, char **end, int base);
extern long long strtoll(const char *string, char **end, int base);
extern unsigned long long strtoull(const char *string, char **end, int base);


extern void srand(unsigned int seed);
extern int rand(void);
extern int random(void);
extern void srandom(unsigned int seed);
extern int rand_r(unsigned int *seed);
extern int random_r(struct random_data *data, int *result);
extern int srandom_r(unsigned int seed, struct random_data *data);
extern char *initstate(unsigned int seed, char *state, size_t size);
extern char *setstate(char *state);
extern int initstate_r(unsigned int seed, void *stateBuffer,
     size_t stateLength, struct random_data *data);
extern int setstate_r(void *stateBuffer, struct random_data *data);

extern double drand48(void);
extern double erand48(unsigned short int xsubi[3]);
extern long lrand48(void);
extern long nrand48(unsigned short int xsubi[3]);
extern long mrand48(void);
extern long jrand48(unsigned short int xsubi[3]);
extern void srand48(long int seed);
extern unsigned short *seed48(unsigned short int seed16v[3]);
extern void lcong48(unsigned short int param[7]);

extern int drand48_r(struct drand48_data *data, double *result);
extern int erand48_r(unsigned short int xsubi[3],
     struct drand48_data *data, double *result);
extern int lrand48_r(struct drand48_data *data, long int *result);
extern int nrand48_r(unsigned short int xsubi[3],
     struct drand48_data *data, long int *result);
extern int mrand48_r(struct drand48_data *data, long int *result);
extern int jrand48_r(unsigned short int xsubi[3],
     struct drand48_data *data, long int *result);
extern int srand48_r(long int seed, struct drand48_data *data);
extern int seed48_r(unsigned short int seed16v[3],
     struct drand48_data *data);
extern int lcong48_r(unsigned short int param[7],
     struct drand48_data *data);


typedef int (*_compare_function)(const void *, const void *);

extern void *bsearch(const void *key, const void *base, size_t numElements,
     size_t sizeOfElement, _compare_function);
extern int heapsort(void *base, size_t numElements, size_t sizeOfElement,
     _compare_function);
extern int mergesort(void *base, size_t numElements, size_t sizeOfElement,
     _compare_function);
extern void qsort(void *base, size_t numElements, size_t sizeOfElement,
     _compare_function);
extern int radixsort(u_char const **base, int numElements,
     u_char const *table, u_int endByte);
extern int sradixsort(u_char const **base, int numElements,
     u_char const *table, u_int endByte);


extern int abs(int number);
extern long labs(long number);
extern long long llabs(long long number);

extern div_t div(int numerator, int denominator);
extern ldiv_t ldiv(long numerator, long denominator);
extern lldiv_t lldiv(long long numerator, long long denominator);


extern int mblen(const char *string, size_t maxSize);
extern int mbtowc(wchar_t *pwc, const char *string, size_t maxSize);
extern int wctomb(char *string, wchar_t wchar);
extern size_t mbstowcs(wchar_t *pwcs, const char *string, size_t maxSize);
extern size_t wcstombs(char *string, const wchar_t *pwcs, size_t maxSize);


extern void setkey(const char *key);


extern int getsubopt(char **optionp, char * const *keylistp,
     char **valuep);


extern int posix_openpt(int openFlags);
extern int grantpt(int masterFD);
extern char* ptsname(int masterFD);
extern int unlockpt(int masterFD);


extern unsigned short __ctype_get_mb_cur_max(void);


}
extern "C" {


int daemon(int noChangeDir, int noClose);
const char *getprogname(void);
void setprogname(const char *programName);
uint32_t arc4random(void);
void arc4random_buf(void *buf, size_t nbytes);
uint32_t arc4random_uniform(uint32_t upper_bound);

int mkstemps(char *templat, int slen);


}







extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  __extension__ inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
  __extension__ inline constexpr
  __float128
  abs(__float128 __x)
  {






    return __builtin_signbit(__x) ? -__x : __x;

  }



}
}
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }

  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }
  template<typename _Tp>
    inline _Tp
    __hypot3(_Tp __x, _Tp __y, _Tp __z)
    {
      __x = std::abs(__x);
      __y = std::abs(__y);
      __z = std::abs(__z);
      if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
 return __a * std::sqrt((__x / __a) * (__x / __a)
          + (__y / __a) * (__y / __a)
          + (__z / __a) * (__z / __a));
      else
 return {};
    }

  inline float
  hypot(float __x, float __y, float __z)
  { return std::__hypot3<float>(__x, __y, __z); }

  inline double
  hypot(double __x, double __y, double __z)
  { return std::__hypot3<double>(__x, __y, __z); }

  inline long double
  hypot(long double __x, long double __y, long double __z)
  { return std::__hypot3<long double>(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
    hypot(_Tp __x, _Up __y, _Vp __z)
    {
      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
      return std::__hypot3<__type>(__x, __y, __z);
    }

}



namespace std __attribute__ ((__visibility__ ("default")))
{




  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));

  void
  __throw_bad_array_new_length(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__));


  void
  __throw_system_error(int) __attribute__((__noreturn__));


  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));

}


       




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

  template<typename _Tp>
    struct __is_integer_nonstrict
    : public std::__is_integer<_Tp>
    {
      using std::__is_integer<_Tp>::__value;


      enum { __width = __value ? sizeof(_Tp) * 8 : 0 };
    };

  template<typename _Value>
    struct __numeric_traits_integer
    {

      static_assert(__is_integer_nonstrict<_Value>::__value,
      "invalid specialization");




      static const bool __is_signed = (_Value)(-1) < 0;
      static const int __digits
 = __is_integer_nonstrict<_Value>::__width - __is_signed;


      static const _Value __max = __is_signed
 ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
 : ~(_Value)0;
      static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
  template<typename _Tp>
    using __int_traits = __numeric_traits_integer<_Tp>;
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;






  template<typename _Value>
    struct __numeric_traits
    : public __numeric_traits_integer<_Value>
    { };

  template<>
    struct __numeric_traits<float>
    : public __numeric_traits_floating<float>
    { };

  template<>
    struct __numeric_traits<double>
    : public __numeric_traits_floating<double>
    { };

  template<>
    struct __numeric_traits<long double>
    : public __numeric_traits_floating<long double>
    { };

}
       







namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp>
    class reference_wrapper;
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };







  using true_type = integral_constant<bool, true>;


  using false_type = integral_constant<bool, false>;



  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;






  template<bool __v>
    using bool_constant = integral_constant<bool, __v>;






  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };


  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template<bool>
    struct __conditional
    {
      template<typename _Tp, typename>
 using type = _Tp;
    };

  template<>
    struct __conditional<false>
    {
      template<typename, typename _Up>
 using type = _Up;
    };


  template<bool _Cond, typename _If, typename _Else>
    using __conditional_t
      = typename __conditional<_Cond>::template type<_If, _Else>;


  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  namespace __detail
  {

    template<typename _Tp, typename...>
      using __first_t = _Tp;


    template<typename... _Bn>
      auto __or_fn(int) -> __first_t<false_type,
         __enable_if_t<!bool(_Bn::value)>...>;

    template<typename... _Bn>
      auto __or_fn(...) -> true_type;

    template<typename... _Bn>
      auto __and_fn(int) -> __first_t<true_type,
          __enable_if_t<bool(_Bn::value)>...>;

    template<typename... _Bn>
      auto __and_fn(...) -> false_type;
  }




  template<typename... _Bn>
    struct __or_
    : decltype(__detail::__or_fn<_Bn...>(0))
    { };

  template<typename... _Bn>
    struct __and_
    : decltype(__detail::__and_fn<_Bn...>(0))
    { };

  template<typename _Pp>
    struct __not_
    : __bool_constant<!bool(_Pp::value)>
    { };





  template<typename... _Bn>
    inline constexpr bool __or_v = __or_<_Bn...>::value;
  template<typename... _Bn>
    inline constexpr bool __and_v = __and_<_Bn...>::value;

  namespace __detail
  {
    template<typename , typename _B1, typename... _Bn>
      struct __disjunction_impl
      { using type = _B1; };

    template<typename _B1, typename _B2, typename... _Bn>
      struct __disjunction_impl<__enable_if_t<!bool(_B1::value)>, _B1, _B2, _Bn...>
      { using type = typename __disjunction_impl<void, _B2, _Bn...>::type; };

    template<typename , typename _B1, typename... _Bn>
      struct __conjunction_impl
      { using type = _B1; };

    template<typename _B1, typename _B2, typename... _Bn>
      struct __conjunction_impl<__enable_if_t<bool(_B1::value)>, _B1, _B2, _Bn...>
      { using type = typename __conjunction_impl<void, _B2, _Bn...>::type; };
  }




  template<typename... _Bn>
    struct conjunction
    : __detail::__conjunction_impl<void, _Bn...>::type
    { };

  template<>
    struct conjunction<>
    : true_type
    { };

  template<typename... _Bn>
    struct disjunction
    : __detail::__disjunction_impl<void, _Bn...>::type
    { };

  template<>
    struct disjunction<>
    : false_type
    { };

  template<typename _Pp>
    struct negation
    : __not_<_Pp>::type
    { };




  template<typename... _Bn>
    inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

  template<typename... _Bn>
    inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

  template<typename _Pp>
    inline constexpr bool negation_v = negation<_Pp>::value;





  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct remove_cv;
  template<typename>
    struct is_const;


  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;





  template<typename _Tp>
    struct is_void
    : public false_type { };

  template<>
    struct is_void<void>
    : public true_type { };

  template<>
    struct is_void<const void>
    : public true_type { };

  template<>
    struct is_void<volatile void>
    : public true_type { };

  template<>
    struct is_void<const volatile void>
    : public true_type { };


  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };




  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };







  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  __extension__
  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  __extension__
  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };




  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public __not_<is_function<_Tp>>::type { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public is_function<_Tp>::type { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename _Tp>
    struct is_function
    : public __bool_constant<!is_const<const _Tp>::value> { };

  template<typename _Tp>
    struct is_function<_Tp&>
    : public false_type { };

  template<typename _Tp>
    struct is_function<_Tp&&>
    : public false_type { };




  template<typename _Tp>
    struct is_null_pointer
    : public false_type { };

  template<>
    struct is_null_pointer<std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<const std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<volatile std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<const volatile std::nullptr_t>
    : public true_type { };



  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__ ("use '" "std::is_null_pointer" "' instead")));




  template<typename _Tp>
    struct is_reference
    : public false_type
    { };

  template<typename _Tp>
    struct is_reference<_Tp&>
    : public true_type
    { };

  template<typename _Tp>
    struct is_reference<_Tp&&>
    : public true_type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __not_<is_fundamental<_Tp>>::type { };


  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };



  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename, typename>
    struct is_same;


  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  __extension__
  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long

   , signed __int128
   >;


  __extension__
  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long

   , unsigned __int128
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;





  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };






  template<typename _Tp>
    struct
   
    is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct
    [[__deprecated__]]
    is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };





  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };


  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };



  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };


  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);


  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename>
    struct remove_all_extents;


  template<typename _Tp>
    struct __is_array_known_bounds
    : public false_type
    { };

  template<typename _Tp, size_t _Size>
    struct __is_array_known_bounds<_Tp[_Size]>
    : public true_type
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public false_type
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds<_Tp[]>
    : public true_type
    { };
  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };







  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_constructible_impl
      = __bool_constant<__is_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename = void>
    struct __add_lvalue_reference_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, __void_t<_Tp&>>
    { using type = _Tp&; };

  template<typename _Tp>
    using __add_lval_ref_t = typename __add_lvalue_reference_helper<_Tp>::type;



  template<typename _Tp>
    struct is_copy_constructible
    : public __is_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename = void>
    struct __add_rvalue_reference_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, __void_t<_Tp&&>>
    { using type = _Tp&&; };

  template<typename _Tp>
    using __add_rval_ref_t = typename __add_rvalue_reference_helper<_Tp>::type;



  template<typename _Tp>
    struct is_move_constructible
    : public __is_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_assignable_impl = __bool_constant<__is_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __is_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>,
      __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_nothrow_assignable_impl
      = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
       __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
       __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_trivially_constructible_impl
      = __bool_constant<__is_trivially_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __is_trivially_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __is_trivially_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<__is_constructible_impl<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_trivially_assignable_impl
      = __bool_constant<__is_trivially_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __is_trivially_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
         __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
         __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint = 0>
    struct extent
    : public integral_constant<size_t, 0> { };

  template<typename _Tp, size_t _Size>
    struct extent<_Tp[_Size], 0>
    : public integral_constant<size_t, _Size> { };

  template<typename _Tp, unsigned _Uint, size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public extent<_Tp, _Uint - 1>::type { };

  template<typename _Tp>
    struct extent<_Tp[], 0>
    : public integral_constant<size_t, 0> { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public extent<_Tp, _Uint - 1>::type { };





  template<typename _Tp, typename _Up>
    struct is_same

    : public integral_constant<bool, __is_same(_Tp, _Up)>



    { };
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };


  template<typename _From, typename _To>
    struct is_convertible
    : public __bool_constant<__is_convertible(_From, _To)>
    { };
  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;
  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };



  template<typename _Tp>
    struct remove_cv
    { using type = __remove_cv(_Tp); };
  template<typename _Tp>
    struct add_const
    { using type = _Tp const; };


  template<typename _Tp>
    struct add_volatile
    { using type = _Tp volatile; };


  template<typename _Tp>
    struct add_cv
    { using type = _Tp const volatile; };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;






  template<typename _Tp>
    struct remove_reference
    { using type = __remove_reference(_Tp); };
  template<typename _Tp>
    struct add_lvalue_reference
    { using type = __add_lval_ref_t<_Tp>; };


  template<typename _Tp>
    struct add_rvalue_reference
    { using type = __add_rval_ref_t<_Tp>; };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;







  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  __extension__
  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };





  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<> struct make_unsigned<bool>;
  template<> struct make_unsigned<bool const>;
  template<> struct make_unsigned<bool volatile>;
  template<> struct make_unsigned<bool const volatile>;




  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  __extension__
  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<> struct make_signed<bool>;
  template<> struct make_signed<bool const>;
  template<> struct make_signed<bool volatile>;
  template<> struct make_signed<bool const volatile>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>>
    { };

  template<typename _Tp, typename = void>
    struct __add_pointer_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, __void_t<_Tp*>>
    { using type = _Tp*; };


  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };

  template<typename _Tp>
    struct add_pointer<_Tp&>
    { using type = _Tp*; };

  template<typename _Tp>
    struct add_pointer<_Tp&&>
    { using type = _Tp*; };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct
   
    aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };

  template <size_t _Len, typename... _Types>
    struct
   
    aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;





  template<typename _Up>
    struct __decay_selector
    : __conditional_t<is_const<const _Up>::value,
        remove_cv<_Up>,
        add_pointer<_Up>>
    { };

  template<typename _Up, size_t _Nm>
    struct __decay_selector<_Up[_Nm]>
    { using type = _Up*; };

  template<typename _Up>
    struct __decay_selector<_Up[]>
    { using type = _Up*; };




  template<typename _Tp>
    struct decay
    { using type = typename __decay_selector<_Tp>::type; };

  template<typename _Tp>
    struct decay<_Tp&>
    { using type = typename __decay_selector<_Tp>::type; };

  template<typename _Tp>
    struct decay<_Tp&&>
    { using type = typename __decay_selector<_Tp>::type; };




  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;





  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;




  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };

  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);
    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };



  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };


  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };






  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    struct result_of;






  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef __remove_cvref_t<_Arg> _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename __conditional_t<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_reference<_Arg>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename __conditional_t<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };


  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { } __attribute__ ((__deprecated__ ("use '" "std::invoke_result" "' instead")));



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;





  template<typename...> using void_t = void;
  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using type = _Default;
      using __is_detected = false_type;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using type = _Op<_Args...>;
      using __is_detected = true_type;
    };

  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;



  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };


  template<typename _Tp>
   
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
   
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);


  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };







  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    inline constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;



  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };



  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp, typename _Up>
    inline constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    inline constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;
  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl
    : false_type
    {
      using __nothrow_conv = false_type;
    };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    {
      using __nothrow_conv = true_type;
    };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:

      using _Res_t = typename _Result::type;



      static _Res_t _S_get() noexcept;


      template<typename _Tp>
 static void _S_conv(__type_identity_t<_Tp>) noexcept;


      template<typename _Tp,
        bool _Nothrow = noexcept(_S_conv<_Tp>(_S_get())),
        typename = decltype(_S_conv<_Tp>(_S_get())),

        bool _Dangle = __reference_converts_from_temporary(_Tp, _Res_t)



       >
 static __bool_constant<_Nothrow && !_Dangle>
 _S_test(int);

      template<typename _Tp, bool = false>
 static false_type
 _S_test(...);

    public:

      using type = decltype(_S_test<_Ret, true>(1));


      using __nothrow_conv = decltype(_S_test<_Ret>(1));
    };

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };






  template<typename _Functor, typename... _ArgTypes>
    struct invoke_result
    : public __invoke_result<_Functor, _ArgTypes...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),
 "_Functor must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _Args>
    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;


  template<typename _Fn, typename... _ArgTypes>
    struct is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_invocable_r
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable
    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
      __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };





  template<typename _Result, typename _Ret>
    using __is_nt_invocable_impl
      = typename __is_invocable_impl<_Result, _Ret>::__nothrow_conv;



  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable_r
    : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
             __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };
template <typename _Tp>
  inline constexpr bool is_void_v = is_void<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_integral_v = is_integral<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;

template <typename _Tp>
  inline constexpr bool is_array_v = false;
template <typename _Tp>
  inline constexpr bool is_array_v<_Tp[]> = true;
template <typename _Tp, size_t _Num>
  inline constexpr bool is_array_v<_Tp[_Num]> = true;

template <typename _Tp>
  inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v<_Tp&> = true;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v<_Tp&&> = true;
template <typename _Tp>
  inline constexpr bool is_member_object_pointer_v =
    is_member_object_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_function_pointer_v =
    is_member_function_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_enum_v = __is_enum(_Tp);
template <typename _Tp>
  inline constexpr bool is_union_v = __is_union(_Tp);
template <typename _Tp>
  inline constexpr bool is_class_v = __is_class(_Tp);
template <typename _Tp>
  inline constexpr bool is_function_v = is_function<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_reference_v<_Tp&> = true;
template <typename _Tp>
  inline constexpr bool is_reference_v<_Tp&&> = true;
template <typename _Tp>
  inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_object_v = is_object<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_compound_v = is_compound<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_const_v = false;
template <typename _Tp>
  inline constexpr bool is_const_v<const _Tp> = true;
template <typename _Tp>
  inline constexpr bool is_volatile_v = false;
template <typename _Tp>
  inline constexpr bool is_volatile_v<volatile _Tp> = true;

template <typename _Tp>
  inline constexpr bool is_trivial_v = __is_trivial(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);
template <typename _Tp>
  inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);
template <typename _Tp>
 
  inline constexpr bool is_pod_v = __is_pod(_Tp);
template <typename _Tp>
  [[__deprecated__]]
  inline constexpr bool is_literal_type_v = __is_literal_type(_Tp);
template <typename _Tp>
  inline constexpr bool is_empty_v = __is_empty(_Tp);
template <typename _Tp>
  inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);
template <typename _Tp>
  inline constexpr bool is_abstract_v = __is_abstract(_Tp);
template <typename _Tp>
  inline constexpr bool is_final_v = __is_final(_Tp);

template <typename _Tp>
  inline constexpr bool is_signed_v = is_signed<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;

template <typename _Tp, typename... _Args>
  inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_copy_constructible_v
    = __is_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_move_constructible_v
    = __is_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_copy_assignable_v
    = __is_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_move_assignable_v
    = __is_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
  inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;

template <typename _Tp, typename... _Args>
  inline constexpr bool is_trivially_constructible_v
    = __is_trivially_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_trivially_default_constructible_v
    = __is_trivially_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_copy_constructible_v
    = __is_trivially_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_move_constructible_v
    = __is_trivially_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_trivially_assignable_v
    = __is_trivially_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_trivially_copy_assignable_v
    = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
    __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_move_assignable_v
    = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
    __add_rval_ref_t<_Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v =
    is_trivially_destructible<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_nothrow_constructible_v
    = __is_nothrow_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_nothrow_default_constructible_v
    = __is_nothrow_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_constructible_v
    = __is_nothrow_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_nothrow_move_constructible_v
    = __is_nothrow_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_nothrow_assignable_v
    = __is_nothrow_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_assignable_v
    = __is_nothrow_assignable(__add_lval_ref_t<_Tp>,
         __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_nothrow_move_assignable_v
    = __is_nothrow_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
  inline constexpr bool is_nothrow_destructible_v =
    is_nothrow_destructible<_Tp>::value;

template <typename _Tp>
  inline constexpr bool has_virtual_destructor_v
    = __has_virtual_destructor(_Tp);

template <typename _Tp>
  inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;

template <typename _Tp>
  inline constexpr size_t rank_v = 0;
template <typename _Tp, size_t _Size>
  inline constexpr size_t rank_v<_Tp[_Size]> = 1 + rank_v<_Tp>;
template <typename _Tp>
  inline constexpr size_t rank_v<_Tp[]> = 1 + rank_v<_Tp>;

template <typename _Tp, unsigned _Idx = 0>
  inline constexpr size_t extent_v = 0;
template <typename _Tp, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], 0> = _Size;
template <typename _Tp, unsigned _Idx, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], _Idx> = extent_v<_Tp, _Idx - 1>;
template <typename _Tp>
  inline constexpr size_t extent_v<_Tp[], 0> = 0;
template <typename _Tp, unsigned _Idx>
  inline constexpr size_t extent_v<_Tp[], _Idx> = extent_v<_Tp, _Idx - 1>;


template <typename _Tp, typename _Up>
  inline constexpr bool is_same_v = __is_same(_Tp, _Up);






template <typename _Base, typename _Derived>
  inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);
template <typename _From, typename _To>
  inline constexpr bool is_convertible_v = __is_convertible(_From, _To);
template<typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
template<typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_v
    = is_nothrow_invocable<_Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_r_v
    = is_invocable_r<_Ret, _Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_r_v
    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;






  template<typename _Tp>
    struct has_unique_object_representations
    : bool_constant<__has_unique_object_representations(
      remove_cv_t<remove_all_extents_t<_Tp>>
      )>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    inline constexpr bool has_unique_object_representations_v
      = has_unique_object_representations<_Tp>::value;






  template<typename _Tp>
    struct is_aggregate
    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)>
    { };





  template<typename _Tp>
    inline constexpr bool is_aggregate_v = __is_aggregate(remove_cv_t<_Tp>);

}
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value,
   "std::forward must not be used to convert an rvalue to an lvalue");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    [[__nodiscard__]]
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr
    __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
  template<typename _Tp>
   
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
   
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
       






namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<typename _Tp>
    inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;



  template<size_t __i, typename _Tp>
    struct tuple_element;


  template<size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      using type = const __tuple_element_t<__i, _Tp>;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      using type = volatile __tuple_element_t<__i, _Tp>;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      using type = const volatile __tuple_element_t<__i, _Tp>;
    };





  template<typename _Tp, typename... _Types>
    constexpr size_t
    __find_uniq_type_in_pack()
    {
      constexpr size_t __sz = sizeof...(_Types);
      constexpr bool __found[__sz] = { __is_same(_Tp, _Types) ... };
      size_t __n = __sz;
      for (size_t __i = 0; __i < __sz; ++__i)
 {
   if (__found[__i])
     {
       if (__n < __sz)
  return __sz;
       __n = __i;
     }
 }
      return __n;
    }
  template<size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;




  template<size_t... _Indexes> struct _Index_tuple { };


  template<size_t _Num>
    struct _Build_index_tuple
    {
      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;



  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;



  struct in_place_t {
    explicit in_place_t() = default;
  };

  inline constexpr in_place_t in_place{};

  template<typename _Tp> struct in_place_type_t
  {
    explicit in_place_type_t() = default;
  };

  template<typename _Tp>
    inline constexpr in_place_type_t<_Tp> in_place_type{};

  template<size_t _Idx> struct in_place_index_t
  {
    explicit in_place_index_t() = default;
  };

  template<size_t _Idx>
    inline constexpr in_place_index_t<_Idx> in_place_index{};

  template<typename>
    inline constexpr bool __is_in_place_type_v = false;

  template<typename _Tp>
    inline constexpr bool __is_in_place_type_v<in_place_type_t<_Tp>> = true;

  template<typename _Tp>
    using __is_in_place_type = bool_constant<__is_in_place_type_v<_Tp>>;




  template<size_t _Np, typename... _Types>
    struct _Nth_type
    { };

  template<typename _Tp0, typename... _Rest>
    struct _Nth_type<0, _Tp0, _Rest...>
    { using type = _Tp0; };

  template<typename _Tp0, typename _Tp1, typename... _Rest>
    struct _Nth_type<1, _Tp0, _Tp1, _Rest...>
    { using type = _Tp1; };

  template<typename _Tp0, typename _Tp1, typename _Tp2, typename... _Rest>
    struct _Nth_type<2, _Tp0, _Tp1, _Tp2, _Rest...>
    { using type = _Tp2; };

  template<size_t _Np, typename _Tp0, typename _Tp1, typename _Tp2,
    typename... _Rest>



    struct _Nth_type<_Np, _Tp0, _Tp1, _Tp2, _Rest...>
    : _Nth_type<_Np - 3, _Rest...>
    { };


  template<typename _Tp0, typename _Tp1, typename... _Rest>
    struct _Nth_type<0, _Tp0, _Tp1, _Rest...>
    { using type = _Tp0; };

  template<typename _Tp0, typename _Tp1, typename _Tp2, typename... _Rest>
    struct _Nth_type<0, _Tp0, _Tp1, _Tp2, _Rest...>
    { using type = _Tp0; };

  template<typename _Tp0, typename _Tp1, typename _Tp2, typename... _Rest>
    struct _Nth_type<1, _Tp0, _Tp1, _Tp2, _Rest...>
    { using type = _Tp1; };







}






namespace std __attribute__ ((__visibility__ ("default")))
{

  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  inline constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename...>
    class tuple;

  template<size_t...>
    struct _Index_tuple;







  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }
    };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
    };



  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };
  template<typename _T1, typename _T2>
    struct pair
    : public __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;


      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;

      template<typename... _Args1, typename... _Args2>

 pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);


      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
        __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }
    private:
      template<typename... _Args1, size_t... _Indexes1,
        typename... _Args2, size_t... _Indexes2>

 pair(tuple<_Args1...>&, tuple<_Args2...>&,
      _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    public:
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>
      constexpr pair()
      : first(), second() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }



      using _PCCP = _PCC<true, _T1, _T2>;



      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }



      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
 constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second)
 { ; }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second)
 { ; }
    private:



      struct __zero_as_null_pointer_constant
      {
 __zero_as_null_pointer_constant(int __zero_as_null_pointer_constant::*)
 { }
 template<typename _Tp,
   typename = __enable_if_t<is_null_pointer<_Tp>::value>>
 __zero_as_null_pointer_constant(_Tp) = delete;
      };

    public:




      template<typename _U1,
        __enable_if_t<__and_<__not_<is_reference<_U1>>,
        is_pointer<_T2>,
        is_constructible<_T1, _U1>,
        __not_<is_constructible<_T1, const _U1&>>,
        is_convertible<_U1, _T1>>::value,
        bool> = true>
 __attribute__ ((__deprecated__ ("use 'nullptr' instead of '0' to " "initialize std::pair of move-only " "type and pointer")))
 constexpr
 pair(_U1&& __x, __zero_as_null_pointer_constant, ...)
 : first(std::forward<_U1>(__x)), second(nullptr)
 { ; }

      template<typename _U1,
        __enable_if_t<__and_<__not_<is_reference<_U1>>,
        is_pointer<_T2>,
        is_constructible<_T1, _U1>,
        __not_<is_constructible<_T1, const _U1&>>,
        __not_<is_convertible<_U1, _T1>>>::value,
        bool> = false>
 __attribute__ ((__deprecated__ ("use 'nullptr' instead of '0' to " "initialize std::pair of move-only " "type and pointer")))
 explicit constexpr
 pair(_U1&& __x, __zero_as_null_pointer_constant, ...)
 : first(std::forward<_U1>(__x)), second(nullptr)
 { ; }

      template<typename _U2,
        __enable_if_t<__and_<is_pointer<_T1>,
        __not_<is_reference<_U2>>,
        is_constructible<_T2, _U2>,
        __not_<is_constructible<_T2, const _U2&>>,
        is_convertible<_U2, _T2>>::value,
        bool> = true>
 __attribute__ ((__deprecated__ ("use 'nullptr' instead of '0' to " "initialize std::pair of move-only " "type and pointer")))
 constexpr
 pair(__zero_as_null_pointer_constant, _U2&& __y, ...)
 : first(nullptr), second(std::forward<_U2>(__y))
 { ; }

      template<typename _U2,
        __enable_if_t<__and_<is_pointer<_T1>,
        __not_<is_reference<_U2>>,
        is_constructible<_T2, _U2>,
        __not_<is_constructible<_T2, const _U2&>>,
        __not_<is_convertible<_U2, _T2>>>::value,
        bool> = false>
 __attribute__ ((__deprecated__ ("use 'nullptr' instead of '0' to " "initialize std::pair of move-only " "type and pointer")))
 explicit constexpr
 pair(__zero_as_null_pointer_constant, _U2&& __y, ...)
 : first(nullptr), second(std::forward<_U2>(__y))
 { ; }



      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))
 { ; }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))
 { ; }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second))
 { ; }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second))
 { ; }



      pair&
      operator=(__conditional_t<__and_<is_copy_assignable<_T1>,
           is_copy_assignable<_T2>>::value,
    const pair&, const __nonesuch&> __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(__conditional_t<__and_<is_move_assignable<_T1>,
           is_move_assignable<_T2>>::value,
    pair&&, __nonesuch&&> __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
 typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
      is_assignable<_T2&, const _U2&>>::value,
      pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
      is_assignable<_T2&, _U2&&>>::value,
      pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }
    };




  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;



  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
  template<typename _T1, typename _T2>
    inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
    { };



  template<class _Tp1, class _Tp2>
    struct tuple_size<pair<_Tp1, _Tp2>>
    : public integral_constant<size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };


  template<typename _Tp1, typename _Tp2>
    inline constexpr size_t tuple_size_v<pair<_Tp1, _Tp2>> = 2;

  template<typename _Tp1, typename _Tp2>
    inline constexpr size_t tuple_size_v<const pair<_Tp1, _Tp2>> = 2;

  template<typename _Tp>
    inline constexpr bool __is_pair = false;

  template<typename _Tp, typename _Up>
    inline constexpr bool __is_pair<pair<_Tp, _Up>> = true;



  template<size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp2>(__pair.second); }
    };






  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(const pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(const pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

}
       
namespace std __attribute__ ((__visibility__ ("default")))
{

  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct [[__deprecated__]] iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
  template<typename _Iterator>
    struct iterator_traits;




  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };



  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };


  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };






  template<typename _Iter>
    __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }




  template<typename _Iter>
    using __iterator_category_t
      = typename iterator_traits<_Iter>::iterator_category;

  template<typename _InIter>
    using _RequireInputIter =
      __enable_if_t<is_convertible<__iterator_category_t<_InIter>,
       input_iterator_tag>::value>;

  template<typename _It,
    typename _Cat = __iterator_category_t<_It>>
    struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat>
    {
      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
      enum { __value = _Base::value };
    };








}
       

       


namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
  template<typename _OutputIterator>
    void
    __distance(_OutputIterator, _OutputIterator, output_iterator_tag) = delete;
  template<typename _InputIterator>
    [[__nodiscard__]] __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      do { if (std::__is_constant_evaluated() && !bool(__n >= 0)) __builtin_unreachable(); } while (false);
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }



  template<typename _OutputIterator, typename _Distance>
    void
    __advance(_OutputIterator&, _Distance, output_iterator_tag) = delete;
  template<typename _InputIterator, typename _Distance>
    __attribute__((__always_inline__))
    inline constexpr void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    [[__nodiscard__]] [[__gnu__::__always_inline__]]
    inline constexpr _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    [[__nodiscard__]] [[__gnu__::__always_inline__]]
    inline constexpr _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
namespace std __attribute__ ((__visibility__ ("default")))
{




  class __undefined;



  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _SomeTemplate, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_SomeTemplate<_Tp, _Types...>>
    { using type = _Tp; };



  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _SomeTemplate, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up>
    { using type = _SomeTemplate<_Up, _Types...>; };


  template<typename _Ptr, typename = void>
    struct __ptr_traits_elem : __get_first_arg<_Ptr>
    { };







  template<typename _Ptr>
    struct __ptr_traits_elem<_Ptr, __void_t<typename _Ptr::element_type>>
    { using type = typename _Ptr::element_type; };


  template<typename _Ptr>
    using __ptr_traits_elem_t = typename __ptr_traits_elem<_Ptr>::type;




  template<typename _Ptr, typename _Elt, bool = is_void<_Elt>::value>
    struct __ptr_traits_ptr_to
    {
      using pointer = _Ptr;
      using element_type = _Elt;







      static pointer
      pointer_to(element_type& __r)





      { return pointer::pointer_to(__r); }
    };


  template<typename _Ptr, typename _Elt>
    struct __ptr_traits_ptr_to<_Ptr, _Elt, true>
    { };


  template<typename _Tp>
    struct __ptr_traits_ptr_to<_Tp*, _Tp, false>
    {
      using pointer = _Tp*;
      using element_type = _Tp;






      static pointer
      pointer_to(element_type& __r) noexcept
      { return std::addressof(__r); }
    };

  template<typename _Ptr, typename _Elt>
    struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt>
    {
    private:
      template<typename _Tp>
 using __diff_t = typename _Tp::difference_type;

      template<typename _Tp, typename _Up>
 using __rebind = __type_identity<typename _Tp::template rebind<_Up>>;

    public:

      using pointer = _Ptr;


      using element_type = _Elt;


      using difference_type = __detected_or_t<ptrdiff_t, __diff_t, _Ptr>;


      template<typename _Up>
 using rebind = typename __detected_or_t<__replace_first_arg<_Ptr, _Up>,
      __rebind, _Ptr, _Up>::type;
    };



  template<typename _Ptr>
    struct __ptr_traits_impl<_Ptr, __undefined>
    { };







  template<typename _Ptr>
    struct pointer_traits : __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>>
    { };







  template<typename _Tp>
    struct pointer_traits<_Tp*> : __ptr_traits_ptr_to<_Tp*, _Tp>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up> using rebind = _Up*;
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }


  template<typename _Ptr>
    constexpr typename std::pointer_traits<_Ptr>::element_type*
    __to_address(const _Ptr& __ptr)
    { return std::__to_address(__ptr.operator->()); }

}
namespace std __attribute__ ((__visibility__ ("default")))
{

 
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
      template<typename _Iter>
 friend class reverse_iterator;
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::pointer pointer;

      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      constexpr
      reverse_iterator()
      noexcept(noexcept(_Iterator()))
      : current()
      { }




      explicit constexpr
      reverse_iterator(iterator_type __x)
      noexcept(noexcept(_Iterator(__x)))
      : current(__x)
      { }




      constexpr
      reverse_iterator(const reverse_iterator& __x)
      noexcept(noexcept(_Iterator(__x.current)))
      : current(__x.current)
      { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>



 constexpr
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 noexcept(noexcept(_Iterator(__x.current)))
 : current(__x.current)
 { }


      template<typename _Iter>




 constexpr
 reverse_iterator&
 operator=(const reverse_iterator<_Iter>& __x)
 noexcept(noexcept(current = __x.current))
 {
   current = __x.current;
   return *this;
 }





      [[__nodiscard__]]
      constexpr iterator_type
      base() const
      noexcept(noexcept(_Iterator(current)))
      { return current; }
      [[__nodiscard__]]
      constexpr reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      [[__nodiscard__]]
      constexpr pointer
      operator->() const




      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      constexpr reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      constexpr reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      constexpr reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      constexpr reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      [[__nodiscard__]]
      constexpr reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      constexpr reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      [[__nodiscard__]]
      constexpr reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      constexpr reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      [[__nodiscard__]]
      constexpr reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    private:
      template<typename _Tp>
 static constexpr _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static constexpr pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }




  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __x.base() > __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() != __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() >= __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() <= __y.base(); }
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }
  template<typename _Iterator>
   
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
   
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;





      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
     
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

     
      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      [[__nodiscard__]]
      back_insert_iterator&
      operator*()
      { return *this; }


     
      back_insert_iterator&
      operator++()
      { return *this; }


     
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
  template<typename _Container>
    [[__nodiscard__]]
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;





      explicit
      front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
     
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

     
      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      [[__nodiscard__]]
      front_insert_iterator&
      operator*()
      { return *this; }


     
      front_insert_iterator&
      operator++()
      { return *this; }


     
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
  template<typename _Container>
    [[__nodiscard__]]
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {



      typedef typename _Container::iterator _Iter;

    protected:
      _Container* container;
      _Iter iter;

    public:

      typedef _Container container_type;
     
      insert_iterator(_Container& __x, _Iter __i)
      : container(std::__addressof(__x)), iter(__i) {}
     
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

     
      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      [[__nodiscard__]]
      insert_iterator&
      operator*()
      { return *this; }


     
      insert_iterator&
      operator++()
      { return *this; }


     
      insert_iterator&
      operator++(int)
      { return *this; }
    };

  template<typename _Container>
    [[__nodiscard__]]
    inline insert_iterator<_Container>
    inserter(_Container& __x, typename _Container::iterator __i)
    { return insert_iterator<_Container>(__x, __i); }





}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef std::iterator_traits<_Iterator> __traits_type;


      template<typename _Iter>
 using __convertible_from
   = std::__enable_if_t<std::is_convertible<_Iter, _Iterator>::value>;


    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;





      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }



      template<typename _Iter, typename = __convertible_from<_Iter>>

 __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 noexcept
        : _M_current(__i.base()) { }


     
      reference
      operator*() const noexcept
      { return *_M_current; }

     
      pointer
      operator->() const noexcept
      { return _M_current; }

     
      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

     
      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


     
      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

     
      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


     
      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

     
      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

     
      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

     
      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

     
      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

     
      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }






  template<typename _IteratorL, typename _IteratorR, typename _Container>


    [[__nodiscard__]]
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
   
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }






  template<typename _Iterator, typename _Container>
    constexpr auto
    __to_address(const __gnu_cxx::__normal_iterator<_Iterator,
          _Container>& __it) noexcept
    -> decltype(std::__to_address(__it.base()))
    { return std::__to_address(__it.base()); }
  namespace __detail
  {
  }
  template<typename _Iterator>
    class move_iterator



    {
      _Iterator _M_current;

      using __traits_type = iterator_traits<_Iterator>;

      using __base_ref = typename __traits_type::reference;


      template<typename _Iter2>
 friend class move_iterator;
    public:
      using iterator_type = _Iterator;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      using reference
 = __conditional_t<is_reference<__base_ref>::value,
     typename remove_reference<__base_ref>::type&&,
     __base_ref>;


      constexpr
      move_iterator()
      : _M_current() { }

      explicit constexpr
      move_iterator(iterator_type __i)
      : _M_current(std::move(__i)) { }

      template<typename _Iter>



 constexpr
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i._M_current) { }

      template<typename _Iter>




 constexpr
 move_iterator& operator=(const move_iterator<_Iter>& __i)
 {
   _M_current = __i._M_current;
   return *this;
 }


      [[__nodiscard__]]
      constexpr iterator_type
      base() const
      { return _M_current; }
      [[__nodiscard__]]
      constexpr reference
      operator*() const



      { return static_cast<reference>(*_M_current); }


      [[__nodiscard__]]
      constexpr pointer
      operator->() const
      { return _M_current; }

      constexpr move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      constexpr move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }







      constexpr move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      constexpr move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      [[__nodiscard__]]
      constexpr move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      constexpr move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      [[__nodiscard__]]
      constexpr move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      constexpr move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      [[__nodiscard__]]
      constexpr reference
      operator[](difference_type __n) const



      { return std::move(_M_current[__n]); }
    };

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return __x.base() == __y.base(); }
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }


  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__x < __y); }




  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }
  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(std::move(__i)); }

  template<typename _Iterator, typename _ReturnType
    = __conditional_t<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
  _Iterator, move_iterator<_Iterator>>>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = __conditional_t<__move_if_noexcept_cond<_Tp>::value,
        const _Tp*, move_iterator<_Tp*>>>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }
  template<typename _Iterator>
   
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
   
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
  template<typename _InputIterator>
    using __iter_key_t = remove_const_t<
      typename iterator_traits<_InputIterator>::value_type::first_type>;

  template<typename _InputIterator>
    using __iter_val_t
      = typename iterator_traits<_InputIterator>::value_type::second_type;

  template<typename _T1, typename _T2>
    struct pair;

  template<typename _InputIterator>
    using __iter_to_alloc_t
      = pair<const __iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>>;



}

namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;

  template<typename _Ite, typename _Seq, typename _Cat>
    struct _Safe_iterator;
}

namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




   
    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

 
  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

 
  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




   
    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
     
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

 
  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

 
  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
     
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

 
  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

 
  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

 
  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

     
      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>

 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

     
      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>

 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

     
      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
   
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

     
      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
   
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

     
      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
   
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

     
      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
   
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}




       
namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _Tp>
    constexpr _Tp
    __rotl(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x << (__r % __uNd)) | (__x >> ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x << __r) | (__x >> ((_Nd - __r) % _Nd));
      else
 return (__x >> -__r) | (__x << ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr _Tp
    __rotr(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x >> (__r % __uNd)) | (__x << ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x >> __r) | (__x << ((_Nd - __r) % _Nd));
      else
 return (__x << -__r) | (__x >> ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr int
    __countl_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 {
   constexpr int __diff = _Nd_u - _Nd;
   return __builtin_clz(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ul)
 {
   constexpr int __diff = _Nd_ul - _Nd;
   return __builtin_clzl(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ull)
 {
   constexpr int __diff = _Nd_ull - _Nd;
   return __builtin_clzll(__x) - __diff;
 }
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   unsigned long long __high = __x >> _Nd_ull;
   if (__high != 0)
     {
       constexpr int __diff = (2 * _Nd_ull) - _Nd;
       return __builtin_clzll(__high) - __diff;
     }
   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   return (_Nd - _Nd_ull) + __builtin_clzll(__low);
 }
    }

  template<typename _Tp>
    constexpr int
    __countl_one(_Tp __x) noexcept
    {
      return std::__countl_zero<_Tp>((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __countr_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_ctz(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_ctzl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_ctzll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   if (__low != 0)
     return __builtin_ctzll(__low);
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_ctzll(__high) + _Nd_ull;
 }
    }

  template<typename _Tp>
    constexpr int
    __countr_one(_Tp __x) noexcept
    {
      return std::__countr_zero((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __popcount(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_popcount(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_popcountl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_popcountll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_popcountll(__low) + __builtin_popcountll(__high);
 }
    }

  template<typename _Tp>
    constexpr bool
    __has_single_bit(_Tp __x) noexcept
    { return std::__popcount(__x) == 1; }

  template<typename _Tp>
    constexpr _Tp
    __bit_ceil(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;
      if (__x == 0 || __x == 1)
        return 1;
      auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1u));




      if (!std::__is_constant_evaluated())
 {
   do { if (std::__is_constant_evaluated() && !bool(__shift_exponent != __int_traits<_Tp>::__digits)) __builtin_unreachable(); } while (false);
 }

      using __promoted_type = decltype(__x << 1);
      if constexpr (!is_same<__promoted_type, _Tp>::value)
 {





   const int __extra_exp = sizeof(__promoted_type) / sizeof(_Tp) / 2;
   __shift_exponent |= (__shift_exponent & _Nd) << __extra_exp;
 }
      return (_Tp)1u << __shift_exponent;
    }

  template<typename _Tp>
    constexpr _Tp
    __bit_floor(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if (__x == 0)
        return 0;
      return (_Tp)1u << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));
    }

  template<typename _Tp>
    constexpr int
    __bit_width(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      return _Nd - std::__countl_zero(__x);
    }

}





namespace std __attribute__ ((__visibility__ ("default")))
{






  template<typename _Tp, typename _Up>
    constexpr
    inline int
    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
    {

      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
 return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
      swap(*__a, *__b);

    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
   
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }

  template<typename _Ite, typename _Seq>
    _Ite
    __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
   std::random_access_iterator_tag>&);




  template<typename _From, typename _To>
   
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (__res - std::__niter_base(__from)); }


  template<typename _Iterator>
   
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }

      template<typename _Tp, typename _Up>
 static void
 __assign_one(_Tp* __to, _Up* __from)
 { *__to = *__from; }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }

      template<typename _Tp, typename _Up>
 static void
 __assign_one(_Tp* __to, _Up* __from)
 { *__to = std::move(*__from); }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp, typename _Up>

 static _Up*
 __copy_m(_Tp* __first, _Tp* __last, _Up* __result)
 {
   const ptrdiff_t _Num = __last - __first;
   if (__builtin_expect(_Num > 1, true))
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   else if (_Num == 1)
     std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       __assign_one(__result, __first);
   return __result + _Num;
 }
    };



  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator;

  struct _Bit_iterator;






  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_move_a2(
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 std::_Deque_iterator<_CharT, _CharT&, _CharT*>);


  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::iterator_category _Category;





      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
         _Category>::__copy_m(__first, __last, __result);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a1(_II __first, _II __last, _OI __result)
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_a(_II, _II,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
   
    _OutputIterator
    __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result,
        bool)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }


  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value, _CharT*>::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >,
        _Size, _CharT*, bool);

  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >, _Size,
        std::_Deque_iterator<_CharT, _CharT&, _CharT*>,
        bool);
  template<typename _II, typename _OI>
   
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
  template<typename _II, typename _OI>
   
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<true>(std::__miter_base(__first),
          std::__miter_base(__last), __result);
    }






  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp, typename _Up>

 static _Up*
 __copy_move_b(_Tp* __first, _Tp* __last, _Up* __result)
 {
   const ptrdiff_t _Num = __last - __first;
   if (__builtin_expect(_Num > 1, true))
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   else if (_Num == 1)
     std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       __assign_one(__result - 1, __first);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::iterator_category _Category;





      return std::__copy_move_backward<_IsMove,
           __memcpyable<_BI2, _BI1>::__value,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II, _II,
       std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a1<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_backward_a(_II, _II,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     

      ;

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     

      ;

      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
            std::__miter_base(__last),
            __result);
    }






  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  template<typename _Ite, typename _Cont, typename _Tp>
   
    inline void
    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
       ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
       const _Tp& __value)
    { std::__fill_a1(__first.base(), __last.base(), __value); }

  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const _VTp&);

 
  void
  __fill_a1(std::_Bit_iterator, std::_Bit_iterator,
     const bool&);

  template<typename _FIte, typename _Tp>
   
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
    void
    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const _Tp&);
  template<typename _ForwardIterator, typename _Tp>
   
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(__first, __last, __value);
    }


  inline constexpr int
  __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned
  __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long
  __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long
  __size_to_integer(unsigned long __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long
  __size_to_integer(unsigned long long __n) { return __n; }


  __extension__ inline constexpr __int128
  __size_to_integer(__int128 __n) { return __n; }
  __extension__ inline constexpr unsigned __int128
  __size_to_integer(unsigned __int128 __n) { return __n; }
  inline constexpr long long
  __size_to_integer(float __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(double __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(long double __n) { return (long long)__n; }

  __extension__ inline constexpr long long
  __size_to_integer(__float128 __n) { return (long long)__n; }


  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
    typename _Tp>
    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
        _Size __n, const _Tp& __value,
        std::input_iterator_tag);

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::output_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::input_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::random_access_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      if (__n <= 0)
 return __first;

      ;

      std::__fill_a(__first, __first + __n, __value);
      return __first + __n;
    }
  template<typename _OI, typename _Size, typename _Tp>
   
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
          std::__iterator_category(__first));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>

 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>

 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !std::__memcmp(__first1, __first2, __len);
   return true;
 }
    };

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   _II);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II, _II,
  std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __memcmpable<_II1, _II2>::__value);
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      return std::__equal_aux1(std::__niter_base(__first1),
          std::__niter_base(__last1),
          std::__niter_base(__first2));
    }

  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  _II2);

  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(_II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename _II1, typename _Seq1, typename _Cat1,
    typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>

 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>

 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>

 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
   
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>

 static bool
 __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   using __gnu_cxx::__ops::__iter_less_iter;
   return std::__lexicographical_compare_impl(__first1, __last1,
           __first2, __last2,
           __iter_less_iter());
 }

      template<typename _II1, typename _II2>

 static int
 __3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   while (__first1 != __last1)
     {
       if (__first2 == __last2)
  return +1;
       if (*__first1 < *__first2)
  return -1;
       if (*__first2 < *__first1)
  return +1;
       ++__first1;
       ++__first2;
     }
   return int(__first2 == __last2) - 1;
 }
    };

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>

 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 { return __3way(__first1, __last1, __first2, __last2) < 0; }

      template<typename _Tp, typename _Up>

 static ptrdiff_t
 __3way(const _Tp* __first1, const _Tp* __last1,
        const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = std::__memcmp(__first1, __first2, __len))
       return __result;
   return ptrdiff_t(__len1 - __len2);
 }
    };

  template<typename _II1, typename _II2>
   
    inline bool
    __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value







  );

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 _Tp2*, _Tp2*);

  template<typename _Tp1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(_Tp1*, _Tp1*,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II1, typename _II2>
   
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      return std::__lexicographical_compare_aux1(std::__niter_base(__first1),
       std::__niter_base(__last1),
       std::__niter_base(__first2),
       std::__niter_base(__last2));
    }

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _II2>
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  _II2, _II2);

  template<typename _II1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    bool
    __lexicographical_compare_aux(
  _II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
   
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
  template<typename _ForwardIterator, typename _Tp>
   
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  template<typename _Tp>
    inline constexpr _Tp
    __lg(_Tp __n)
    {

      return std::__bit_width(make_unsigned_t<_Tp>(__n)) - 1;
    }


  template<typename _II1, typename _II2>
   
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(__first1, __last1, __first2);
    }
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
  template<typename _II1, typename _II2>
   
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2);
    }
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2,
          __binary_pred);
    }
  template<typename _II1, typename _II2>
   
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(__first1, __last1,
      __first2, __last2);
    }
  template<typename _II1, typename _II2, typename _Compare>
   
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
  template<typename _InputIterator1, typename _InputIterator2>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
  template<typename _InputIterator1, typename _InputIterator2>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }





  template<typename _InputIterator, typename _Predicate>
   
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
   
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;

 case 2:
   if (__pred(__first))
     return __first;
   ++__first;

 case 1:
   if (__pred(__first))
     return __first;
   ++__first;

 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
   
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Predicate>
   
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }

  template<typename _ForwardIterator, typename _Predicate>
   
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }



}
       
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
  __extension__ template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; __extension__ template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };

}


namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {



    template<typename _Tp>
    struct __floating_point_constant
    {
      static const _Tp __value;
    };



    template<typename _Tp>
      struct __numeric_constants
      {

        static _Tp __pi() throw()
        { return static_cast<_Tp>(3.1415926535897932384626433832795029L); }

        static _Tp __pi_2() throw()
        { return static_cast<_Tp>(1.5707963267948966192313216916397514L); }

        static _Tp __pi_3() throw()
        { return static_cast<_Tp>(1.0471975511965977461542144610931676L); }

        static _Tp __pi_4() throw()
        { return static_cast<_Tp>(0.7853981633974483096156608458198757L); }

        static _Tp __1_pi() throw()
        { return static_cast<_Tp>(0.3183098861837906715377675267450287L); }

        static _Tp __2_sqrtpi() throw()
        { return static_cast<_Tp>(1.1283791670955125738961589031215452L); }

        static _Tp __sqrt2() throw()
        { return static_cast<_Tp>(1.4142135623730950488016887242096981L); }

        static _Tp __sqrt3() throw()
        { return static_cast<_Tp>(1.7320508075688772935274463415058723L); }

        static _Tp __sqrtpio2() throw()
        { return static_cast<_Tp>(1.2533141373155002512078826424055226L); }

        static _Tp __sqrt1_2() throw()
        { return static_cast<_Tp>(0.7071067811865475244008443621048490L); }

        static _Tp __lnpi() throw()
        { return static_cast<_Tp>(1.1447298858494001741434273513530587L); }

        static _Tp __gamma_e() throw()
        { return static_cast<_Tp>(0.5772156649015328606065120900824024L); }

        static _Tp __euler() throw()
        { return static_cast<_Tp>(2.7182818284590452353602874713526625L); }
      };
    template<typename _Tp>
    inline bool __isnan(_Tp __x)
    { return std::isnan(__x); }
  }





}

namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {
    template <typename _Tp>
    _Tp
    __bernoulli_series(unsigned int __n)
    {

      static const _Tp __num[28] = {
        _Tp(1UL), -_Tp(1UL) / _Tp(2UL),
        _Tp(1UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(1UL) / _Tp(42UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(5UL) / _Tp(66UL), _Tp(0UL),
        -_Tp(691UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(7UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(3617UL) / _Tp(510UL), _Tp(0UL),
        _Tp(43867UL) / _Tp(798UL), _Tp(0UL),
        -_Tp(174611) / _Tp(330UL), _Tp(0UL),
        _Tp(854513UL) / _Tp(138UL), _Tp(0UL),
        -_Tp(236364091UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(8553103UL) / _Tp(6UL), _Tp(0UL)
      };

      if (__n == 0)
        return _Tp(1);

      if (__n == 1)
        return -_Tp(1) / _Tp(2);


      if (__n % 2 == 1)
        return _Tp(0);


      if (__n < 28)
        return __num[__n];


      _Tp __fact = _Tp(1);
      if ((__n / 2) % 2 == 0)
        __fact *= _Tp(-1);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
      __fact *= _Tp(2);

      _Tp __sum = _Tp(0);
      for (unsigned int __i = 1; __i < 1000; ++__i)
        {
          _Tp __term = std::pow(_Tp(__i), -_Tp(__n));
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __fact * __sum;
    }
    template<typename _Tp>
    inline _Tp
    __bernoulli(int __n)
    { return __bernoulli_series<_Tp>(__n); }
    template<typename _Tp>
    _Tp
    __log_gamma_bernoulli(_Tp __x)
    {
      _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x
               + _Tp(0.5L) * std::log(_Tp(2)
               * __numeric_constants<_Tp>::__pi());

      const _Tp __xx = __x * __x;
      _Tp __help = _Tp(1) / __x;
      for ( unsigned int __i = 1; __i < 20; ++__i )
        {
          const _Tp __2i = _Tp(2 * __i);
          __help /= __2i * (__2i - _Tp(1)) * __xx;
          __lg += __bernoulli<_Tp>(2 * __i) * __help;
        }

      return __lg;
    }
    template<typename _Tp>
    _Tp
    __log_gamma_lanczos(_Tp __x)
    {
      const _Tp __xm1 = __x - _Tp(1);

      static const _Tp __lanczos_cheb_7[9] = {
       _Tp( 0.99999999999980993227684700473478L),
       _Tp( 676.520368121885098567009190444019L),
       _Tp(-1259.13921672240287047156078755283L),
       _Tp( 771.3234287776530788486528258894L),
       _Tp(-176.61502916214059906584551354L),
       _Tp( 12.507343278686904814458936853L),
       _Tp(-0.13857109526572011689554707L),
       _Tp( 9.984369578019570859563e-6L),
       _Tp( 1.50563273514931155834e-7L)
      };

      static const _Tp __LOGROOT2PI
          = _Tp(0.9189385332046727417803297364056176L);

      _Tp __sum = __lanczos_cheb_7[0];
      for(unsigned int __k = 1; __k < 9; ++__k)
        __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);

      const _Tp __term1 = (__xm1 + _Tp(0.5L))
                        * std::log((__xm1 + _Tp(7.5L))
                       / __numeric_constants<_Tp>::__euler());
      const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
      const _Tp __result = __term1 + (__term2 - _Tp(7));

      return __result;
    }
    template<typename _Tp>
    _Tp
    __log_gamma(_Tp __x)
    {
      if (__x > _Tp(0.5L))
        return __log_gamma_lanczos(__x);
      else
        {
          const _Tp __sin_fact
                 = std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
          if (__sin_fact == _Tp(0))
            std::__throw_domain_error(("Argument is nonpositive integer " "in __log_gamma")
                                                           );
          return __numeric_constants<_Tp>::__lnpi()
                     - std::log(__sin_fact)
                     - __log_gamma_lanczos(_Tp(1) - __x);
        }
    }
    template<typename _Tp>
    _Tp
    __log_gamma_sign(_Tp __x)
    {
      if (__x > _Tp(0))
        return _Tp(1);
      else
        {
          const _Tp __sin_fact
                  = std::sin(__numeric_constants<_Tp>::__pi() * __x);
          if (__sin_fact > _Tp(0))
            return (1);
          else if (__sin_fact < _Tp(0))
            return -_Tp(1);
          else
            return _Tp(0);
        }
    }
    template<typename _Tp>
    _Tp
    __log_bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      _Tp __coeff = ::std::lgamma(_Tp(1 + __n))
                  - ::std::lgamma(_Tp(1 + __k))
                  - ::std::lgamma(_Tp(1 + __n - __k));





    }
    template<typename _Tp>
    _Tp
    __bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
      if (__log_coeff > __max_bincoeff)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return std::exp(__log_coeff);
    }
    template<typename _Tp>
    inline _Tp
    __gamma(_Tp __x)
    { return std::exp(__log_gamma(__x)); }
    template<typename _Tp>
    _Tp
    __psi_series(_Tp __x)
    {
      _Tp __sum = -__numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
      const unsigned int __max_iter = 100000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __x / (__k * (__k + __x));
          __sum += __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
        }
      return __sum;
    }
    template<typename _Tp>
    _Tp
    __psi_asymp(_Tp __x)
    {
      _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
      const _Tp __xx = __x * __x;
      _Tp __xp = __xx;
      const unsigned int __max_iter = 100;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
          __sum -= __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
          __xp *= __xx;
        }
      return __sum;
    }
    template<typename _Tp>
    _Tp
    __psi(_Tp __x)
    {
      const int __n = static_cast<int>(__x + 0.5L);
      const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
      if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x < _Tp(0))
        {
          const _Tp __pi = __numeric_constants<_Tp>::__pi();
          return __psi(_Tp(1) - __x)
               - __pi * std::cos(__pi * __x) / std::sin(__pi * __x);
        }
      else if (__x > _Tp(100))
        return __psi_asymp(__x);
      else
        return __psi_series(__x);
    }
    template<typename _Tp>
    _Tp
    __psi(unsigned int __n, _Tp __x)
    {
      if (__x <= _Tp(0))
        std::__throw_domain_error(("Argument out of range " "in __psi")
                                                 );
      else if (__n == 0)
        return __psi(__x);
      else
        {
          const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);

          const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));



          _Tp __result = std::exp(__ln_nfact) * __hzeta;
          if (__n % 2 == 1)
            __result = -__result;
          return __result;
        }
    }
  }






}
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {
    template <typename _Tp>
    void
    __gamma_temme(_Tp __mu,
                  _Tp & __gam1, _Tp & __gam2, _Tp & __gampl, _Tp & __gammi)
    {

      __gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
      __gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);





      if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
        __gam1 = -_Tp(__numeric_constants<_Tp>::__gamma_e());
      else
        __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);

      __gam2 = (__gammi + __gampl) / (_Tp(2));

      return;
    }
    template <typename _Tp>
    void
    __bessel_jn(_Tp __nu, _Tp __x,
                _Tp & __Jnu, _Tp & __Nnu, _Tp & __Jpnu, _Tp & __Npnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Jnu = _Tp(1);
              __Jpnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0.5L);
            }
          else
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0);
            }
          __Nnu = -std::numeric_limits<_Tp>::infinity();
          __Npnu = std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();




      const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = (__x < __x_min
                    ? static_cast<int>(__nu + _Tp(0.5L))
                    : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
      int __isign = 1;
      _Tp __h = __nu * __xi;
      if (__h < __fp_min)
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for (__i = 1; __i <= __max_iter; ++__i)
        {
          __b += __xi2;
          __d = __b - __d;
          if (std::abs(__d) < __fp_min)
            __d = __fp_min;
          __c = __b - _Tp(1) / __c;
          if (std::abs(__c) < __fp_min)
            __c = __fp_min;
          __d = _Tp(1) / __d;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (__d < _Tp(0))
            __isign = -__isign;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large in __bessel_jn; " "try asymptotic expansion.")
                                                                   );
      _Tp __Jnul = __isign * __fp_min;
      _Tp __Jpnul = __h * __Jnul;
      _Tp __Jnul1 = __Jnul;
      _Tp __Jpnu1 = __Jpnul;
      _Tp __fact = __nu * __xi;
      for ( int __l = __nl; __l >= 1; --__l )
        {
          const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
          __fact -= __xi;
          __Jpnul = __fact * __Jnutemp - __Jnul;
          __Jnul = __Jnutemp;
        }
      if (__Jnul == _Tp(0))
        __Jnul = __eps;
      _Tp __f= __Jpnul / __Jnul;
      _Tp __Nmu, __Nnu1, __Npmu, __Jmu;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          _Tp __fact = (std::abs(__pimu) < __eps
                      ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          _Tp __fact2 = (std::abs(__e) < __eps
                       ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi())
                   * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          __e = std::exp(__e);
          _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
          _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
          const _Tp __pimu2 = __pimu / _Tp(2);
          _Tp __fact3 = (std::abs(__pimu2) < __eps
                       ? _Tp(1) : std::sin(__pimu2) / __pimu2 );
          _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
          _Tp __c = _Tp(1);
          __d = -__x2 * __x2;
          _Tp __sum = __ff + __r * __q;
          _Tp __sum1 = __p;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / _Tp(__i);
              __p /= _Tp(__i) - __mu;
              __q /= _Tp(__i) + __mu;
              const _Tp __del = __c * (__ff + __r * __q);
              __sum += __del;
              const _Tp __del1 = __c * __p - __i * __del;
              __sum1 += __del1;
              if ( std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)) )
                break;
            }
          if ( __i > __max_iter )
            std::__throw_runtime_error(("Bessel y series failed to converge " "in __bessel_jn.")
                                                             );
          __Nmu = -__sum;
          __Nnu1 = -__sum1 * __xi2;
          __Npmu = __mu * __xi * __Nmu - __Nnu1;
          __Jmu = __w / (__Npmu - __f * __Nmu);
        }
      else
        {
          _Tp __a = _Tp(0.25L) - __mu2;
          _Tp __q = _Tp(1);
          _Tp __p = -__xi / _Tp(2);
          _Tp __br = _Tp(2) * __x;
          _Tp __bi = _Tp(2);
          _Tp __fact = __a * __xi / (__p * __p + __q * __q);
          _Tp __cr = __br + __q * __fact;
          _Tp __ci = __bi + __p * __fact;
          _Tp __den = __br * __br + __bi * __bi;
          _Tp __dr = __br / __den;
          _Tp __di = -__bi / __den;
          _Tp __dlr = __cr * __dr - __ci * __di;
          _Tp __dli = __cr * __di + __ci * __dr;
          _Tp __temp = __p * __dlr - __q * __dli;
          __q = __p * __dli + __q * __dlr;
          __p = __temp;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a += _Tp(2 * (__i - 1));
              __bi += _Tp(2);
              __dr = __a * __dr + __br;
              __di = __a * __di + __bi;
              if (std::abs(__dr) + std::abs(__di) < __fp_min)
                __dr = __fp_min;
              __fact = __a / (__cr * __cr + __ci * __ci);
              __cr = __br + __cr * __fact;
              __ci = __bi - __ci * __fact;
              if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                __cr = __fp_min;
              __den = __dr * __dr + __di * __di;
              __dr /= __den;
              __di /= -__den;
              __dlr = __cr * __dr - __ci * __di;
              __dli = __cr * __di + __ci * __dr;
              __temp = __p * __dlr - __q * __dli;
              __q = __p * __dli + __q * __dlr;
              __p = __temp;
              if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
                break;
          }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Lentz's method failed " "in __bessel_jn.")
                                                             );
          const _Tp __gam = (__p - __f) / __q;
          __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));

          __Jmu = ::std::copysign(__Jmu, __Jnul);




          __Nmu = __gam * __Jmu;
          __Npmu = (__p + __q / __gam) * __Nmu;
          __Nnu1 = __mu * __xi * __Nmu - __Npmu;
      }
      __fact = __Jmu / __Jnul;
      __Jnu = __fact * __Jnul1;
      __Jpnu = __fact * __Jpnu1;
      for (__i = 1; __i <= __nl; ++__i)
        {
          const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
          __Nmu = __Nnu1;
          __Nnu1 = __Nnutemp;
        }
      __Nnu = __Nmu;
      __Npnu = __nu * __xi * __Nmu - __Nnu1;

      return;
    }
    template <typename _Tp>
    void
    __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp & __Jnu, _Tp & __Nnu)
    {
      const _Tp __mu = _Tp(4) * __nu * __nu;
      const _Tp __8x = _Tp(8) * __x;

      _Tp __P = _Tp(0);
      _Tp __Q = _Tp(0);

      _Tp __k = _Tp(0);
      _Tp __term = _Tp(1);

      int __epsP = 0;
      int __epsQ = 0;

      _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      do
        {
          __term *= (__k == 0
                     ? _Tp(1)
                     : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));

          __epsP = std::abs(__term) < __eps * std::abs(__P);
          __P += __term;

          __k++;

          __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
          __epsQ = std::abs(__term) < __eps * std::abs(__Q);
          __Q += __term;

          if (__epsP && __epsQ && __k > (__nu / 2.))
            break;

          __k++;
        }
      while (__k < 1000);

      const _Tp __chi = __x - (__nu + _Tp(0.5L))
                             * __numeric_constants<_Tp>::__pi_2();

      const _Tp __c = std::cos(__chi);
      const _Tp __s = std::sin(__chi);

      const _Tp __coef = std::sqrt(_Tp(2)
                             / (__numeric_constants<_Tp>::__pi() * __x));

      __Jnu = __coef * (__c * __P - __s * __Q);
      __Nnu = __coef * (__s * __P + __c * __Q);

      return;
    }
    template <typename _Tp>
    _Tp
    __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn,
                           unsigned int __max_iter)
    {
      if (__x == _Tp(0))
 return __nu == _Tp(0) ? _Tp(1) : _Tp(0);

      const _Tp __x2 = __x / _Tp(2);
      _Tp __fact = __nu * std::log(__x2);

      __fact -= ::std::lgamma(__nu + _Tp(1));



      __fact = std::exp(__fact);
      const _Tp __xx4 = __sgn * __x2 * __x2;
      _Tp __Jn = _Tp(1);
      _Tp __term = _Tp(1);

      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
          __Jn += __term;
          if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      return __fact * __Jn;
    }
    template<typename _Tp>
    _Tp
    __cyl_bessel_j(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_j.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, -_Tp(1), 200);
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __J_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __J_nu;
        }
    }
    template<typename _Tp>
    _Tp
    __cyl_neumann_n(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_neumann_n.")
                                                            );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __N_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __N_nu;
        }
    }
    template <typename _Tp>
    void
    __sph_bessel_jn(unsigned int __n, _Tp __x,
                    _Tp & __j_n, _Tp & __n_n, _Tp & __jp_n, _Tp & __np_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
      __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __j_n = __factor * __J_nu;
      __n_n = __factor * __N_nu;
      __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
      __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);

      return;
    }
    template <typename _Tp>
    _Tp
    __sph_bessel(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_bessel.")
                                                         );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        {
          if (__n == 0)
            return _Tp(1);
          else
            return _Tp(0);
        }
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __j_n;
        }
    }
    template <typename _Tp>
    _Tp
    __sph_neumann(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_neumann.")
                                                          );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        return -std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __n_n;
        }
    }
  }






}
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {
    template<typename _Tp>
    _Tp
    __beta_gamma(_Tp __x, _Tp __y)
    {

      _Tp __bet;

      if (__x > __y)
        {
          __bet = ::std::tgamma(__x)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__y);
        }
      else
        {
          __bet = ::std::tgamma(__y)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__x);
        }
      return __bet;
    }
    template<typename _Tp>
    _Tp
    __beta_lgamma(_Tp __x, _Tp __y)
    {

      _Tp __bet = ::std::lgamma(__x)
                + ::std::lgamma(__y)
                - ::std::lgamma(__x + __y);





      __bet = std::exp(__bet);
      return __bet;
    }
    template<typename _Tp>
    _Tp
    __beta_product(_Tp __x, _Tp __y)
    {

      _Tp __bet = (__x + __y) / (__x * __y);

      unsigned int __max_iter = 1000000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          _Tp __term = (_Tp(1) + (__x + __y) / __k)
                     / ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
          __bet *= __term;
        }

      return __bet;
    }
    template<typename _Tp>
    inline _Tp
    __beta(_Tp __x, _Tp __y)
    {
      if (__isnan(__x) || __isnan(__y))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __beta_lgamma(__x, __y);
    }
  }






}
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {
    template<typename _Tp>
    _Tp
    __ellint_rf(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rf.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim)
        std::__throw_domain_error(("Argument too small in __ellint_rf"));
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(24);
          const _Tp __c2 = _Tp(1) / _Tp(10);
          const _Tp __c3 = _Tp(3) / _Tp(44);
          const _Tp __c4 = _Tp(1) / _Tp(14);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn) / _Tp(3);
              __xndev = 2 - (__mu + __xn) / __mu;
              __yndev = 2 - (__mu + __yn) / __mu;
              __zndev = 2 - (__mu + __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
          const _Tp __e3 = __xndev * __yndev * __zndev;
          const _Tp __s = _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2
                   + __c4 * __e3;

          return __s / std::sqrt(__mu);
        }
    }
    template<typename _Tp>
    _Tp
    __comp_ellint_1_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk / _Tp(4);
      _Tp __sum = _Tp(1) + __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          __term *= (2 * __i - 1) * __kk / (2 * __i);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __numeric_constants<_Tp>::__pi_2() * __sum;
    }
    template<typename _Tp>
    _Tp
    __comp_ellint_1(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) >= _Tp(1))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
    }
    template<typename _Tp>
    _Tp
    __ellint_1(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_1."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __s = std::sin(__phi_red);
          const _Tp __c = std::cos(__phi_red);

          const _Tp __F = __s
                        * __ellint_rf(__c * __c,
                                _Tp(1) - __k * __k * __s * __s, _Tp(1));

          if (__n == 0)
            return __F;
          else
            return __F + _Tp(2) * __n * __comp_ellint_1(__k);
        }
    }
    template<typename _Tp>
    _Tp
    __comp_ellint_2_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk;
      _Tp __sum = __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          const _Tp __i2m = 2 * __i - 1;
          const _Tp __i2 = 2 * __i;
          __term *= __i2m * __i2m * __kk / (__i2 * __i2);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term / __i2m;
        }

      return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
    }
    template<typename _Tp>
    _Tp
    __ellint_rd(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rd.")
                                                        );
      else if (__x + __y < __lolim || __z < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rd.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(6);
          const _Tp __c3 = _Tp(9) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              _Tp __xnroot = std::sqrt(__xn);
              _Tp __ynroot = std::sqrt(__yn);
              _Tp __znroot = std::sqrt(__zn);
              _Tp __lambda = __xnroot * (__ynroot + __znroot)
                           + __ynroot * __znroot;
              __sigma += __power4 / (__znroot * (__zn + __lambda));
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          _Tp __ea = __xndev * __yndev;
          _Tp __eb = __zndev * __zndev;
          _Tp __ec = __ea - __eb;
          _Tp __ed = __ea - _Tp(6) * __eb;
          _Tp __ef = __ed + __ec + __ec;
          _Tp __s1 = __ed * (-__c1 + __c3 * __ed
                                   / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef
                                   / _Tp(2));
          _Tp __s2 = __zndev
                   * (__c2 * __ef
                    + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));

          return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2)
                                        / (__mu * std::sqrt(__mu));
        }
    }
    template<typename _Tp>
    _Tp
    __comp_ellint_2(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) == 1)
        return _Tp(1);
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               - __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
        }
    }
    template<typename _Tp>
    _Tp
    __ellint_2(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_2."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __E = __s
                        * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        - __kk * __sss
                        * __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        / _Tp(3);

          if (__n == 0)
            return __E;
          else
            return __E + _Tp(2) * __n * __comp_ellint_2(__k);
        }
    }
    template<typename _Tp>
    _Tp
    __ellint_rc(_Tp __x, _Tp __y)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rc.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(7);
          const _Tp __c2 = _Tp(9) / _Tp(22);
          const _Tp __c3 = _Tp(3) / _Tp(10);
          const _Tp __c4 = _Tp(3) / _Tp(8);

          _Tp __xn = __x;
          _Tp __yn = __y;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __sn;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + _Tp(2) * __yn) / _Tp(3);
              __sn = (__yn + __mu) / __mu - _Tp(2);
              if (std::abs(__sn) < __errtol)
                break;
              const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn)
                             + __yn;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
            }

          _Tp __s = __sn * __sn
                  * (__c3 + __sn*(__c1 + __sn * (__c4 + __sn * __c2)));

          return (_Tp(1) + __s) / std::sqrt(__mu);
        }
    }
    template<typename _Tp>
    _Tp
    __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1)/_Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rj.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim || __p < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rj")
                                                       );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(3);
          const _Tp __c3 = _Tp(3) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __pn = __p;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev, __pndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              __pndev = (__mu - __pn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              __epsilon = std::max(__epsilon, std::abs(__pndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot)
                                + __xnroot * __ynroot * __znroot;
              const _Tp __alpha2 = __alpha1 * __alpha1;
              const _Tp __beta = __pn * (__pn + __lambda)
                                      * (__pn + __lambda);
              __sigma += __power4 * __ellint_rc(__alpha2, __beta);
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
              __pn = __c0 * (__pn + __lambda);
            }

          _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
          _Tp __eb = __xndev * __yndev * __zndev;
          _Tp __ec = __pndev * __pndev;
          _Tp __e2 = __ea - _Tp(3) * __ec;
          _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);
          _Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4)
                            - _Tp(3) * __c4 * __e3 / _Tp(2));
          _Tp __s2 = __eb * (__c2 / _Tp(2)
                   + __pndev * (-__c3 - __c3 + __pndev * __c4));
          _Tp __s3 = __pndev * __ea * (__c2 - __pndev * __c3)
                   - __c2 * __pndev * __ec;

          return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3)
                                             / (__mu * std::sqrt(__mu));
        }
    }
    template<typename _Tp>
    _Tp
    __comp_ellint_3(_Tp __k, _Tp __nu)
    {

      if (__isnan(__k) || __isnan(__nu))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__nu == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               + __nu
               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu)
               / _Tp(3);
        }
    }
    template<typename _Tp>
    _Tp
    __ellint_3(_Tp __k, _Tp __nu, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_3."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __Pi = __s
                         * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                         + __nu * __sss
                         * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
                                       _Tp(1) - __nu * __ss) / _Tp(3);

          if (__n == 0)
            return __Pi;
          else
            return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
        }
    }
  }





}
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {
    template<typename _Tp> _Tp __expint_E1(_Tp);
    template<typename _Tp>
    _Tp
    __expint_E1_series(_Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(0);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= - __x / __i;
          if (std::abs(__term) < __eps)
            break;
          if (__term >= _Tp(0))
            __esum += __term / __i;
          else
            __osum += __term / __i;
        }

      return - __esum - __osum
             - __numeric_constants<_Tp>::__gamma_e() - std::log(__x);
    }
    template<typename _Tp>
    _Tp
    __expint_E1_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(1);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= - __i / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          if (__term >= _Tp(0))
            __esum += __term;
          else
            __osum += __term;
        }

      return std::exp(- __x) * (__esum + __osum) / __x;
    }
    template<typename _Tp>
    _Tp
    __expint_En_series(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const int __nm1 = __n - 1;
      _Tp __ans = (__nm1 != 0
                ? _Tp(1) / __nm1 : -std::log(__x)
                                   - __numeric_constants<_Tp>::__gamma_e());
      _Tp __fact = _Tp(1);
      for (int __i = 1; __i <= __max_iter; ++__i)
        {
          __fact *= -__x / _Tp(__i);
          _Tp __del;
          if ( __i != __nm1 )
            __del = -__fact / _Tp(__i - __nm1);
          else
            {
              _Tp __psi = -__numeric_constants<_Tp>::gamma_e();
              for (int __ii = 1; __ii <= __nm1; ++__ii)
                __psi += _Tp(1) / _Tp(__ii);
              __del = __fact * (__psi - std::log(__x));
            }
          __ans += __del;
          if (std::abs(__del) < __eps * std::abs(__ans))
            return __ans;
        }
      std::__throw_runtime_error(("Series summation failed " "in __expint_En_series.")
                                                              );
    }
    template<typename _Tp>
    _Tp
    __expint_En_cont_frac(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = std::numeric_limits<_Tp>::min();
      const int __nm1 = __n - 1;
      _Tp __b = __x + _Tp(__n);
      _Tp __c = _Tp(1) / __fp_min;
      _Tp __d = _Tp(1) / __b;
      _Tp __h = __d;
      for ( unsigned int __i = 1; __i <= __max_iter; ++__i )
        {
          _Tp __a = -_Tp(__i * (__nm1 + __i));
          __b += _Tp(2);
          __d = _Tp(1) / (__a * __d + __b);
          __c = __b + __a / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            {
              const _Tp __ans = __h * std::exp(-__x);
              return __ans;
            }
        }
      std::__throw_runtime_error(("Continued fraction failed " "in __expint_En_cont_frac.")
                                                                 );
    }
    template<typename _Tp>
    _Tp
    __expint_En_recursion(unsigned int __n, _Tp __x)
    {
      _Tp __En;
      _Tp __E1 = __expint_E1(__x);
      if (__x < _Tp(__n))
        {

          __En = __E1;
          for (unsigned int __j = 2; __j < __n; ++__j)
            __En = (std::exp(-__x) - __x * __En) / _Tp(__j - 1);
        }
      else
        {

          __En = _Tp(1);
          const int __N = __n + 20;
          _Tp __save = _Tp(0);
          for (int __j = __N; __j > 0; --__j)
            {
              __En = (std::exp(-__x) - __j * __En) / __x;
              if (__j == __n)
                __save = __En;
            }
            _Tp __norm = __En / __E1;
            __En /= __norm;
        }

      return __En;
    }
    template<typename _Tp>
    _Tp
    __expint_Ei_series(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __x / __i;
          __sum += __term / __i;
          if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
            break;
        }

      return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
    }
    template<typename _Tp>
    _Tp
    __expint_Ei_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= __i / __x;
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          if (__term >= __prev)
            break;
          __sum += __term;
        }

      return std::exp(__x) * __sum / __x;
    }
    template<typename _Tp>
    _Tp
    __expint_Ei(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_E1(-__x);
      else if (__x < -std::log(std::numeric_limits<_Tp>::epsilon()))
        return __expint_Ei_series(__x);
      else
        return __expint_Ei_asymp(__x);
    }
    template<typename _Tp>
    _Tp
    __expint_E1(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_Ei(-__x);
      else if (__x < _Tp(1))
        return __expint_E1_series(__x);
      else if (__x < _Tp(100))
        return __expint_En_cont_frac(1, __x);
      else
        return __expint_E1_asymp(__x);
    }
    template<typename _Tp>
    _Tp
    __expint_asymp(unsigned int __n, _Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= -(__n - __i + 1) / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __x;
    }
    template<typename _Tp>
    _Tp
    __expint_large_n(unsigned int __n, _Tp __x)
    {
      const _Tp __xpn = __x + __n;
      const _Tp __xpn2 = __xpn * __xpn;
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __xpn;
    }
    template<typename _Tp>
    _Tp
    __expint(unsigned int __n, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n <= 1 && __x == _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __E0 = std::exp(__x) / __x;
          if (__n == 0)
            return __E0;

          _Tp __E1 = __expint_E1(__x);
          if (__n == 1)
            return __E1;

          if (__x == _Tp(0))
            return _Tp(1) / static_cast<_Tp>(__n - 1);

          _Tp __En = __expint_En_recursion(__n, __x);

          return __En;
        }
    }
    template<typename _Tp>
    inline _Tp
    __expint(_Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __expint_Ei(__x);
    }
  }





}
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {
    template<typename _Tp>
    _Tp
    __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fac = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fac += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __conf_hyperg_series.")
                                                                  );

      return __Fac;
    }
    template<typename _Tp>
    _Tp
    __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a / __c;
      const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
      _Tp __F = _Tp(1);
      _Tp __prec;

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while(1)
        {
          _Tp __npam1 = _Tp(__n - 1) + __a;
          _Tp __npcm1 = _Tp(__n - 1) + __c;
          _Tp __npam2 = _Tp(__n - 2) + __a;
          _Tp __npcm2 = _Tp(__n - 2) + __c;
          _Tp __tnm1 = _Tp(2 * __n - 1);
          _Tp __tnm3 = _Tp(2 * __n - 3);
          _Tp __tnm5 = _Tp(2 * __n - 5);
          _Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
          _Tp __F2 = (_Tp(__n) + __a) * __npam1
                   / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          _Tp __F3 = -__npam2 * __npam1 * (_Tp(__n - 2) - __a)
                   / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                   * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          _Tp __E = -__npam1 * (_Tp(__n - 1) - __c)
                   / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          _Tp __r = __An / __Bn;

          __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __conf_hyperg_luke.")
                                                                );

      return __F;
    }
    template<typename _Tp>
    _Tp
    __conf_hyperg(_Tp __a, _Tp __c, _Tp __x)
    {

      const _Tp __c_nint = ::std::nearbyint(__c);



      if (__isnan(__a) || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= 0)
        return std::numeric_limits<_Tp>::infinity();
      else if (__a == _Tp(0))
        return _Tp(1);
      else if (__c == __a)
        return std::exp(__x);
      else if (__x < _Tp(0))
        return __conf_hyperg_luke(__a, __c, __x);
      else
        return __conf_hyperg_series(__a, __c, __x);
    }
    template<typename _Tp>
    _Tp
    __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fabc = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fabc += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __hyperg_series.")
                                                             );

      return __Fabc;
    }







    template<typename _Tp>
    _Tp
    __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a * __b / __c;
      const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) * (__b + _Tp(2))
                     / (_Tp(2) * (__c + _Tp(1)));

      _Tp __F = _Tp(1);

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while (1)
        {
          const _Tp __npam1 = _Tp(__n - 1) + __a;
          const _Tp __npbm1 = _Tp(__n - 1) + __b;
          const _Tp __npcm1 = _Tp(__n - 1) + __c;
          const _Tp __npam2 = _Tp(__n - 2) + __a;
          const _Tp __npbm2 = _Tp(__n - 2) + __b;
          const _Tp __npcm2 = _Tp(__n - 2) + __c;
          const _Tp __tnm1 = _Tp(2 * __n - 1);
          const _Tp __tnm3 = _Tp(2 * __n - 3);
          const _Tp __tnm5 = _Tp(2 * __n - 5);
          const _Tp __n2 = __n * __n;
          const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n
                         + _Tp(2) - __a * __b - _Tp(2) * (__a + __b))
                         / (_Tp(2) * __tnm3 * __npcm1);
          const _Tp __F2 = -(_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n
                         + _Tp(2) - __a * __b) * __npam1 * __npbm1
                         / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1
                         * (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b))
                         / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                         * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          const _Tp __E = -__npam1 * __npbm1 * (_Tp(__n - 1) - __c)
                         / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          const _Tp __r = __An / __Bn;

          const _Tp __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __hyperg_luke.")
                                                           );

      return __F;
    }
    template<typename _Tp>
    _Tp
    __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __d = __c - __a - __b;
      const int __intd = std::floor(__d + _Tp(0.5L));
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __toler = _Tp(1000) * __eps;
      const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
      const bool __d_integer = (std::abs(__d - __intd) < __toler);

      if (__d_integer)
        {
          const _Tp __ln_omx = std::log(_Tp(1) - __x);
          const _Tp __ad = std::abs(__d);
          _Tp __F1, __F2;

          _Tp __d1, __d2;
          if (__d >= _Tp(0))
            {
              __d1 = __d;
              __d2 = _Tp(0);
            }
          else
            {
              __d1 = _Tp(0);
              __d2 = __d;
            }

          const _Tp __lng_c = __log_gamma(__c);


          if (__ad < __eps)
            {

              __F1 = _Tp(0);
            }
          else
            {

              bool __ok_d1 = true;
              _Tp __lng_ad, __lng_ad1, __lng_bd1;
              try
                {
                  __lng_ad = __log_gamma(__ad);
                  __lng_ad1 = __log_gamma(__a + __d1);
                  __lng_bd1 = __log_gamma(__b + __d1);
                }
              catch(...)
                {
                  __ok_d1 = false;
                }

              if (__ok_d1)
                {



                  _Tp __sum1 = _Tp(1);
                  _Tp __term = _Tp(1);
                  _Tp __ln_pre1 = __lng_ad + __lng_c + __d2 * __ln_omx
                                - __lng_ad1 - __lng_bd1;



                  for (int __i = 1; __i < __ad; ++__i)
                    {
                      const int __j = __i - 1;
                      __term *= (__a + __d2 + __j) * (__b + __d2 + __j)
                              / (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
                      __sum1 += __term;
                    }

                  if (__ln_pre1 > __log_max)
                    std::__throw_runtime_error(("Overflow of gamma functions" " in __hyperg_luke.")
                                                                        );
                  else
                    __F1 = std::exp(__ln_pre1) * __sum1;
                }
              else
                {


                  __F1 = _Tp(0);
                }
            }


          bool __ok_d2 = true;
          _Tp __lng_ad2, __lng_bd2;
          try
            {
              __lng_ad2 = __log_gamma(__a + __d2);
              __lng_bd2 = __log_gamma(__b + __d2);
            }
          catch(...)
            {
              __ok_d2 = false;
            }

          if (__ok_d2)
            {


              const int __maxiter = 2000;
              const _Tp __psi_1 = -__numeric_constants<_Tp>::__gamma_e();
              const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
              const _Tp __psi_apd1 = __psi(__a + __d1);
              const _Tp __psi_bpd1 = __psi(__b + __d1);

              _Tp __psi_term = __psi_1 + __psi_1pd - __psi_apd1
                             - __psi_bpd1 - __ln_omx;
              _Tp __fact = _Tp(1);
              _Tp __sum2 = __psi_term;
              _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx
                            - __lng_ad2 - __lng_bd2;


              int __j;
              for (__j = 1; __j < __maxiter; ++__j)
                {


                  const _Tp __term1 = _Tp(1) / _Tp(__j)
                                    + _Tp(1) / (__ad + __j);
                  const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1))
                                    + _Tp(1) / (__b + __d1 + _Tp(__j - 1));
                  __psi_term += __term1 - __term2;
                  __fact *= (__a + __d1 + _Tp(__j - 1))
                          * (__b + __d1 + _Tp(__j - 1))
                          / ((__ad + __j) * __j) * (_Tp(1) - __x);
                  const _Tp __delta = __fact * __psi_term;
                  __sum2 += __delta;
                  if (std::abs(__delta) < __eps * std::abs(__sum2))
                    break;
                }
              if (__j == __maxiter)
                std::__throw_runtime_error(("Sum F2 failed to converge " "in __hyperg_reflect")
                                                                     );

              if (__sum2 == _Tp(0))
                __F2 = _Tp(0);
              else
                __F2 = std::exp(__ln_pre2) * __sum2;
            }
          else
            {


              __F2 = _Tp(0);
            }

          const _Tp __sgn_2 = (__intd % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __F = __F1 + __sgn_2 * __F2;

          return __F;
        }
      else
        {




          bool __ok1 = true;
          _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
          _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
          try
            {
              __sgn_g1ca = __log_gamma_sign(__c - __a);
              __ln_g1ca = __log_gamma(__c - __a);
              __sgn_g1cb = __log_gamma_sign(__c - __b);
              __ln_g1cb = __log_gamma(__c - __b);
            }
          catch(...)
            {
              __ok1 = false;
            }

          bool __ok2 = true;
          _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
          _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
          try
            {
              __sgn_g2a = __log_gamma_sign(__a);
              __ln_g2a = __log_gamma(__a);
              __sgn_g2b = __log_gamma_sign(__b);
              __ln_g2b = __log_gamma(__b);
            }
          catch(...)
            {
              __ok2 = false;
            }

          const _Tp __sgn_gc = __log_gamma_sign(__c);
          const _Tp __ln_gc = __log_gamma(__c);
          const _Tp __sgn_gd = __log_gamma_sign(__d);
          const _Tp __ln_gd = __log_gamma(__d);
          const _Tp __sgn_gmd = __log_gamma_sign(-__d);
          const _Tp __ln_gmd = __log_gamma(-__d);

          const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
          const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;

          _Tp __pre1, __pre2;
          if (__ok1 && __ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre1 < __log_max && __ln_pre2 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre2 = std::exp(__ln_pre2);
                  __pre1 *= __sgn1;
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (__ok1 && !__ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              if (__ln_pre1 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre1 *= __sgn1;
                  __pre2 = _Tp(0);
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (!__ok1 && __ok2)
            {
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre2 < __log_max)
                {
                  __pre1 = _Tp(0);
                  __pre2 = std::exp(__ln_pre2);
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else
            {
              __pre1 = _Tp(0);
              __pre2 = _Tp(0);
              std::__throw_runtime_error(("Underflow of gamma functions " "in __hyperg_reflect")
                                                                   );
            }

          const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d,
                                           _Tp(1) - __x);
          const _Tp __F2 = __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d,
                                           _Tp(1) - __x);

          const _Tp __F = __pre1 * __F1 + __pre2 * __F2;

          return __F;
        }
    }
    template<typename _Tp>
    _Tp
    __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {

      const _Tp __a_nint = ::std::nearbyint(__a);
      const _Tp __b_nint = ::std::nearbyint(__b);
      const _Tp __c_nint = ::std::nearbyint(__c);





      const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
      if (std::abs(__x) >= _Tp(1))
        std::__throw_domain_error(("Argument outside unit circle " "in __hyperg.")
                                                     );
      else if (__isnan(__a) || __isnan(__b)
            || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
        return std::pow(_Tp(1) - __x, __c - __a - __b);
      else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0)
            && __x >= _Tp(0) && __x < _Tp(0.995L))
        return __hyperg_series(__a, __b, __c, __x);
      else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10))
        {


          if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
            return __hyperg_series(__a_nint, __b, __c, __x);
          else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
            return __hyperg_series(__a, __b_nint, __c, __x);
          else if (__x < -_Tp(0.25L))
            return __hyperg_luke(__a, __b, __c, __x);
          else if (__x < _Tp(0.5L))
            return __hyperg_series(__a, __b, __c, __x);
          else
            if (std::abs(__c) > _Tp(10))
              return __hyperg_series(__a, __b, __c, __x);
            else
              return __hyperg_reflect(__a, __b, __c, __x);
        }
      else
        return __hyperg_luke(__a, __b, __c, __x);
    }
  }






}
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {
    template<typename _Tp>
    _Tp
    __poly_legendre_p(unsigned int __l, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == +_Tp(1))
        return +_Tp(1);
      else if (__x == -_Tp(1))
        return (__l % 2 == 1 ? -_Tp(1) : +_Tp(1));
      else
        {
          _Tp __p_lm2 = _Tp(1);
          if (__l == 0)
            return __p_lm2;

          _Tp __p_lm1 = __x;
          if (__l == 1)
            return __p_lm1;

          _Tp __p_l = 0;
          for (unsigned int __ll = 2; __ll <= __l; ++__ll)
            {


              __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2
                    - (__x * __p_lm1 - __p_lm2) / _Tp(__ll);
              __p_lm2 = __p_lm1;
              __p_lm1 = __p_l;
            }

          return __p_l;
        }
    }
    template<typename _Tp>
    _Tp
    __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x,
         _Tp __phase = _Tp(+1))
    {

      if (__m > __l)
        return _Tp(0);
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__m == 0)
        return __poly_legendre_p(__l, __x);
      else
        {
          _Tp __p_mm = _Tp(1);
          if (__m > 0)
            {


              _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
              _Tp __fact = _Tp(1);
              for (unsigned int __i = 1; __i <= __m; ++__i)
                {
                  __p_mm *= __phase * __fact * __root;
                  __fact += _Tp(2);
                }
            }
          if (__l == __m)
            return __p_mm;

          _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
          if (__l == __m + 1)
            return __p_mp1m;

          _Tp __p_lm2m = __p_mm;
          _Tp __P_lm1m = __p_mp1m;
          _Tp __p_lm = _Tp(0);
          for (unsigned int __j = __m + 2; __j <= __l; ++__j)
            {
              __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m
                      - _Tp(__j + __m - 1) * __p_lm2m) / _Tp(__j - __m);
              __p_lm2m = __P_lm1m;
              __P_lm1m = __p_lm;
            }

          return __p_lm;
        }
    }
    template <typename _Tp>
    _Tp
    __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      if (__isnan(__theta))
        return std::numeric_limits<_Tp>::quiet_NaN();

      const _Tp __x = std::cos(__theta);

      if (__m > __l)
        return _Tp(0);
      else if (__m == 0)
        {
          _Tp __P = __poly_legendre_p(__l, __x);
          _Tp __fact = std::sqrt(_Tp(2 * __l + 1)
                     / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          __P *= __fact;
          return __P;
        }
      else if (__x == _Tp(1) || __x == -_Tp(1))
        {

          return _Tp(0);
        }
      else
        {





          const _Tp __sgn = ( __m % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));

          const _Tp __lncirc = ::std::log1p(-__x * __x);





          const _Tp __lnpoch = ::std::lgamma(_Tp(__m + _Tp(0.5L)))
                             - ::std::lgamma(_Tp(__m));




          const _Tp __lnpre_val =
                    -_Tp(0.25L) * __numeric_constants<_Tp>::__lnpi()
                    + _Tp(0.5L) * (__lnpoch + __m * __lncirc);
          const _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m)
                         / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
          _Tp __y_mp1m = __y_mp1m_factor * __y_mm;

          if (__l == __m)
            return __y_mm;
          else if (__l == __m + 1)
            return __y_mp1m;
          else
            {
              _Tp __y_lm = _Tp(0);


              for (unsigned int __ll = __m + 2; __ll <= __l; ++__ll)
                {
                  const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
                  const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
                  const _Tp __fact1 = std::sqrt(__rat1 * _Tp(2 * __ll + 1)
                                                       * _Tp(2 * __ll - 1));
                  const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1)
                                                                / _Tp(2 * __ll - 3));
                  __y_lm = (__x * __y_mp1m * __fact1
                         - (__ll + __m - 1) * __y_mm * __fact2) / _Tp(__ll - __m);
                  __y_mm = __y_mp1m;
                  __y_mp1m = __y_lm;
                }

              return __y_lm;
            }
        }
    }
  }






}
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {
    template <typename _Tp>
    void
    __bessel_ik(_Tp __nu, _Tp __x,
                _Tp & __Inu, _Tp & __Knu, _Tp & __Ipnu, _Tp & __Kpnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Inu = _Tp(1);
              __Ipnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0.5L);
            }
          else
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0);
            }
          __Knu = std::numeric_limits<_Tp>::infinity();
          __Kpnu = -std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = static_cast<int>(__nu + _Tp(0.5L));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __h = __nu * __xi;
      if ( __h < __fp_min )
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for ( __i = 1; __i <= __max_iter; ++__i )
        {
          __b += __xi2;
          __d = _Tp(1) / (__b + __d);
          __c = __b + _Tp(1) / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large " "in __bessel_ik; " "try asymptotic expansion.")

                                                                   );
      _Tp __Inul = __fp_min;
      _Tp __Ipnul = __h * __Inul;
      _Tp __Inul1 = __Inul;
      _Tp __Ipnu1 = __Ipnul;
      _Tp __fact = __nu * __xi;
      for (int __l = __nl; __l >= 1; --__l)
        {
          const _Tp __Inutemp = __fact * __Inul + __Ipnul;
          __fact -= __xi;
          __Ipnul = __fact * __Inutemp + __Inul;
          __Inul = __Inutemp;
        }
      _Tp __f = __Ipnul / __Inul;
      _Tp __Kmu, __Knu1;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          const _Tp __fact = (std::abs(__pimu) < __eps
                            ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          const _Tp __fact2 = (std::abs(__e) < __eps
                            ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = __fact
                   * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          _Tp __sum = __ff;
          __e = std::exp(__e);
          _Tp __p = __e / (_Tp(2) * __gampl);
          _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
          _Tp __c = _Tp(1);
          __d = __x2 * __x2;
          _Tp __sum1 = __p;
          int __i;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / __i;
              __p /= __i - __mu;
              __q /= __i + __mu;
              const _Tp __del = __c * __ff;
              __sum += __del;
              const _Tp __del1 = __c * (__p - __i * __ff);
              __sum1 += __del1;
              if (std::abs(__del) < __eps * std::abs(__sum))
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Bessel k series failed to converge " "in __bessel_ik.")
                                                             );
          __Kmu = __sum;
          __Knu1 = __sum1 * __xi2;
        }
      else
        {
          _Tp __b = _Tp(2) * (_Tp(1) + __x);
          _Tp __d = _Tp(1) / __b;
          _Tp __delh = __d;
          _Tp __h = __delh;
          _Tp __q1 = _Tp(0);
          _Tp __q2 = _Tp(1);
          _Tp __a1 = _Tp(0.25L) - __mu2;
          _Tp __q = __c = __a1;
          _Tp __a = -__a1;
          _Tp __s = _Tp(1) + __q * __delh;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a -= 2 * (__i - 1);
              __c = -__a * __c / __i;
              const _Tp __qnew = (__q1 - __b * __q2) / __a;
              __q1 = __q2;
              __q2 = __qnew;
              __q += __c * __qnew;
              __b += _Tp(2);
              __d = _Tp(1) / (__b + __a * __d);
              __delh = (__b * __d - _Tp(1)) * __delh;
              __h += __delh;
              const _Tp __dels = __q * __delh;
              __s += __dels;
              if ( std::abs(__dels / __s) < __eps )
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Steed's method failed " "in __bessel_ik.")
                                                             );
          __h = __a1 * __h;
          __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x))
                * std::exp(-__x) / __s;
          __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
        }

      _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
      _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
      __Inu = __Inumu * __Inul1 / __Inul;
      __Ipnu = __Inumu * __Ipnu1 / __Inul;
      for ( __i = 1; __i <= __nl; ++__i )
        {
          const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
          __Kmu = __Knu1;
          __Knu1 = __Knutemp;
        }
      __Knu = __Kmu;
      __Kpnu = __nu * __xi * __Kmu - __Knu1;

      return;
    }
    template<typename _Tp>
    _Tp
    __cyl_bessel_i(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_i.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, +_Tp(1), 200);
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __I_nu;
        }
    }
    template<typename _Tp>
    _Tp
    __cyl_bessel_k(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_k.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __K_nu;
        }
    }
    template <typename _Tp>
    void
    __sph_bessel_ik(unsigned int __n, _Tp __x,
                    _Tp & __i_n, _Tp & __k_n, _Tp & __ip_n, _Tp & __kp_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
      __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __i_n = __factor * __I_nu;
      __k_n = __factor * __K_nu;
      __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
      __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);

      return;
    }
    template <typename _Tp>
    void
    __airy(_Tp __x, _Tp & __Ai, _Tp & __Bi, _Tp & __Aip, _Tp & __Bip)
    {
      const _Tp __absx = std::abs(__x);
      const _Tp __rootx = std::sqrt(__absx);
      const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);
      const _Tp _S_inf = std::numeric_limits<_Tp>::infinity();

      if (__isnan(__x))
        __Bip = __Aip = __Bi = __Ai = std::numeric_limits<_Tp>::quiet_NaN();
      else if (__z == _S_inf)
        {
   __Aip = __Ai = _Tp(0);
   __Bip = __Bi = _S_inf;
 }
      else if (__z == -_S_inf)
 __Bip = __Aip = __Bi = __Ai = _Tp(0);
      else if (__x > _Tp(0))
        {
          _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;

          __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Ai = __rootx * __K_nu
               / (__numeric_constants<_Tp>::__sqrt3()
                * __numeric_constants<_Tp>::__pi());
          __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi()
                 + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());

          __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Aip = -__x * __K_nu
                / (__numeric_constants<_Tp>::__sqrt3()
                 * __numeric_constants<_Tp>::__pi());
          __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi()
                      + _Tp(2) * __I_nu
                      / __numeric_constants<_Tp>::__sqrt3());
        }
      else if (__x < _Tp(0))
        {
          _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;

          __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Ai = __rootx * (__J_nu
                    - __N_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
          __Bi = -__rootx * (__N_nu
                    + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);

          __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3()
                          + __J_nu) / _Tp(2);
          __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3()
                          - __N_nu) / _Tp(2);
        }
      else
        {



          __Ai = _Tp(0.35502805388781723926L);
          __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();




          __Aip = -_Tp(0.25881940379280679840L);
          __Bip = -__Aip * __numeric_constants<_Tp>::__sqrt3();
        }

      return;
    }
  }





}
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {
    template<typename _Tp>
    _Tp
    __poly_hermite_recursion(unsigned int __n, _Tp __x)
    {

      _Tp __H_0 = 1;
      if (__n == 0)
        return __H_0;


      _Tp __H_1 = 2 * __x;
      if (__n == 1)
        return __H_1;


      _Tp __H_n, __H_nm1, __H_nm2;
      unsigned int __i;
      for (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i)
        {
          __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
          __H_nm2 = __H_nm1;
          __H_nm1 = __H_n;
        }

      return __H_n;
    }
    template<typename _Tp>
    inline _Tp
    __poly_hermite(unsigned int __n, _Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __poly_hermite_recursion(__n, __x);
    }
  }





}
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_large_n(unsigned __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __a = -_Tp(__n);
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
      const _Tp __cos2th = __x / __eta;
      const _Tp __sin2th = _Tp(1) - __cos2th;
      const _Tp __th = std::acos(std::sqrt(__cos2th));
      const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2()
                        * __numeric_constants<_Tp>::__pi_2()
                        * __eta * __eta * __cos2th * __sin2th;


      const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
      const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));





      _Tp __pre_term1 = _Tp(0.5L) * (_Tp(1) - __b)
                      * std::log(_Tp(0.25L) * __x * __eta);
      _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
      _Tp __lnpre = __lg_b - __lnfact + _Tp(0.5L) * __x
                      + __pre_term1 - __pre_term2;
      _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
      _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta
                              * (_Tp(2) * __th
                               - std::sin(_Tp(2) * __th))
                               + __numeric_constants<_Tp>::__pi_4());
      _Tp __ser = __ser_term1 + __ser_term2;

      return std::exp(__lnpre) * __ser;
    }
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __mx = -__x;
      const _Tp __tc_sgn = (__x < _Tp(0) ? _Tp(1)
                         : ((__n % 2 == 1) ? -_Tp(1) : _Tp(1)));

      _Tp __tc = _Tp(1);
      const _Tp __ax = std::abs(__x);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __tc *= (__ax / __k);

      _Tp __term = __tc * __tc_sgn;
      _Tp __sum = __term;
      for (int __k = int(__n) - 1; __k >= 0; --__k)
        {
          __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k))
                  * _Tp(__k + 1) / __mx;
          __sum += __term;
        }

      return __sum;
    }
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {

      _Tp __l_0 = _Tp(1);
      if (__n == 0)
        return __l_0;


      _Tp __l_1 = -__x + _Tp(1) + _Tp(__alpha1);
      if (__n == 1)
        return __l_1;


      _Tp __l_n2 = __l_0;
      _Tp __l_n1 = __l_1;
      _Tp __l_n = _Tp(0);
      for (unsigned int __nn = 2; __nn <= __n; ++__nn)
        {
            __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x)
                  * __l_n1 / _Tp(__nn)
                  - (_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
            __l_n2 = __l_n1;
            __l_n1 = __l_n;
        }

      return __l_n;
    }
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Negative argument " "in __poly_laguerre.")
                                                            );

      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n == 0)
        return _Tp(1);
      else if (__n == 1)
        return _Tp(1) + _Tp(__alpha1) - __x;
      else if (__x == _Tp(0))
        {
          _Tp __prod = _Tp(__alpha1) + _Tp(1);
          for (unsigned int __k = 2; __k <= __n; ++__k)
            __prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
          return __prod;
        }
      else if (__n > 10000000 && _Tp(__alpha1) > -_Tp(1)
            && __x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
        return __poly_laguerre_large_n(__n, __alpha1, __x);
      else if (_Tp(__alpha1) >= _Tp(0)
           || (__x > _Tp(0) && _Tp(__alpha1) < -_Tp(__n + 1)))
        return __poly_laguerre_recursion(__n, __alpha1, __x);
      else
        return __poly_laguerre_hyperg(__n, __alpha1, __x);
    }
    template<typename _Tp>
    inline _Tp
    __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x); }
    template<typename _Tp>
    inline _Tp
    __laguerre(unsigned int __n, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x); }
  }






}
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {
    template<typename _Tp>
    _Tp
    __riemann_zeta_sum(_Tp __s)
    {

      if (__s < _Tp(1))
        std::__throw_domain_error(("Bad argument in zeta sum."));

      const unsigned int max_iter = 10000;
      _Tp __zeta = _Tp(0);
      for (unsigned int __k = 1; __k < max_iter; ++__k)
        {
          _Tp __term = std::pow(static_cast<_Tp>(__k), -__s);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            {
              break;
            }
          __zeta += __term;
        }

      return __zeta;
    }
    template<typename _Tp>
    _Tp
    __riemann_zeta_alt(_Tp __s)
    {
      _Tp __sgn = _Tp(1);
      _Tp __zeta = _Tp(0);
      for (unsigned int __i = 1; __i < 10000000; ++__i)
        {
          _Tp __term = __sgn / std::pow(__i, __s);
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __zeta += __term;
          __sgn *= _Tp(-1);
        }
      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
    template<typename _Tp>
    _Tp
    __riemann_zeta_glob(_Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);



      if (__s < _Tp(0))
        {

          if (::std::fmod(__s,_Tp(2)) == _Tp(0))
            return _Tp(0);
          else

            {
              _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
              __zeta *= std::pow(_Tp(2)
                     * __numeric_constants<_Tp>::__pi(), __s)
                     * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                     * std::exp(::std::lgamma(_Tp(1) - __s))



                     / __numeric_constants<_Tp>::__pi();
              return __zeta;
            }
        }

      _Tp __num = _Tp(0.5L);
      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term *= __num;
          __zeta += __term;
          if (std::abs(__term/__zeta) < __eps)
            break;
          __num *= _Tp(0.5L);
        }

      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
    template<typename _Tp>
    _Tp
    __riemann_zeta_product(_Tp __s)
    {
      static const _Tp __prime[] = {
        _Tp(2), _Tp(3), _Tp(5), _Tp(7), _Tp(11), _Tp(13), _Tp(17), _Tp(19),
        _Tp(23), _Tp(29), _Tp(31), _Tp(37), _Tp(41), _Tp(43), _Tp(47),
        _Tp(53), _Tp(59), _Tp(61), _Tp(67), _Tp(71), _Tp(73), _Tp(79),
        _Tp(83), _Tp(89), _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)
      };
      static const unsigned int __num_primes = sizeof(__prime) / sizeof(_Tp);

      _Tp __zeta = _Tp(1);
      for (unsigned int __i = 0; __i < __num_primes; ++__i)
        {
          const _Tp __fact = _Tp(1) - std::pow(__prime[__i], -__s);
          __zeta *= __fact;
          if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      __zeta = _Tp(1) / __zeta;

      return __zeta;
    }
    template<typename _Tp>
    _Tp
    __riemann_zeta(_Tp __s)
    {
      if (__isnan(__s))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__s == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (__s < -_Tp(19))
        {
          _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
          __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s)
                 * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                 * std::exp(::std::lgamma(_Tp(1) - __s))



                 / __numeric_constants<_Tp>::__pi();
          return __zeta;
        }
      else if (__s < _Tp(20))
        {

          bool __glob = true;
          if (__glob)
            return __riemann_zeta_glob(__s);
          else
            {
              if (__s > _Tp(1))
                return __riemann_zeta_sum(__s);
              else
                {
                  _Tp __zeta = std::pow(_Tp(2)
                                * __numeric_constants<_Tp>::__pi(), __s)
                         * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                             * ::std::tgamma(_Tp(1) - __s)



                             * __riemann_zeta_sum(_Tp(1) - __s);
                  return __zeta;
                }
            }
        }
      else
        return __riemann_zeta_product(__s);
    }
    template<typename _Tp>
    _Tp
    __hurwitz_zeta_glob(_Tp __a, _Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);

      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term /= _Tp(__i + 1);
          if (std::abs(__term / __zeta) < __eps)
            break;
          __zeta += __term;
        }

      __zeta /= __s - _Tp(1);

      return __zeta;
    }
    template<typename _Tp>
    inline _Tp
    __hurwitz_zeta(_Tp __a, _Tp __s)
    { return __hurwitz_zeta_glob(__a, __s); }
  }






}

namespace std __attribute__ ((__visibility__ ("default")))
{

  inline float
  assoc_laguerref(unsigned int __n, unsigned int __m, float __x)
  { return __detail::__assoc_laguerre<float>(__n, __m, __x); }







  inline long double
  assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)
  { return __detail::__assoc_laguerre<long double>(__n, __m, __x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_laguerre<__type>(__n, __m, __x);
    }
  inline float
  assoc_legendref(unsigned int __l, unsigned int __m, float __x)
  { return __detail::__assoc_legendre_p<float>(__l, __m, __x); }






  inline long double
  assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)
  { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
    }
  inline float
  betaf(float __a, float __b)
  { return __detail::__beta<float>(__a, __b); }







  inline long double
  betal(long double __a, long double __b)
  { return __detail::__beta<long double>(__a, __b); }
  template<typename _Tpa, typename _Tpb>
    inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type
    beta(_Tpa __a, _Tpb __b)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
      return __detail::__beta<__type>(__a, __b);
    }
  inline float
  comp_ellint_1f(float __k)
  { return __detail::__comp_ellint_1<float>(__k); }







  inline long double
  comp_ellint_1l(long double __k)
  { return __detail::__comp_ellint_1<long double>(__k); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_1(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_1<__type>(__k);
    }
  inline float
  comp_ellint_2f(float __k)
  { return __detail::__comp_ellint_2<float>(__k); }







  inline long double
  comp_ellint_2l(long double __k)
  { return __detail::__comp_ellint_2<long double>(__k); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_2(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_2<__type>(__k);
    }
  inline float
  comp_ellint_3f(float __k, float __nu)
  { return __detail::__comp_ellint_3<float>(__k, __nu); }







  inline long double
  comp_ellint_3l(long double __k, long double __nu)
  { return __detail::__comp_ellint_3<long double>(__k, __nu); }
  template<typename _Tp, typename _Tpn>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type
    comp_ellint_3(_Tp __k, _Tpn __nu)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
      return __detail::__comp_ellint_3<__type>(__k, __nu);
    }
  inline float
  cyl_bessel_if(float __nu, float __x)
  { return __detail::__cyl_bessel_i<float>(__nu, __x); }







  inline long double
  cyl_bessel_il(long double __nu, long double __x)
  { return __detail::__cyl_bessel_i<long double>(__nu, __x); }
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_i(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_i<__type>(__nu, __x);
    }
  inline float
  cyl_bessel_jf(float __nu, float __x)
  { return __detail::__cyl_bessel_j<float>(__nu, __x); }







  inline long double
  cyl_bessel_jl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_j<long double>(__nu, __x); }
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_j(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_j<__type>(__nu, __x);
    }
  inline float
  cyl_bessel_kf(float __nu, float __x)
  { return __detail::__cyl_bessel_k<float>(__nu, __x); }







  inline long double
  cyl_bessel_kl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_k<long double>(__nu, __x); }
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_k(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_k<__type>(__nu, __x);
    }
  inline float
  cyl_neumannf(float __nu, float __x)
  { return __detail::__cyl_neumann_n<float>(__nu, __x); }







  inline long double
  cyl_neumannl(long double __nu, long double __x)
  { return __detail::__cyl_neumann_n<long double>(__nu, __x); }
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_neumann(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_neumann_n<__type>(__nu, __x);
    }
  inline float
  ellint_1f(float __k, float __phi)
  { return __detail::__ellint_1<float>(__k, __phi); }







  inline long double
  ellint_1l(long double __k, long double __phi)
  { return __detail::__ellint_1<long double>(__k, __phi); }
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_1(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_1<__type>(__k, __phi);
    }
  inline float
  ellint_2f(float __k, float __phi)
  { return __detail::__ellint_2<float>(__k, __phi); }







  inline long double
  ellint_2l(long double __k, long double __phi)
  { return __detail::__ellint_2<long double>(__k, __phi); }
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_2(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_2<__type>(__k, __phi);
    }
  inline float
  ellint_3f(float __k, float __nu, float __phi)
  { return __detail::__ellint_3<float>(__k, __nu, __phi); }







  inline long double
  ellint_3l(long double __k, long double __nu, long double __phi)
  { return __detail::__ellint_3<long double>(__k, __nu, __phi); }
  template<typename _Tp, typename _Tpn, typename _Tpp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type
    ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
      return __detail::__ellint_3<__type>(__k, __nu, __phi);
    }
  inline float
  expintf(float __x)
  { return __detail::__expint<float>(__x); }







  inline long double
  expintl(long double __x)
  { return __detail::__expint<long double>(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__expint<__type>(__x);
    }
  inline float
  hermitef(unsigned int __n, float __x)
  { return __detail::__poly_hermite<float>(__n, __x); }







  inline long double
  hermitel(unsigned int __n, long double __x)
  { return __detail::__poly_hermite<long double>(__n, __x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    hermite(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_hermite<__type>(__n, __x);
    }
  inline float
  laguerref(unsigned int __n, float __x)
  { return __detail::__laguerre<float>(__n, __x); }







  inline long double
  laguerrel(unsigned int __n, long double __x)
  { return __detail::__laguerre<long double>(__n, __x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    laguerre(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__laguerre<__type>(__n, __x);
    }
  inline float
  legendref(unsigned int __l, float __x)
  { return __detail::__poly_legendre_p<float>(__l, __x); }







  inline long double
  legendrel(unsigned int __l, long double __x)
  { return __detail::__poly_legendre_p<long double>(__l, __x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    legendre(unsigned int __l, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_legendre_p<__type>(__l, __x);
    }
  inline float
  riemann_zetaf(float __s)
  { return __detail::__riemann_zeta<float>(__s); }







  inline long double
  riemann_zetal(long double __s)
  { return __detail::__riemann_zeta<long double>(__s); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    riemann_zeta(_Tp __s)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__riemann_zeta<__type>(__s);
    }
  inline float
  sph_besself(unsigned int __n, float __x)
  { return __detail::__sph_bessel<float>(__n, __x); }







  inline long double
  sph_bessell(unsigned int __n, long double __x)
  { return __detail::__sph_bessel<long double>(__n, __x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_bessel(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_bessel<__type>(__n, __x);
    }
  inline float
  sph_legendref(unsigned int __l, unsigned int __m, float __theta)
  { return __detail::__sph_legendre<float>(__l, __m, __theta); }
  inline long double
  sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)
  { return __detail::__sph_legendre<long double>(__l, __m, __theta); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_legendre<__type>(__l, __m, __theta);
    }
  inline float
  sph_neumannf(unsigned int __n, float __x)
  { return __detail::__sph_neumann<float>(__n, __x); }







  inline long double
  sph_neumannl(unsigned int __n, long double __x)
  { return __detail::__sph_neumann<long double>(__n, __x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_neumann(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_neumann<__type>(__n, __x);
    }




}


namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

  inline float
  airy_aif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  inline long double
  airy_ail(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_ai(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Ai;
    }




  inline float
  airy_bif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  inline long double
  airy_bil(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_bi(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Bi;
    }
  inline float
  conf_hypergf(float __a, float __c, float __x)
  { return std::__detail::__conf_hyperg<float>(__a, __c, __x); }
  inline long double
  conf_hypergl(long double __a, long double __c, long double __x)
  { return std::__detail::__conf_hyperg<long double>(__a, __c, __x); }
  template<typename _Tpa, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type
    conf_hyperg(_Tpa __a, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type __type;
      return std::__detail::__conf_hyperg<__type>(__a, __c, __x);
    }
  inline float
  hypergf(float __a, float __b, float __c, float __x)
  { return std::__detail::__hyperg<float>(__a, __b, __c, __x); }
  inline long double
  hypergl(long double __a, long double __b, long double __c, long double __x)
  { return std::__detail::__hyperg<long double>(__a, __b, __c, __x); }
  template<typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type
    hyperg(_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>
  ::__type __type;
      return std::__detail::__hyperg<__type>(__a, __b, __c, __x);
    }



}


}

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;

class BRect;


class BPoint {
public:
   float x;
   float y;

        BPoint();
        BPoint(float x, float y);
        BPoint(const BPoint& p);

   BPoint& operator=(const BPoint& other);
   void Set(float x, float y);

   void ConstrainTo(BRect rect);
   void PrintToStream() const;

   BPoint operator-() const;
   BPoint operator+(const BPoint& other) const;
   BPoint operator-(const BPoint& other) const;
   BPoint& operator+=(const BPoint& other);
   BPoint& operator-=(const BPoint& other);

   bool operator!=(const BPoint& other) const;
   bool operator==(const BPoint& other) const;
};


extern const BPoint B_ORIGIN;



inline
BPoint::BPoint()
 :
 x(0.0f),
 y(0.0f)
{
}


inline
BPoint::BPoint(float x, float y)
 :
 x(x),
 y(y)
{
}


inline
BPoint::BPoint(const BPoint& other)
 :
 x(other.x),
 y(other.y)
{
}


inline BPoint&
BPoint::operator=(const BPoint& other)
{
 x = other.x;
 y = other.y;
 return *this;
}


inline void
BPoint::Set(float x, float y)
{
 this->x = x;
 this->y = y;
}











const float B_SIZE_UNSET = -2;
const float B_SIZE_UNLIMITED = 1024 * 1024 * 1024;


class BSize {
public:
   float width;
   float height;

 inline BSize();
 inline BSize(const BSize& other);
 inline BSize(float width, float height);

 inline float Width() const;
 inline float Height() const;

 inline void Set(float width, float height);
 inline void SetWidth(float width);
 inline void SetHeight(float height);

 inline int32 IntegerWidth() const;
 inline int32 IntegerHeight() const;

 inline bool IsWidthSet() const;
 inline bool IsHeightSet() const;

 inline bool operator==(const BSize& other) const;
 inline bool operator!=(const BSize& other) const;

 inline BSize& operator=(const BSize& other);
};


inline
BSize::BSize()
 : width(B_SIZE_UNSET),
   height(B_SIZE_UNSET)
{
}


inline
BSize::BSize(const BSize& other)
 : width(other.width),
   height(other.height)
{
}


inline
BSize::BSize(float width, float height)
 : width(width),
   height(height)
{
}


inline float
BSize::Width() const
{
 return width;
}


inline float
BSize::Height() const
{
 return height;
}


inline void
BSize::Set(float width, float height)
{
 this->width = width;
 this->height = height;
}


inline void
BSize::SetWidth(float width)
{
 this->width = width;
}


inline void
BSize::SetHeight(float height)
{
 this->height = height;
}


inline int32
BSize::IntegerWidth() const
{
 return (int32)width;
}


inline int32
BSize::IntegerHeight() const
{
 return (int32)height;
}


inline bool
BSize::IsWidthSet() const
{
 return width != B_SIZE_UNSET;
}


inline bool
BSize::IsHeightSet() const
{
 return height != B_SIZE_UNSET;
}


inline bool
BSize::operator==(const BSize& other) const
{
 return (width == other.width && height == other.height);
}


inline bool
BSize::operator!=(const BSize& other) const
{
 return !(*this == other);
}


inline BSize&
BSize::operator=(const BSize& other)
{
 width = other.width;
 height = other.height;
 return *this;
}


class BRect {
public:
   float left;
   float top;
   float right;
   float bottom;

        BRect();
        BRect(const BRect& other);
        BRect(float left, float top, float right,
         float bottom);
        BRect(BPoint leftTop, BPoint rightBottom);
        BRect(BPoint leftTop, BSize size);
        BRect(float side);

   BRect& operator=(const BRect& other);
   void Set(float left, float top, float right,
         float bottom);

   void PrintToStream() const;

   BPoint LeftTop() const;
   BPoint RightBottom() const;
   BPoint LeftBottom() const;
   BPoint RightTop() const;

   void SetLeftTop(const BPoint point);
   void SetRightBottom(const BPoint point);
   void SetLeftBottom(const BPoint point);
   void SetRightTop(const BPoint point);


   void InsetBy(BPoint inset);
   void InsetBy(float dx, float dy);
   void OffsetBy(BPoint delta);
   void OffsetBy(float dx, float dy);
   void OffsetTo(BPoint offset);
   void OffsetTo(float x, float y);


   BRect& InsetBySelf(BPoint inset);
   BRect& InsetBySelf(float dx, float dy);
   BRect InsetByCopy(BPoint inset) const;
   BRect InsetByCopy(float dx, float dy) const;
   BRect& OffsetBySelf(BPoint offset);
   BRect& OffsetBySelf(float dx, float dy);
   BRect OffsetByCopy(BPoint offset) const;
   BRect OffsetByCopy(float dx, float dy) const;
   BRect& OffsetToSelf(BPoint offset);
   BRect& OffsetToSelf(float x, float y);
   BRect OffsetToCopy(BPoint offset) const;
   BRect OffsetToCopy(float x, float y) const;


   bool operator==(BRect other) const;
   bool operator!=(BRect other) const;


   BRect operator&(BRect other) const;
   BRect operator|(BRect other) const;

   bool IsValid() const;
   float Width() const;
   int32 IntegerWidth() const;
   float Height() const;
   int32 IntegerHeight() const;
   BSize Size() const;

   bool Intersects(BRect rect) const;
   bool Contains(BPoint point) const;
   bool Contains(BRect rect) const;
};




inline BPoint
BRect::LeftTop() const
{
 return *(const BPoint*)&left;
}


inline BPoint
BRect::RightBottom() const
{
 return *(const BPoint*)&right;
}


inline BPoint
BRect::LeftBottom() const
{
 return BPoint(left, bottom);
}


inline BPoint
BRect::RightTop() const
{
 return BPoint(right, top);
}


inline
BRect::BRect()
 :
 left(0),
 top(0),
 right(-1),
 bottom(-1)
{
}


inline
BRect::BRect(float left, float top, float right, float bottom)
 :
 left(left),
 top(top),
 right(right),
 bottom(bottom)
{
}


inline
BRect::BRect(const BRect& other)
 :
 left(other.left),
 top(other.top),
 right(other.right),
 bottom(other.bottom)
{
}


inline
BRect::BRect(BPoint leftTop, BPoint rightBottom)
 :
 left(leftTop.x),
 top(leftTop.y),
 right(rightBottom.x),
 bottom(rightBottom.y)
{
}


inline
BRect::BRect(BPoint leftTop, BSize size)
 :
 left(leftTop.x),
 top(leftTop.y),
 right(leftTop.x + size.width),
 bottom(leftTop.y + size.height)
{
}


inline
BRect::BRect(float side)
 :
 left(0),
 top(0),
 right(side - 1),
 bottom(side - 1)
{
}


inline BRect&
BRect::operator=(const BRect& other)
{
 left = other.left;
 top = other.top;
 right = other.right;
 bottom = other.bottom;
 return *this;
}


inline void
BRect::Set(float left, float top, float right, float bottom)
{
 this->left = left;
 this->top = top;
 this->right = right;
 this->bottom = bottom;
}


inline bool
BRect::IsValid() const
{
 return left <= right && top <= bottom;
}


inline int32
BRect::IntegerWidth() const
{
 return (int32)ceil(right - left);
}


inline float
BRect::Width() const
{
 return right - left;
}


inline int32
BRect::IntegerHeight() const
{
 return (int32)ceil(bottom - top);
}


inline float
BRect::Height() const
{
 return bottom - top;
}


inline BSize
BRect::Size() const
{
 return BSize(right - left, bottom - top);
}



enum {
 B_AFFINE_TRANSFORM_TYPE = 'AMTX',
 B_ALIGNMENT_TYPE = 'ALGN',
 B_ANY_TYPE = 'ANYT',
 B_ATOM_TYPE = 'ATOM',
 B_ATOMREF_TYPE = 'ATMR',
 B_BOOL_TYPE = 'BOOL',
 B_CHAR_TYPE = 'CHAR',
 B_COLOR_8_BIT_TYPE = 'CLRB',
 B_DOUBLE_TYPE = 'DBLE',
 B_FLOAT_TYPE = 'FLOT',
 B_GRAYSCALE_8_BIT_TYPE = 'GRYB',
 B_INT16_TYPE = 'SHRT',
 B_INT32_TYPE = 'LONG',
 B_INT64_TYPE = 'LLNG',
 B_INT8_TYPE = 'BYTE',
 B_LARGE_ICON_TYPE = 'ICON',
 B_MEDIA_PARAMETER_GROUP_TYPE = 'BMCG',
 B_MEDIA_PARAMETER_TYPE = 'BMCT',
 B_MEDIA_PARAMETER_WEB_TYPE = 'BMCW',
 B_MESSAGE_TYPE = 'MSGG',
 B_MESSENGER_TYPE = 'MSNG',
 B_MIME_TYPE = 'MIME',
 B_MINI_ICON_TYPE = 'MICN',
 B_MONOCHROME_1_BIT_TYPE = 'MNOB',
 B_OBJECT_TYPE = 'OPTR',
 B_OFF_T_TYPE = 'OFFT',
 B_PATTERN_TYPE = 'PATN',
 B_POINTER_TYPE = 'PNTR',
 B_POINT_TYPE = 'BPNT',
 B_PROPERTY_INFO_TYPE = 'SCTD',
 B_RAW_TYPE = 'RAWT',
 B_RECT_TYPE = 'RECT',
 B_REF_TYPE = 'RREF',
 B_NODE_REF_TYPE = 'NREF',
 B_RGB_32_BIT_TYPE = 'RGBB',
 B_RGB_COLOR_TYPE = 'RGBC',
 B_SIZE_TYPE = 'SIZE',
 B_SIZE_T_TYPE = 'SIZT',
 B_SSIZE_T_TYPE = 'SSZT',
 B_STRING_TYPE = 'CSTR',
 B_STRING_LIST_TYPE = 'STRL',
 B_TIME_TYPE = 'TIME',
 B_UINT16_TYPE = 'USHT',
 B_UINT32_TYPE = 'ULNG',
 B_UINT64_TYPE = 'ULLG',
 B_UINT8_TYPE = 'UBYT',
 B_VECTOR_ICON_TYPE = 'VICN',
 B_XATTR_TYPE = 'XATR',
 B_NETWORK_ADDRESS_TYPE = 'NWAD',
 B_MIME_STRING_TYPE = 'MIMS',


 B_ASCII_TYPE = 'TEXT'

};



extern const char* B_URL_HTTP;

extern const char* B_URL_HTTPS;

extern const char* B_URL_FTP;

extern const char* B_URL_GOPHER;

extern const char* B_URL_MAILTO;

extern const char* B_URL_NEWS;

extern const char* B_URL_NNTP;

extern const char* B_URL_TELNET;

extern const char* B_URL_RLOGIN;

extern const char* B_URL_TN3270;

extern const char* B_URL_WAIS;

extern const char* B_URL_FILE;


class BAlignment;
class BBlockCache;
class BMessenger;
class BHandler;
class BString;
class BStringList;
struct entry_ref;
struct rgb_color;






enum {
 B_NO_SPECIFIER = 0,
 B_DIRECT_SPECIFIER = 1,
 B_INDEX_SPECIFIER,
 B_REVERSE_INDEX_SPECIFIER,
 B_RANGE_SPECIFIER,
 B_REVERSE_RANGE_SPECIFIER,
 B_NAME_SPECIFIER,
 B_ID_SPECIFIER,

 B_SPECIFIERS_END = 128

};


class BMessage {
public:
   uint32 what;

        BMessage();
        BMessage(uint32 what);
        BMessage(const BMessage& other);
 virtual ~BMessage();

   BMessage& operator=(const BMessage& other);


   status_t GetInfo(type_code typeRequested, int32 index,
         char** nameFound, type_code* typeFound,
         int32* countFound = __null) const;
   status_t GetInfo(const char* name, type_code* typeFound,
         int32* countFound = __null) const;
   status_t GetInfo(const char* name, type_code* typeFound,
         bool* fixedSize) const;
   status_t GetInfo(const char* name, type_code* typeFound,
         int32* countFound, bool* fixedSize) const;

   int32 CountNames(type_code type) const;
   bool IsEmpty() const;
   bool IsSystem() const;
   bool IsReply() const;
   void PrintToStream() const;

   status_t Rename(const char* oldEntry,
         const char* newEntry);


   bool WasDelivered() const;
   bool IsSourceWaiting() const;
   bool IsSourceRemote() const;
   BMessenger ReturnAddress() const;
   const BMessage* Previous() const;
   bool WasDropped() const;
   BPoint DropPoint(BPoint* offset = __null) const;


   status_t SendReply(uint32 command,
         BHandler* replyTo = __null);
   status_t SendReply(BMessage* reply,
         BHandler* replyTo = __null,
         bigtime_t timeout = (9223372036854775807LL));
   status_t SendReply(BMessage* reply, BMessenger replyTo,
         bigtime_t timeout = (9223372036854775807LL));

   status_t SendReply(uint32 command,
         BMessage* replyToReply);
   status_t SendReply(BMessage* reply,
         BMessage* replyToReply,
         bigtime_t sendTimeout = (9223372036854775807LL),
         bigtime_t replyTimeout
          = (9223372036854775807LL));


   ssize_t FlattenedSize() const;
   status_t Flatten(char* buffer, ssize_t size) const;
   status_t Flatten(BDataIO* stream,
         ssize_t* size = __null) const;
   status_t Unflatten(const char* flatBuffer);
   status_t Unflatten(BDataIO* stream);


   status_t AddSpecifier(const char* property);
   status_t AddSpecifier(const char* property, int32 index);
   status_t AddSpecifier(const char* property, int32 index,
         int32 range);
   status_t AddSpecifier(const char* property,
         const char* name);
   status_t AddSpecifier(const BMessage* specifier);

   status_t SetCurrentSpecifier(int32 index);
   status_t GetCurrentSpecifier(int32* index,
         BMessage* specifier = __null,
         int32* what = __null,
         const char** property = __null) const;
   bool HasSpecifiers() const;
   status_t PopSpecifier();


   status_t AddAlignment(const char* name,
         const BAlignment& alignment);
   status_t AddRect(const char* name, BRect rect);
   status_t AddPoint(const char* name, BPoint point);
   status_t AddSize(const char* name, BSize size);
   status_t AddString(const char* name, const char* string);
   status_t AddString(const char* name,
         const BString& string);
   status_t AddStrings(const char* name,
         const BStringList& list);
   status_t AddInt8(const char* name, int8 value);
   status_t AddUInt8(const char* name, uint8 value);
   status_t AddInt16(const char* name, int16 value);
   status_t AddUInt16(const char* name, uint16 value);
   status_t AddInt32(const char* name, int32 value);
   status_t AddUInt32(const char* name, uint32 value);
   status_t AddInt64(const char* name, int64 value);
   status_t AddUInt64(const char* name, uint64 value);
   status_t AddBool(const char* name, bool value);
   status_t AddFloat(const char* name, float value);
   status_t AddDouble(const char* name, double value);
   status_t AddColor(const char* name, rgb_color value);
   status_t AddPointer(const char* name,
         const void* pointer);
   status_t AddMessenger(const char* name,
         BMessenger messenger);
   status_t AddRef(const char* name, const entry_ref* ref);
   status_t AddNodeRef(const char* name,
         const node_ref* ref);
   status_t AddMessage(const char* name,
         const BMessage* message);
   status_t AddFlat(const char* name, BFlattenable* object,
         int32 count = 1);
   status_t AddFlat(const char* name,
         const BFlattenable* object, int32 count = 1);
   status_t AddData(const char* name, type_code type,
         const void* data, ssize_t numBytes,
         bool isFixedSize = true, int32 count = 1);

   status_t Append(const BMessage& message);


   status_t RemoveData(const char* name, int32 index = 0);
   status_t RemoveName(const char* name);
   status_t MakeEmpty();


   status_t FindAlignment(const char* name,
         BAlignment* alignment) const;
   status_t FindAlignment(const char* name, int32 index,
         BAlignment* alignment) const;

   status_t FindRect(const char* name, BRect* rect) const;
   status_t FindRect(const char* name, int32 index,
         BRect* rect) const;
   status_t FindPoint(const char* name,
         BPoint* point) const;
   status_t FindPoint(const char* name, int32 index,
         BPoint* point) const;

   status_t FindSize(const char* name, BSize* size) const;
   status_t FindSize(const char* name, int32 index,
         BSize* size) const;

   status_t FindString(const char* name,
         const char** string) const;
   status_t FindString(const char* name, int32 index,
         const char** string) const;
   status_t FindString(const char* name,
         BString* string) const;
   status_t FindString(const char* name, int32 index,
         BString* string) const;
   status_t FindStrings(const char* name,
         BStringList* list) const;
   status_t FindInt8(const char* name, int8* value) const;
   status_t FindInt8(const char* name, int32 index,
         int8* value) const;
   status_t FindUInt8(const char* name, uint8* value) const;
   status_t FindUInt8(const char* name, int32 index,
         uint8* value) const;
   status_t FindInt16(const char* name, int16* value) const;
   status_t FindInt16(const char* name, int32 index,
         int16* value) const;
   status_t FindUInt16(const char* name,
         uint16* value) const;
   status_t FindUInt16(const char* name, int32 index,
         uint16* value) const;
   status_t FindInt32(const char* name, int32* value) const;
   status_t FindInt32(const char* name, int32 index,
         int32* value) const;
   status_t FindUInt32(const char* name,
         uint32* value) const;
   status_t FindUInt32(const char* name, int32 index,
         uint32* value) const;
   status_t FindInt64(const char* name, int64* value) const;
   status_t FindInt64(const char* name, int32 index,
         int64* value) const;
   status_t FindUInt64(const char* name,
         uint64* value) const;
   status_t FindUInt64(const char* name, int32 index,
         uint64* value) const;
   status_t FindBool(const char* name, bool* value) const;
   status_t FindBool(const char* name, int32 index,
         bool* value) const;
   status_t FindFloat(const char* name, float* value) const;
   status_t FindFloat(const char* name, int32 index,
         float* value) const;
   status_t FindDouble(const char* name,
         double* value) const;
   status_t FindDouble(const char* name, int32 index,
         double* value) const;
   status_t FindColor(const char* name,
         rgb_color* value) const;
   status_t FindColor(const char* name, int32 index,
         rgb_color* value) const;
   status_t FindPointer(const char* name,
         void** pointer) const;
   status_t FindPointer(const char* name, int32 index,
         void** pointer) const;
   status_t FindMessenger(const char* name,
         BMessenger* messenger) const;
   status_t FindMessenger(const char* name, int32 index,
         BMessenger* messenger) const;
   status_t FindRef(const char* name, entry_ref* ref) const;
   status_t FindRef(const char* name, int32 index,
         entry_ref* ref) const;
   status_t FindNodeRef(const char* name,
         node_ref* ref) const;
   status_t FindNodeRef(const char* name, int32 index,
         node_ref* ref) const;
   status_t FindMessage(const char* name,
         BMessage* message) const;
   status_t FindMessage(const char* name, int32 index,
         BMessage* message) const;
   status_t FindFlat(const char* name,
         BFlattenable* object) const;
   status_t FindFlat(const char* name, int32 index,
         BFlattenable* object) const;
   status_t FindData(const char* name, type_code type,
         const void** data, ssize_t* numBytes) const;
   status_t FindData(const char* name, type_code type,
         int32 index, const void** data,
         ssize_t* numBytes) const;


   status_t ReplaceAlignment(const char* name,
         const BAlignment& alignment);
   status_t ReplaceAlignment(const char* name, int32 index,
         const BAlignment& alignment);

   status_t ReplaceRect(const char* name, BRect rect);
   status_t ReplaceRect(const char* name, int32 index,
         BRect rect);

   status_t ReplacePoint(const char* name, BPoint aPoint);
   status_t ReplacePoint(const char* name, int32 index,
         BPoint aPoint);
   status_t ReplaceSize(const char* name, BSize aSize);
   status_t ReplaceSize(const char* name, int32 index,
         BSize aSize);

   status_t ReplaceString(const char* name,
         const char* string);
   status_t ReplaceString(const char* name, int32 index,
         const char* string);
   status_t ReplaceString(const char* name,
         const BString& string);
   status_t ReplaceString(const char* name, int32 index,
         const BString& string);
   status_t ReplaceInt8(const char* name, int8 value);
   status_t ReplaceInt8(const char* name, int32 index,
         int8 value);
   status_t ReplaceUInt8(const char* name, uint8 value);
   status_t ReplaceUInt8(const char* name, int32 index,
         uint8 value);
   status_t ReplaceInt16(const char* name, int16 value);
   status_t ReplaceInt16(const char* name, int32 index,
         int16 value);
   status_t ReplaceUInt16(const char* name, uint16 value);
   status_t ReplaceUInt16(const char* name, int32 index,
         uint16 value);
   status_t ReplaceInt32(const char* name, int32 value);
   status_t ReplaceInt32(const char* name, int32 index,
         int32 value);
   status_t ReplaceUInt32(const char* name, uint32 value);
   status_t ReplaceUInt32(const char* name, int32 index,
         uint32 value);
   status_t ReplaceInt64(const char* name, int64 value);
   status_t ReplaceInt64(const char* name, int32 index,
         int64 value);
   status_t ReplaceUInt64(const char* name, uint64 value);
   status_t ReplaceUInt64(const char* name, int32 index,
         uint64 value);
   status_t ReplaceBool(const char* name, bool aBoolean);
   status_t ReplaceBool(const char* name, int32 index,
         bool value);
   status_t ReplaceFloat(const char* name, float value);
   status_t ReplaceFloat(const char* name, int32 index,
         float value);
   status_t ReplaceDouble(const char* name, double value);
   status_t ReplaceDouble(const char* name, int32 index,
         double value);
   status_t ReplaceColor(const char* name,
         rgb_color value);
   status_t ReplaceColor(const char* name, int32 index,
         rgb_color value);
   status_t ReplacePointer(const char* name,
         const void* pointer);
   status_t ReplacePointer(const char* name, int32 index,
         const void* pointer);
   status_t ReplaceMessenger(const char* name,
         BMessenger messenger);
   status_t ReplaceMessenger(const char* name, int32 index,
         BMessenger messenger);
   status_t ReplaceRef(const char* name,
         const entry_ref* ref);
   status_t ReplaceRef(const char* name, int32 index,
         const entry_ref* ref);
   status_t ReplaceNodeRef(const char* name,
         const node_ref* ref);
   status_t ReplaceNodeRef(const char* name, int32 index,
         const node_ref* ref);
   status_t ReplaceMessage(const char* name,
         const BMessage* message);
   status_t ReplaceMessage(const char* name, int32 index,
         const BMessage* message);
   status_t ReplaceFlat(const char* name,
         BFlattenable* object);
   status_t ReplaceFlat(const char* name, int32 index,
         BFlattenable* object);
   status_t ReplaceData(const char* name, type_code type,
         const void* data, ssize_t numBytes);
   status_t ReplaceData(const char* name, type_code type,
         int32 index, const void* data,
         ssize_t numBytes);


   bool HasSameData(const BMessage& other,
         bool ignoreFieldOrder = true,
         bool deep = false) const;

   void* operator new(size_t size);
   void* operator new(size_t, void* pointer);
   void* operator new(size_t,
         const std::nothrow_t& noThrow);
   void operator delete(void* pointer, size_t size);


   bool HasAlignment(const char* name,
         int32 n = 0) const;
   bool HasRect(const char* name, int32 n = 0) const;
   bool HasPoint(const char* name, int32 n = 0) const;
   bool HasSize(const char* name, int32 n = 0) const;
   bool HasString(const char* name, int32 n = 0) const;
   bool HasInt8(const char* name, int32 n = 0) const;
   bool HasUInt8(const char* name, int32 n = 0) const;
   bool HasInt16(const char* name, int32 n = 0) const;
   bool HasUInt16(const char* name, int32 n = 0) const;
   bool HasInt32(const char* name, int32 n = 0) const;
   bool HasUInt32(const char* name, int32 n = 0) const;
   bool HasInt64(const char* name, int32 n = 0) const;
   bool HasUInt64(const char* name, int32 n = 0) const;
   bool HasBool(const char* name, int32 n = 0) const;
   bool HasFloat(const char* name, int32 n = 0) const;
   bool HasDouble(const char* name, int32 n = 0) const;
   bool HasColor(const char* name, int32 n = 0) const;
   bool HasPointer(const char* name, int32 n = 0) const;
   bool HasMessenger(const char* name,
         int32 n = 0) const;
   bool HasRef(const char* name, int32 n = 0) const;
   bool HasNodeRef(const char* name, int32 n = 0) const;
   bool HasMessage(const char* name, int32 n = 0) const;
   bool HasFlat(const char* name,
         const BFlattenable* object) const;
   bool HasFlat(const char* name, int32 n,
         const BFlattenable* object) const;
   bool HasData(const char* name, type_code ,
         int32 n = 0) const;
   BRect FindRect(const char* name, int32 n = 0) const;
   BPoint FindPoint(const char* name, int32 n = 0) const;
   const char* FindString(const char* name, int32 n = 0) const;
   int8 FindInt8(const char* name, int32 n = 0) const;
   int16 FindInt16(const char* name, int32 n = 0) const;
   int32 FindInt32(const char* name, int32 n = 0) const;
   int64 FindInt64(const char* name, int32 n = 0) const;
   bool FindBool(const char* name, int32 n = 0) const;
   float FindFloat(const char* name, int32 n = 0) const;
   double FindDouble(const char* name, int32 n = 0) const;


   bool GetBool(const char* name,
         bool defaultValue = false) const;
   bool GetBool(const char* name, int32 index,
         bool defaultValue) const;
   int8 GetInt8(const char* name,
         int8 defaultValue) const;
   int8 GetInt8(const char* name, int32 index,
         int8 defaultValue) const;
   uint8 GetUInt8(const char* name,
         uint8 defaultValue) const;
   uint8 GetUInt8(const char* name, int32 index,
         uint8 defaultValue) const;
   int16 GetInt16(const char* name,
         int16 defaultValue) const;
   int16 GetInt16(const char* name, int32 index,
         int16 defaultValue) const;
   uint16 GetUInt16(const char* name,
         uint16 defaultValue) const;
   uint16 GetUInt16(const char* name, int32 index,
         uint16 defaultValue) const;
   int32 GetInt32(const char* name,
         int32 defaultValue) const;
   int32 GetInt32(const char* name, int32 index,
         int32 defaultValue) const;
   uint32 GetUInt32(const char* name,
         uint32 defaultValue) const;
   uint32 GetUInt32(const char* name, int32 index,
         uint32 defaultValue) const;
   int64 GetInt64(const char* name,
         int64 defaultValue) const;
   int64 GetInt64(const char* name, int32 index,
         int64 defaultValue) const;
   uint64 GetUInt64(const char* name,
         uint64 defaultValue) const;
   uint64 GetUInt64(const char* name, int32 index,
         uint64 defaultValue) const;
   float GetFloat(const char* name,
         float defaultValue) const;
   float GetFloat(const char* name, int32 index,
         float defaultValue) const;
   double GetDouble(const char* name,
         double defaultValue) const;
   double GetDouble(const char* name, int32 index,
         double defaultValue) const;
   rgb_color GetColor(const char* name,
         rgb_color defaultValue) const;
   rgb_color GetColor(const char* name, int32 index,
         rgb_color defaultValue) const;
   const void* GetPointer(const char* name, int32 index,
         const void* defaultValue = __null) const;
   const void* GetPointer(const char* name,
         const void* defaultValue = __null) const;
   const char* GetString(const char* name,
         const char* defaultValue = __null) const;
   const char* GetString(const char* name, int32 index,
         const char* defaultValue) const;
   BAlignment GetAlignment(const char* name, int32 index,
         const BAlignment& defaultValue) const;
   BAlignment GetAlignment(const char* name,
         const BAlignment& defaultValue) const;
   BRect GetRect(const char* name, int32 index,
         const BRect& defaultValue) const;
   BRect GetRect(const char* name,
         const BRect& defaultValue) const;
   BPoint GetPoint(const char* name, int32 index,
         const BPoint& defaultValue) const;
   BPoint GetPoint(const char* name,
         const BPoint& defaultValue) const;
   BSize GetSize(const char* name, int32 index,
         const BSize& defaultValue) const;
   BSize GetSize(const char* name,
         const BSize& defaultValue) const;


   status_t SetBool(const char* name, bool value);
   status_t SetInt8(const char* name, int8 value);
   status_t SetUInt8(const char* name, uint8 value);
   status_t SetInt16(const char* name, int16 value);
   status_t SetUInt16(const char* name, uint16 value);
   status_t SetInt32(const char* name, int32 value);
   status_t SetUInt32(const char* name, uint32 value);
   status_t SetInt64(const char* name, int64 value);
   status_t SetUInt64(const char* name, uint64 value);
   status_t SetColor(const char* name, rgb_color value);
   status_t SetPointer(const char* name, const void* value);
   status_t SetString(const char* name, const char* string);
   status_t SetString(const char* name,
         const BString& string);
   status_t SetFloat(const char* name, float value);
   status_t SetDouble(const char* name, double value);
   status_t SetAlignment(const char* name,
         const BAlignment& value);
   status_t SetPoint(const char* name, const BPoint& value);
   status_t SetRect(const char* name, const BRect& value);
   status_t SetSize(const char* name, const BSize& value);
   status_t SetData(const char* name, type_code type,
         const void* data, ssize_t numBytes,
         bool fixedSize = true, int count = 1);

 class Private;
 struct message_header;
 struct field_header;

private:
 friend class Private;
 friend class BMessageQueue;

   status_t _InitCommon(bool initHeader);
   status_t _InitHeader();
   status_t _Clear();

   status_t _FlattenToArea(message_header** _header) const;
   status_t _CopyForWrite();
   status_t _Reference();
   status_t _Dereference();

   status_t _ValidateMessage();

   void _UpdateOffsets(uint32 offset, int32 change);
   status_t _ResizeData(uint32 offset, int32 change);

   uint32 _HashName(const char* name) const;
   status_t _FindField(const char* name, type_code type,
         field_header** _result) const;
   status_t _AddField(const char* name, type_code type,
         bool isFixedSize, field_header** _result);
   status_t _RemoveField(field_header* field);

   void _PrintToStream(const char* indent) const;

private:
        BMessage(BMessage* message);


 virtual void _ReservedMessage1();
 virtual void _ReservedMessage2();
 virtual void _ReservedMessage3();

   status_t _SendMessage(port_id port, team_id portOwner,
         int32 token, bigtime_t timeout,
         bool replyRequired,
         BMessenger& replyTo) const;
   status_t _SendMessage(port_id port, team_id portOwner,
         int32 token, BMessage* reply,
         bigtime_t sendTimeout,
         bigtime_t replyTimeout) const;
 static status_t _SendFlattenedMessage(void* data, int32 size,
         port_id port, int32 token,
         bigtime_t timeout);

 static void _StaticInit();
 static void _StaticReInitForkedChild();
 static void _StaticCleanup();
 static void _StaticCacheCleanup();
 static int32 _StaticGetCachedReplyPort();

private:
   message_header* fHeader;
   field_header* fFields;
   uint8* fData;

   uint32 fFieldsAvailable;
   size_t fDataAvailable;

   mutable BMessage* fOriginal;

   BMessage* fQueueLink;


   void* fArchivingPointer;

   uint32 fReserved[8];

   enum { sNumReplyPorts = 3 };
 static port_id sReplyPorts[sNumReplyPorts];
 static int32 sReplyPortInUse[sNumReplyPorts];
 static int32 sGetCachedReplyPort();

 static BBlockCache* sMsgCache;
};



class BMessage;


namespace BPrivate {
namespace Archiving {
 class BArchiveManager;
 class BUnarchiveManager;
}
}

using ::BPrivate::Archiving::BArchiveManager;
using ::BPrivate::Archiving::BUnarchiveManager;


class BArchivable {
public:
        BArchivable(BMessage* from);
        BArchivable();
 virtual ~BArchivable();

 virtual status_t Archive(BMessage* into, bool deep = true) const;
 static BArchivable* Instantiate(BMessage* archive);

 virtual status_t Perform(perform_code d, void* arg);

 virtual status_t AllUnarchived(const BMessage* archive);
 virtual status_t AllArchived(BMessage* archive) const;

private:
 friend class BUnarchiveManager;

 virtual void _ReservedArchivable3();

   int32 fArchivingToken;
   uint32 _reserved;
};


class BArchiver {
public:
        BArchiver(BMessage* archive);
        ~BArchiver();

   status_t AddArchivable(const char* name,
         BArchivable* archivable, bool deep = true);

 inline status_t GetTokenForArchivable(BArchivable* archivable,
         int32& _token);
   status_t GetTokenForArchivable(BArchivable* archivable,
         bool deep, int32& _token);

   bool IsArchived(BArchivable* archivable);
   status_t Finish(status_t err = ((int)0));
   BMessage* ArchiveMessage() const;

private:
 friend class BArchivable;

        BArchiver();
        BArchiver(const BArchiver&);

   void RegisterArchivable(
         const BArchivable* archivable);

   BArchiveManager* fManager;
   BMessage* fArchive;
   bool fFinished;
   uint32 _reserved[2];
};


class BUnarchiver {
public:
   enum ownership_policy {
    B_ASSUME_OWNERSHIP,
    B_DONT_ASSUME_OWNERSHIP
   };

        BUnarchiver(const BMessage* archive);
        ~BUnarchiver();

 template<class T>
 inline status_t GetObject(int32 token, T*& object);

 template<class T>
   status_t GetObject(int32 token, ownership_policy owning,
         T*& object);

 template<class T>
 inline status_t FindObject(const char* name, T*& object);

 template<class T>
 inline status_t FindObject(const char* name,
         ownership_policy owning,
         T*& object);

 template<class T>
 inline status_t FindObject(const char* name,
         int32 index, T*& object);

 template<class T>
   status_t FindObject(const char* name, int32 index,
         ownership_policy owning, T*& object);

 inline status_t EnsureUnarchived(const char* name,
         int32 index = 0);
 inline status_t EnsureUnarchived(int32 token);

   bool IsInstantiated(int32 token);
   bool IsInstantiated(const char* name,
         int32 index = 0);

   status_t Finish(status_t err = ((int)0));
   const BMessage* ArchiveMessage() const;

   void AssumeOwnership(BArchivable* archivable);
   void RelinquishOwnership(BArchivable* archivable);

 static bool IsArchiveManaged(const BMessage* archive);
 static BMessage* PrepareArchive(BMessage*& archive);

 template<class T>
 static status_t InstantiateObject(BMessage* archive,
         T*& object);

private:
 friend class BArchivable;

        BUnarchiver();
        BUnarchiver(const BUnarchiver&);

   void RegisterArchivable(BArchivable* archivable);

 inline void _CallDebuggerIfManagerNull();

   BUnarchiveManager* fManager;
   const BMessage* fArchive;
   bool fFinished;
   uint32 _reserved[2];
};




typedef BArchivable* (*instantiation_func)(BMessage*);

BArchivable* instantiate_object(BMessage* from, image_id* id);
BArchivable* instantiate_object(BMessage* from);
bool validate_instantiation(BMessage* from, const char* className);

instantiation_func find_instantiation_func(const char* className,
 const char* signature);
instantiation_func find_instantiation_func(const char* className);
instantiation_func find_instantiation_func(BMessage* archive);


status_t
BArchiver::GetTokenForArchivable(BArchivable* archivable, int32& _token)
{
 return GetTokenForArchivable(archivable, true, _token);
}


template<>
status_t BUnarchiver::FindObject<BArchivable>(const char* name, int32 index,
 ownership_policy owning, BArchivable*& archivable);


template<class T>
status_t
BUnarchiver::FindObject(const char* name, int32 index,
 ownership_policy owning, T*& object)
{
 object = __null;

 BArchivable* interim;
 status_t err = FindObject(name, index, owning, interim);

 if (err == ((int)0) && interim) {
  object = dynamic_cast<T*>(interim);
  if (!object) {
   err = ((-0x7fffffff - 1) + 4);

   if (owning == B_ASSUME_OWNERSHIP)
    RelinquishOwnership(interim);
  }
 }
 return err;
}


template<>
status_t
BUnarchiver::GetObject<BArchivable>(int32 token,
 ownership_policy owning, BArchivable*& object);


template<class T>
status_t
BUnarchiver::GetObject(int32 token, ownership_policy owning, T*& object)
{
 object = __null;

 BArchivable* interim;
 status_t err = GetObject(token, owning, interim);

 if (err == ((int)0) && interim) {
  object = dynamic_cast<T*>(interim);
  if (!object) {
   err = ((-0x7fffffff - 1) + 4);

   if (owning == B_ASSUME_OWNERSHIP)
    RelinquishOwnership(interim);
  }
 }
 return err;
}


template<class T>
status_t
BUnarchiver::GetObject(int32 token, T*& object)
{
 return GetObject<T>(token, B_ASSUME_OWNERSHIP, object);
}


template<class T>
status_t
BUnarchiver::FindObject(const char* name, ownership_policy owning, T*& object)
{
 return FindObject(name, 0, owning, object);
}


template<class T>
status_t
BUnarchiver::FindObject(const char* name, T*& object)
{
 return FindObject<T>(name, 0, B_ASSUME_OWNERSHIP, object);
}


template<class T>
status_t
BUnarchiver::FindObject(const char* name,
 int32 index, T*& object)
{
 return FindObject(name, index, B_ASSUME_OWNERSHIP, object);
}


status_t
BUnarchiver::EnsureUnarchived(int32 token)
{
 BArchivable* dummy;
 return GetObject(token, B_DONT_ASSUME_OWNERSHIP, dummy);
}


status_t
BUnarchiver::EnsureUnarchived(const char* name, int32 index)
{
 BArchivable* dummy;
 return FindObject(name, index, B_DONT_ASSUME_OWNERSHIP, dummy);
}


template<>
status_t
BUnarchiver::InstantiateObject<BArchivable>(BMessage* from,
 BArchivable*& object);


template<class T>
status_t
BUnarchiver::InstantiateObject(BMessage* archive, T*& object)
{
 object = __null;

 BArchivable* interim;
 status_t err = InstantiateObject(archive, interim);
 if (err != ((int)0) || interim == __null)
  return err;

 object = dynamic_cast<T*>(interim);
 if (object == __null) {
  delete interim;
  return ((-0x7fffffff - 1) + 4);
 }

 return ((int)0);
}


class BLooper;
class BMessageFilter;
class BMessage;
class BMessenger;
class BList;



const uint32 B_OBSERVER_OBSERVE_ALL = 0xffffffff;

namespace BPrivate {
 class ObserverList;
}

class BHandler : public BArchivable {
public:
       BHandler(const char* name = __null);
 virtual ~BHandler();


       BHandler(BMessage* data);
 static BArchivable* Instantiate(BMessage* data);
 virtual status_t Archive(BMessage* data, bool deep = true) const;


 virtual void MessageReceived(BMessage* message);
   BLooper* Looper() const;
   void SetName(const char* name);
   const char* Name() const;
 virtual void SetNextHandler(BHandler* handler);
   BHandler* NextHandler() const;


 virtual void AddFilter(BMessageFilter* filter);
 virtual bool RemoveFilter(BMessageFilter* filter);
 virtual void SetFilterList(BList* filters);
   BList* FilterList();

   bool LockLooper();
   status_t LockLooperWithTimeout(bigtime_t timeout);
   void UnlockLooper();


 virtual BHandler* ResolveSpecifier(BMessage* message, int32 index,
        BMessage* specifier, int32 what,
        const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);


   status_t StartWatching(BMessenger target, uint32 what);
   status_t StartWatchingAll(BMessenger target);
   status_t StopWatching(BMessenger target, uint32 what);
   status_t StopWatchingAll(BMessenger target);


   status_t StartWatching(BHandler* observer, uint32 what);
   status_t StartWatchingAll(BHandler* observer);
   status_t StopWatching(BHandler* observer, uint32 what);
   status_t StopWatchingAll(BHandler* observer);



 virtual status_t Perform(perform_code d, void* arg);


 virtual void SendNotices(uint32 what,
        const BMessage* notice = __null);
   bool IsWatched() const;

private:
 typedef BArchivable _inherited;
 friend inline int32 _get_object_token_(const BHandler* );
 friend class BLooper;
 friend class BMessageFilter;

 virtual void _ReservedHandler2();
 virtual void _ReservedHandler3();
 virtual void _ReservedHandler4();

   void _InitData(const char* name);
   BPrivate::ObserverList* _ObserverList();

       BHandler(const BHandler&);
   BHandler& operator=(const BHandler&);
   void SetLooper(BLooper* looper);

   int32 fToken;
   char* fName;
   BLooper* fLooper;
   BHandler* fNextHandler;
   BList* fFilters;
   BPrivate::ObserverList* fObserverList;
   uint32 _reserved[3];
};
class BList {
public:
        BList(int32 count = 20);
        BList(const BList& other);
 virtual ~BList();

   BList& operator=(const BList& other);
   bool operator==(const BList& other) const;
   bool operator!=(const BList& other) const;


   bool AddItem(void* item, int32 index);
   bool AddItem(void* item);
   bool AddList(const BList* list, int32 index);
   bool AddList(const BList* list);

   bool RemoveItem(void* item);
   void* RemoveItem(int32 index);
   bool RemoveItems(int32 index, int32 count);
   bool ReplaceItem(int32 index, void* item);

   void MakeEmpty();


   void SortItems(int (*compareFunc)(const void*,
         const void*));
   bool SwapItems(int32 indexA, int32 indexB);
   bool MoveItem(int32 from, int32 to);


   void* ItemAt(int32 index) const;
   void* FirstItem() const;
   void* ItemAtFast(int32 index) const;


   void* LastItem() const;
   void* Items() const;


   bool HasItem(void* item) const;
   bool HasItem(const void* item) const;
   int32 IndexOf(void* item) const;
   int32 IndexOf(const void* item) const;
   int32 CountItems() const;
   bool IsEmpty() const;


   void DoForEach(bool (*func)(void* item));
   void DoForEach(bool (*func)(void* item,
         void* arg2), void* arg2);

private:
 virtual void _ReservedList1();
 virtual void _ReservedList2();

   bool _ResizeArray(int32 count);

private:
   void** fObjectList;
   int32 fPhysicalSize;
   int32 fItemCount;
   int32 fBlockSize;
   int32 fResizeThreshold;

   uint32 _reserved[1];
};



class BMessage;
class BMessageQueue;
namespace BPrivate {
 class BDirectMessageTarget;
 class BLooperList;
}





class BLooper : public BHandler {
public:
       BLooper(const char* name = __null,
        int32 priority = 10,
        int32 portCapacity
         = 200);
 virtual ~BLooper();


       BLooper(BMessage* data);
 static BArchivable* Instantiate(BMessage* data);
 virtual status_t Archive(BMessage* data, bool deep = true) const;


   status_t PostMessage(uint32 command);
   status_t PostMessage(BMessage* message);
   status_t PostMessage(uint32 command, BHandler* handler,
        BHandler* replyTo = __null);
   status_t PostMessage(BMessage* message, BHandler* handler,
        BHandler* replyTo = __null);

 virtual void DispatchMessage(BMessage* message,
        BHandler* handler);
 virtual void MessageReceived(BMessage* message);
   BMessage* CurrentMessage() const;
   BMessage* DetachCurrentMessage();
   void DispatchExternalMessage(BMessage* message,
        BHandler* handler, bool& _detached);
   BMessageQueue* MessageQueue() const;
   bool IsMessageWaiting() const;


   void AddHandler(BHandler* handler);
   bool RemoveHandler(BHandler* handler);
   int32 CountHandlers() const;
   BHandler* HandlerAt(int32 index) const;
   int32 IndexOf(BHandler* handler) const;

   BHandler* PreferredHandler() const;
   void SetPreferredHandler(BHandler* handler);


 virtual thread_id Run();
   void Loop();
 virtual void Quit();
 virtual bool QuitRequested();
   bool Lock();
   void Unlock();
   bool IsLocked() const;
   status_t LockWithTimeout(bigtime_t timeout);
   thread_id Thread() const;
   team_id Team() const;
 static BLooper* LooperForThread(thread_id thread);


   thread_id LockingThread() const;
   int32 CountLocks() const;
   int32 CountLockRequests() const;
   sem_id Sem() const;


 virtual BHandler* ResolveSpecifier(BMessage* message, int32 index,
        BMessage* specifier, int32 what,
        const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);


 virtual void AddCommonFilter(BMessageFilter* filter);
 virtual bool RemoveCommonFilter(BMessageFilter* filter);
 virtual void SetCommonFilterList(BList* filters);
   BList* CommonFilterList() const;


 virtual status_t Perform(perform_code d, void* arg);

protected:

   BMessage* MessageFromPort(bigtime_t = (9223372036854775807LL));

private:
 typedef BHandler _inherited;
 friend class BWindow;
 friend class BApplication;
 friend class BMessenger;
 friend class BView;
 friend class BHandler;
 friend class ::BPrivate::BLooperList;
 friend port_id _get_looper_port_(const BLooper* );

 virtual void _ReservedLooper1();
 virtual void _ReservedLooper2();
 virtual void _ReservedLooper3();
 virtual void _ReservedLooper4();
 virtual void _ReservedLooper5();
 virtual void _ReservedLooper6();

       BLooper(const BLooper&);
   BLooper& operator=(const BLooper&);

       BLooper(int32 priority, port_id port,
        const char* name);

   status_t _PostMessage(BMessage* msg, BHandler* handler,
        BHandler* reply_to);

 static status_t _Lock(BLooper* loop, port_id port,
        bigtime_t timeout);
 static status_t _LockComplete(BLooper* loop, int32 old,
        thread_id this_tid, sem_id sem,
        bigtime_t timeout);
   void _InitData(const char* name, int32 priority,
        port_id port, int32 capacity);
   void AddMessage(BMessage* msg);
   void _AddMessagePriv(BMessage* msg);
 static status_t _task0_(void* arg);

   void* ReadRawFromPort(int32* code,
        bigtime_t timeout = (9223372036854775807LL));
   BMessage* ReadMessageFromPort(
        bigtime_t timeout = (9223372036854775807LL));
 virtual BMessage* ConvertToMessage(void* raw, int32 code);
 virtual void task_looper();
   void _QuitRequested(BMessage* msg);
   bool AssertLocked() const;
   BHandler* _TopLevelFilter(BMessage* msg, BHandler* target);
   BHandler* _HandlerFilter(BMessage* msg, BHandler* target);
   BHandler* _ApplyFilters(BList* list, BMessage* msg,
        BHandler* target);
   void check_lock();
   BHandler* resolve_specifier(BHandler* target, BMessage* msg);
   void UnlockFully();

   ::BPrivate::BDirectMessageTarget* fDirectTarget;
   BMessage* fLastMessage;
   port_id fMsgPort;
   int32 fAtomicCount;
   sem_id fLockSem;
   int32 fOwnerCount;
   thread_id fOwner;
   thread_id fThread;
   addr_t fCachedStack;
   int32 fInitPriority;
   BHandler* fPreferred;
   BList fHandlers;
   BList* fCommonFilters;
   bool fTerminating;
   bool fRunCalled;
   bool fOwnsPort;
   uint32 _reserved[11];
};








extern "C" {
static __inline uint32_t
be32dec(const void *pp)
{
 uint8_t const *p = (uint8_t const *)pp;

 return (((unsigned)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
}

static __inline uint64_t
be64dec(const void *pp)
{
 uint8_t const *p = (uint8_t const *)pp;

 return (((uint64_t)be32dec(p) << 32) | be32dec(p + 4));
}

static __inline void
be32enc(void *pp, uint32_t u)
{
 uint8_t *p = (uint8_t *)pp;

 p[0] = (u >> 24) & 0xff;
 p[1] = (u >> 16) & 0xff;
 p[2] = (u >> 8) & 0xff;
 p[3] = u & 0xff;
}

static __inline void
be64enc(void *pp, uint64_t u)
{
 uint8_t *p = (uint8_t *)pp;

 be32enc(p, (uint32_t)(u >> 32));
 be32enc(p + 4, (uint32_t)(u & 0xffffffffU));
}


}






typedef enum {
 B_SWAP_HOST_TO_LENDIAN,
 B_SWAP_HOST_TO_BENDIAN,
 B_SWAP_LENDIAN_TO_HOST,
 B_SWAP_BENDIAN_TO_HOST,
 B_SWAP_ALWAYS
} swap_action;
extern "C" {


extern status_t swap_data(type_code type, void *data, size_t length,
 swap_action action);
extern bool is_type_swapped(type_code type);


extern double __swap_double(double arg);
extern float __swap_float(float arg);
}



class BHandler;
class BLooper;

class BMessenger {
public:
         BMessenger();
         BMessenger(const char* signature,
          team_id team = -1,
          status_t* result = __null);
         BMessenger(const BHandler* handler,
          const BLooper* looper = __null,
          status_t* result = __null);
         BMessenger(const BMessenger& other);
         ~BMessenger();



   bool IsTargetLocal() const;
   BHandler* Target(BLooper **looper) const;
   bool LockTarget() const;
   status_t LockTargetWithTimeout(
          bigtime_t timeout) const;



   status_t SendMessage(uint32 command,
          BHandler* replyTo = __null) const;
   status_t SendMessage(BMessage* message,
          BHandler* replyTo = __null,
          bigtime_t timeout
           = (9223372036854775807LL)) const;
   status_t SendMessage(BMessage* message,
          BMessenger replyTo,
          bigtime_t timeout
           = (9223372036854775807LL)) const;
   status_t SendMessage(uint32 command,
          BMessage* reply) const;
   status_t SendMessage(BMessage* message,
          BMessage* reply,
          bigtime_t deliveryTimeout
           = (9223372036854775807LL),
          bigtime_t replyTimeout
           = (9223372036854775807LL)) const;



   status_t SetTo(const char* signature,
          team_id team = -1);
   status_t SetTo(const BHandler* handler,
          const BLooper* looper = __null);

   BMessenger& operator=(const BMessenger& other);
   bool operator==(const BMessenger& other) const;

   bool IsValid() const;
   team_id Team() const;

   uint32 HashValue() const;



 class Private;

private:
 friend class Private;

   void _SetTo(team_id team, port_id port,
          int32 token);
   void _InitData(const char* signature,
          team_id team, status_t* result);
   void _InitData(const BHandler* handler,
          const BLooper *looper,
          status_t* result);

private:
   port_id fPort;
   int32 fHandlerToken;
   team_id fTeam;

   int32 _reserved[3];
};

bool operator<(const BMessenger& a, const BMessenger& b);
bool operator!=(const BMessenger& a, const BMessenger& b);




class BCursor;
class BList;
class BLocker;
class BMessageRunner;
class BResources;
class BServer;
class BWindow;

struct app_info;


namespace BPrivate {
 class PortLink;
 class ServerMemoryAllocator;
}


class BApplication : public BLooper {
public:
        BApplication(const char* signature);
        BApplication(const char* signature,
         status_t* error);
 virtual ~BApplication();


        BApplication(BMessage* data);
 static BArchivable* Instantiate(BMessage* data);
 virtual status_t Archive(BMessage* data, bool deep = true) const;

   status_t InitCheck() const;


 virtual thread_id Run();
 virtual void Quit();
 virtual bool QuitRequested();
 virtual void Pulse();
 virtual void ReadyToRun();
 virtual void MessageReceived(BMessage* message);
 virtual void ArgvReceived(int32 argc, char** argv);
 virtual void AppActivated(bool active);
 virtual void RefsReceived(BMessage* message);
 virtual void AboutRequested();


 virtual BHandler* ResolveSpecifier(BMessage* message, int32 index,
         BMessage* specifier, int32 form,
         const char* property);


   void ShowCursor();
   void HideCursor();
   void ObscureCursor();
   bool IsCursorHidden() const;
   void SetCursor(const void* cursor);
   void SetCursor(const BCursor* cursor,
         bool sync = true);

   int32 CountWindows() const;
   BWindow* WindowAt(int32 index) const;

   int32 CountLoopers() const;
   BLooper* LooperAt(int32 index) const;
   bool IsLaunching() const;
   const char* Signature() const;
   status_t GetAppInfo(app_info* info) const;
 static BResources* AppResources();

 virtual void DispatchMessage(BMessage* message,
         BHandler* handler);
   void SetPulseRate(bigtime_t rate);



   status_t RegisterLooper(BLooper* looper);
   status_t UnregisterLooper(BLooper* looper);


 virtual status_t GetSupportedSuites(BMessage* data);



 virtual status_t Perform(perform_code d, void* arg);

 class Private;

private:
 typedef BLooper _inherited;

 friend class Private;
 friend class BServer;

        BApplication(const char* signature,
         const char* looperName, port_id port,
         bool initGUI, status_t* error);
        BApplication(uint32 signature);
        BApplication(const BApplication&);
   BApplication& operator=(const BApplication&);

 virtual void _ReservedApplication1();
 virtual void _ReservedApplication2();
 virtual void _ReservedApplication3();
 virtual void _ReservedApplication4();
 virtual void _ReservedApplication5();
 virtual void _ReservedApplication6();
 virtual void _ReservedApplication7();
 virtual void _ReservedApplication8();

 virtual bool ScriptReceived(BMessage* msg, int32 index,
         BMessage* specifier, int32 form,
         const char* property);
   void _InitData(const char* signature, bool initGUI,
         status_t* error);
   port_id _GetPort(const char* signature);
   void BeginRectTracking(BRect r, bool trackWhole);
   void EndRectTracking();
   status_t _SetupServerAllocator();
   status_t _InitGUIContext();
   status_t _ConnectToServer();
   void _ReconnectToServer();
   bool _QuitAllWindows(bool force);
   bool _WindowQuitLoop(bool quitFilePanels,
         bool force);
   void _ArgvReceived(BMessage* message);

   uint32 InitialWorkspace();
   int32 _CountWindows(bool includeMenus) const;
   BWindow* _WindowAt(uint32 index,
         bool includeMenus) const;

 static void _InitAppResources();

private:
 static BResources* sAppResources;

   const char* fAppName;
   ::BPrivate::PortLink* fServerLink;
   ::BPrivate::ServerMemoryAllocator* fServerAllocator;

   void* fCursorData;
   bigtime_t fPulseRate;
   uint32 fInitialWorkspace;
   BMessageRunner* fPulseRunner;
   status_t fInitError;
   void* fServerReadOnlyMemory;
   uint32 _reserved[12];

   bool fReadyToRunCalled;
};




extern BApplication* be_app;
extern BMessenger be_app_messenger;



class BAffineTransform : public BFlattenable {
public:




 static constexpr double kDefaultEpsilon = 1e-14;


public:
         BAffineTransform();
         BAffineTransform(double sx, double shy,
          double shx, double sy, double tx,
          double ty);
         BAffineTransform(
          const BAffineTransform& copyFrom);
 virtual ~BAffineTransform();


 virtual bool IsFixedSize() const;
 virtual type_code TypeCode() const;
 virtual ssize_t FlattenedSize() const;
 virtual status_t Flatten(void* buffer,
          ssize_t size) const;
 virtual status_t Unflatten(type_code code,
          const void* buffer, ssize_t size);


 static BAffineTransform AffineTranslation(double x, double y);
 static BAffineTransform AffineRotation(double angle);
 static BAffineTransform AffineScaling(double x, double y);
 static BAffineTransform AffineScaling(double scale);
 static BAffineTransform AffineShearing(double x, double y);


 inline void Apply(double* x, double* y) const;
 inline void ApplyInverse(double* x, double* y) const;

   BPoint Apply(const BPoint& point) const;
   BPoint ApplyInverse(const BPoint& point) const;

   void Apply(BPoint* point) const;
   void ApplyInverse(BPoint* point) const;

   void Apply(BPoint* points, uint32 count) const;
   void ApplyInverse(BPoint* points,
          uint32 count) const;


 inline const BAffineTransform& TranslateBy(double x, double y);
   const BAffineTransform& TranslateBy(const BPoint& delta);

 inline const BAffineTransform& PreTranslateBy(double x, double y);

   BAffineTransform TranslateByCopy(double x, double y) const;
   BAffineTransform TranslateByCopy(const BPoint& delta) const;




 inline const BAffineTransform& RotateBy(double angle);
   const BAffineTransform& RotateBy(const BPoint& center,
          double angle);

 inline const BAffineTransform& PreRotateBy(double angleRadians);

   BAffineTransform RotateByCopy(double angle) const;
   BAffineTransform RotateByCopy(const BPoint& center,
          double angle) const;




 inline const BAffineTransform& ScaleBy(double scale);
   const BAffineTransform& ScaleBy(const BPoint& center,
          double scale);
 inline const BAffineTransform& ScaleBy(double x, double y);
   const BAffineTransform& ScaleBy(const BPoint& center, double x,
          double y);
   const BAffineTransform& ScaleBy(const BPoint& scale);
   const BAffineTransform& ScaleBy(const BPoint& center,
          const BPoint& scale);

 inline const BAffineTransform& PreScaleBy(double x, double y);

   BAffineTransform ScaleByCopy(double scale) const;
   BAffineTransform ScaleByCopy(const BPoint& center,
          double scale) const;
   BAffineTransform ScaleByCopy(double x, double y) const;
   BAffineTransform ScaleByCopy(const BPoint& center,
          double x, double y) const;
   BAffineTransform ScaleByCopy(const BPoint& scale) const;
   BAffineTransform ScaleByCopy(const BPoint& center,
          const BPoint& scale) const;

   const BAffineTransform& SetScale(double scale);
   const BAffineTransform& SetScale(double x, double y);


 inline const BAffineTransform& ShearBy(double x, double y);
   const BAffineTransform& ShearBy(const BPoint& center, double x,
          double y);
   const BAffineTransform& ShearBy(const BPoint& shear);
   const BAffineTransform& ShearBy(const BPoint& center,
          const BPoint& shear);

   BAffineTransform ShearByCopy(double x, double y) const;
   BAffineTransform ShearByCopy(const BPoint& center,
          double x, double y) const;
   BAffineTransform ShearByCopy(const BPoint& shear) const;
   BAffineTransform ShearByCopy(const BPoint& center,
          const BPoint& shear) const;




 inline const BAffineTransform& Multiply(const BAffineTransform& other);
   const BAffineTransform& PreMultiply(const BAffineTransform& other);
 inline const BAffineTransform& MultiplyInverse(
          const BAffineTransform& other);
 inline const BAffineTransform& PreMultiplyInverse(
          const BAffineTransform& other);


 inline BAffineTransform& operator=(
          const BAffineTransform& copyFrom);

 inline bool operator==(
          const BAffineTransform& other) const;
 inline bool operator!=(
          const BAffineTransform& other) const;

 inline const BAffineTransform& operator*=(const BAffineTransform& other);
 inline const BAffineTransform& operator/=(const BAffineTransform& other);

 inline BAffineTransform operator*(
          const BAffineTransform& other) const;
 inline BAffineTransform operator/(
          const BAffineTransform& other) const;

 inline BAffineTransform operator~() const;


   bool IsValid(double epsilon
          = kDefaultEpsilon) const;
   bool IsIdentity(double epsilon
          = kDefaultEpsilon) const;
   bool IsDilation(double epsilon
          = kDefaultEpsilon) const;
   bool IsEqual(const BAffineTransform& other,
          double epsilon
           = kDefaultEpsilon) const;

   const BAffineTransform& Invert();
   const BAffineTransform& FlipX();
   const BAffineTransform& FlipY();
   const BAffineTransform& Reset();

 inline double Determinant() const;
 inline double InverseDeterminant() const;
   void GetTranslation(double* tx,
          double* ty) const;
   double Rotation() const;
   double Scale() const;
   void GetScale(double* sx, double* sy) const;
   void GetScaleAbs(double* sx,
          double* sy) const;
   bool GetAffineParameters(double* translationX,
          double* translationY, double* rotation,
          double* scaleX, double* scaleY,
          double* shearX, double* shearY) const;

public:
   double sx;
   double shy;
   double shx;
   double sy;
   double tx;
   double ty;
};


extern const BAffineTransform B_AFFINE_IDENTITY_TRANSFORM;





inline void
BAffineTransform::Apply(double* x, double* y) const
{
 double tmp = *x;
 *x = tmp * sx + *y * shx + tx;
 *y = tmp * shy + *y * sy + ty;
}


inline void
BAffineTransform::ApplyInverse(double* x, double* y) const
{
 double d = InverseDeterminant();
 double a = (*x - tx) * d;
 double b = (*y - ty) * d;
 *x = a * sy - b * shx;
 *y = b * sx - a * shy;
}





inline const BAffineTransform&
BAffineTransform::TranslateBy(double x, double y)
{
 tx += x;
 ty += y;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::PreTranslateBy(double x, double y)
{
 tx += x * sx + y * shx;
 ty += x * shy + y * sy;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::RotateBy(double angle)
{
 double ca = cos(angle);
 double sa = sin(angle);
 double t0 = sx * ca - shy * sa;
 double t2 = shx * ca - sy * sa;
 double t4 = tx * ca - ty * sa;
 shy = sx * sa + shy * ca;
 sy = shx * sa + sy * ca;
 ty = tx * sa + ty * ca;
 sx = t0;
 shx = t2;
 tx = t4;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::PreRotateBy(double angle)
{
 double ca = cos(angle);
 double sa = sin(angle);
 double newSx = sx * ca + shx * sa;
 double newSy = -shy * sa + sy * ca;
 shy = shy * ca + sy * sa;
 shx = -sx * sa + shx * ca;
 sx = newSx;
 sy = newSy;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::ScaleBy(double x, double y)
{
 double mm0 = x;

 double mm3 = y;
 sx *= mm0;
 shx *= mm0;
 tx *= mm0;
 shy *= mm3;
 sy *= mm3;
 ty *= mm3;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::ScaleBy(double s)
{
 double m = s;

 sx *= m;
 shx *= m;
 tx *= m;
 shy *= m;
 sy *= m;
 ty *= m;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::PreScaleBy(double x, double y)
{
 sx *= x;
 shx *= y;
 shy *= x;
 sy *= y;
 return *this;
}


inline const BAffineTransform&
BAffineTransform::ShearBy(double x, double y)
{
 BAffineTransform shearTransform = AffineShearing(x, y);
 return PreMultiply(shearTransform);
}





inline const BAffineTransform&
BAffineTransform::Multiply(const BAffineTransform& other)
{
 BAffineTransform t(other);
 return *this = t.PreMultiply(*this);
}


inline const BAffineTransform&
BAffineTransform::MultiplyInverse(const BAffineTransform& other)
{
 BAffineTransform t(other);
 t.Invert();
 return Multiply(t);
}


inline const BAffineTransform&
BAffineTransform::PreMultiplyInverse(const BAffineTransform& other)
{
 BAffineTransform t(other);
 t.Invert();
 return *this = t.Multiply(*this);
}





inline BAffineTransform&
BAffineTransform::operator=(const BAffineTransform& other)
{
 sx = other.sx;
 shy = other.shy;
 shx = other.shx;
 sy = other.sy;
 tx = other.tx;
 ty = other.ty;
 return *this;
}

inline bool
BAffineTransform::operator==(const BAffineTransform& other) const
{
 return IsEqual(other);
}

inline bool
BAffineTransform::operator!=(const BAffineTransform& other) const
{
 return !IsEqual(other);
}


inline const BAffineTransform&
BAffineTransform::operator*=(const BAffineTransform& other)
{
 return Multiply(other);
}


inline const BAffineTransform&
BAffineTransform::operator/=(const BAffineTransform& other)
{
 return MultiplyInverse(other);
}


inline BAffineTransform
BAffineTransform::operator*(const BAffineTransform& other) const
{
 return BAffineTransform(*this).Multiply(other);
}


inline BAffineTransform
BAffineTransform::operator/(const BAffineTransform& other) const
{
 return BAffineTransform(*this).MultiplyInverse(other);
}


inline BAffineTransform
BAffineTransform::operator~() const
{
 BAffineTransform result(*this);
 return result.Invert();
}





inline double
BAffineTransform::Determinant() const
{
 return sx * sy - shy * shx;
}


inline double
BAffineTransform::InverseDeterminant() const
{
 return 1.0 / (sx * sy - shy * shx);
}
class BAlignment {
public:
   alignment horizontal;
   vertical_alignment vertical;

 inline BAlignment();
 inline BAlignment(const BAlignment& other);
 inline BAlignment(alignment horizontal,
         vertical_alignment vertical);

 inline alignment Horizontal() const;
 inline vertical_alignment Vertical() const;

   float RelativeHorizontal() const;
   float RelativeVertical() const;

 inline void SetHorizontal(alignment horizontal);
 inline void SetVertical(vertical_alignment vertical);

 inline bool IsHorizontalSet() const;
 inline bool IsVerticalSet() const;

 inline bool operator==(const BAlignment& other) const;
 inline bool operator!=(const BAlignment& other) const;

 inline BAlignment& operator=(const BAlignment& other);
};



inline
BAlignment::BAlignment()
 : horizontal(B_ALIGN_HORIZONTAL_UNSET),
   vertical(B_ALIGN_VERTICAL_UNSET)
{
}


inline
BAlignment::BAlignment(const BAlignment& other)
 : horizontal(other.horizontal),
   vertical(other.vertical)
{
}


inline
BAlignment::BAlignment(alignment horizontal, vertical_alignment vertical)
 : horizontal(horizontal),
   vertical(vertical)
{
}


inline alignment
BAlignment::Horizontal() const
{
 return horizontal;
}


inline vertical_alignment
BAlignment::Vertical() const
{
 return vertical;
}


inline void
BAlignment::SetHorizontal(alignment horizontal)
{
 this->horizontal = horizontal;
}


inline void
BAlignment::SetVertical(vertical_alignment vertical)
{
 this->vertical = vertical;
}


inline bool
BAlignment::IsHorizontalSet() const
{
 return (horizontal != B_ALIGN_HORIZONTAL_UNSET);
}


inline bool
BAlignment::IsVerticalSet() const
{
 return (vertical != B_ALIGN_VERTICAL_UNSET);
}


inline bool
BAlignment::operator==(const BAlignment& other) const
{
 return (horizontal == other.horizontal && vertical == other.vertical);
}


inline bool
BAlignment::operator!=(const BAlignment& other) const
{
 return !(*this == other);
}


inline BAlignment&
BAlignment::operator=(const BAlignment& other)
{
 horizontal = other.horizontal;
 vertical = other.vertical;
 return *this;
}
class BPoint;




typedef char font_family[63 + 1];
typedef char font_style[63 + 1];



enum {
 B_CHAR_SPACING = 0,
 B_STRING_SPACING = 1,
 B_BITMAP_SPACING = 2,
 B_FIXED_SPACING = 3
};


enum font_direction {
 B_FONT_LEFT_TO_RIGHT = 0,
 B_FONT_RIGHT_TO_LEFT = 1
};



enum {
 B_DISABLE_ANTIALIASING = 0x00000001,
 B_FORCE_ANTIALIASING = 0x00000002
};



enum {
 B_NO_TRUNCATION = ~0U,
 B_TRUNCATE_END = 0,
 B_TRUNCATE_BEGINNING = 1,
 B_TRUNCATE_MIDDLE = 2,
 B_TRUNCATE_SMART = 3
};



enum {
 B_UNICODE_UTF8 = 0,
 B_ISO_8859_1 = 1,
 B_ISO_8859_2 = 2,
 B_ISO_8859_3 = 3,
 B_ISO_8859_4 = 4,
 B_ISO_8859_5 = 5,
 B_ISO_8859_6 = 6,
 B_ISO_8859_7 = 7,
 B_ISO_8859_8 = 8,
 B_ISO_8859_9 = 9,
 B_ISO_8859_10 = 10,
 B_MACINTOSH_ROMAN = 11
};



enum {
 B_HAS_TUNED_FONT = 0x0001,
 B_IS_FIXED = 0x0002
};



enum {
 B_ITALIC_FACE = 0x0001,
 B_UNDERSCORE_FACE = 0x0002,
 B_NEGATIVE_FACE = 0x0004,
 B_OUTLINED_FACE = 0x0008,
 B_STRIKEOUT_FACE = 0x0010,
 B_BOLD_FACE = 0x0020,
 B_REGULAR_FACE = 0x0040,

 B_CONDENSED_FACE = 0x0080,
 B_LIGHT_FACE = 0x0100,
 B_HEAVY_FACE = 0x0200,
};


enum font_metric_mode {
 B_SCREEN_METRIC = 0,
 B_PRINTING_METRIC = 1
};


enum font_file_format {
 B_TRUETYPE_WINDOWS = 0,
 B_POSTSCRIPT_TYPE1_WINDOWS = 1
};


class unicode_block {
public:
 inline unicode_block();
 inline unicode_block(uint64 block2, uint64 block1);

 inline bool Includes(const unicode_block& block) const;
 inline unicode_block operator&(const unicode_block& block) const;
 inline unicode_block operator|(const unicode_block& block) const;
 inline unicode_block& operator=(const unicode_block& block);
 inline bool operator==(const unicode_block& block) const;
 inline bool operator!=(const unicode_block& block) const;

private:
 uint64 fData[2];
};


struct unicode_block_range {
 uint32 start;
 uint32 end;
 const unicode_block& block;

 uint32 Count() const { return end + 1 - start; }
};


struct edge_info {
 float left;
 float right;
};


struct font_height {
 float ascent;
 float descent;
 float leading;
};


struct escapement_delta {
 float nonspace;
 float space;
};


struct font_cache_info {
 int32 sheared_font_penalty;
 int32 rotated_font_penalty;
 float oversize_threshold;
 int32 oversize_penalty;
 int32 cache_size;
 float spacing_size_threshold;
};


struct tuned_font_info {
 float size;
 float shear;
 float rotation;
 uint32 flags;
 uint16 face;
};


class BShape;
class BString;
class BFontPrivate;


class BFont {
public:
        BFont();
        BFont(const BFont& font);
        BFont(const BFont* font);

   status_t SetFamilyAndStyle(const font_family family,
         const font_style style);
   void SetFamilyAndStyle(uint32 code);
   status_t SetFamilyAndFace(const font_family family,
         uint16 face);

   void SetSize(float size);
   void SetShear(float shear);
   void SetRotation(float rotation);
   void SetFalseBoldWidth(float width);
   void SetSpacing(uint8 spacing);
   void SetEncoding(uint8 encoding);
   void SetFace(uint16 face);
   void SetFlags(uint32 flags);

   void GetFamilyAndStyle(font_family* family,
         font_style* style) const;
   uint32 FamilyAndStyle() const;
   float Size() const;
   float Shear() const;
   float Rotation() const;
   float FalseBoldWidth() const;
   uint8 Spacing() const;
   uint8 Encoding() const;
   uint16 Face() const;
   uint32 Flags() const;

   font_direction Direction() const;
   bool IsFixed() const;
   bool IsFullAndHalfFixed() const;
   BRect BoundingBox() const;
   unicode_block Blocks() const;
   bool IncludesBlock(uint32 start, uint32 end) const;
   font_file_format FileFormat() const;

   int32 CountTuned() const;
   void GetTunedInfo(int32 index,
         tuned_font_info* info) const;

   void TruncateString(BString* inOut, uint32 mode,
         float width) const;
   void GetTruncatedStrings(const char* stringArray[],
         int32 numStrings, uint32 mode, float width,
         BString resultArray[]) const;
   void GetTruncatedStrings(const char* stringArray[],
         int32 numStrings, uint32 mode,
         float width, char* resultArray[]) const;

   float StringWidth(const char* string) const;
   float StringWidth(const char* string,
         int32 length) const;
   void GetStringWidths(const char* stringArray[],
         const int32 lengthArray[],
         int32 numStrings,
         float widthArray[]) const;

   void GetEscapements(const char charArray[],
         int32 numChars,
         float escapementArray[]) const;
   void GetEscapements(const char charArray[],
         int32 numChars, escapement_delta* delta,
         float escapementArray[]) const;
   void GetEscapements(const char charArray[],
         int32 numChars, escapement_delta* delta,
         BPoint escapementArray[]) const;
   void GetEscapements(const char charArray[],
         int32 numChars, escapement_delta* delta,
         BPoint escapementArray[],
         BPoint offsetArray[]) const;

   void GetEdges(const char charArray[],
         int32 numBytes,
         edge_info edgeArray[]) const;
   void GetHeight(font_height* height) const;

   void GetBoundingBoxesAsGlyphs(
         const char charArray[], int32 numChars,
         font_metric_mode mode,
         BRect boundingBoxArray[]) const;
   void GetBoundingBoxesAsString(
         const char charArray[], int32 numChars,
         font_metric_mode mode,
         escapement_delta* delta,
         BRect boundingBoxArray[]) const;
   void GetBoundingBoxesForStrings(
         const char* stringArray[],
         int32 numStrings, font_metric_mode mode,
         escapement_delta deltas[],
         BRect boundingBoxArray[]) const;

   void GetGlyphShapes(const char charArray[],
         int32 numChars,
         BShape* glyphShapeArray[]) const;

   void GetHasGlyphs(const char charArray[],
         int32 numChars,
         bool hasArray[]) const;

   BFont& operator=(const BFont& font);
   bool operator==(const BFont& font) const;
   bool operator!=(const BFont& font) const;

   void PrintToStream() const;

   status_t LoadFont(const char* path);
   status_t LoadFont(const area_id fontAreaID,
         size_t size = 0, size_t offset = 0);
   status_t UnloadFont();

private:
  friend void _init_global_fonts_();

   void _GetExtraFlags() const;
   void _GetBoundingBoxes(const char charArray[],
         int32 numChars, font_metric_mode mode,
         bool string_escapement,
         escapement_delta* delta,
         BRect boundingBoxArray[],
         bool asString) const;

private:
   uint16 fFamilyID;
   uint16 fStyleID;
   float fSize;
   float fShear;
   float fRotation;
   float fFalseBoldWidth;
   uint8 fSpacing;
   uint8 fEncoding;
   uint16 fFace;
   uint32 fFlags;
 mutable font_height fHeight;
 mutable uint32 fExtraFlags;

   uint32 _reserved[1];
};




extern const BFont* be_plain_font;
extern const BFont* be_bold_font;
extern const BFont* be_fixed_font;

int32 count_font_families(void);
status_t get_font_family(int32 index, font_family* name,
 uint32* flags = __null);

int32 count_font_styles(font_family name);
status_t get_font_style(font_family family, int32 index, font_style* name,
 uint32* flags = __null);
status_t get_font_style(font_family family, int32 index, font_style* name,
 uint16* face, uint32* flags = __null);
bool update_font_families(bool checkOnly);






unicode_block::unicode_block()
{
 fData[0] = fData[1] = 0LL;
}


unicode_block::unicode_block(uint64 block2, uint64 block1)
{
 fData[0] = block1;
 fData[1] = block2;
}


bool
unicode_block::Includes(const unicode_block& block) const
{
 return (fData[0] & block.fData[0]) == block.fData[0]
  && (fData[1] & block.fData[1]) == block.fData[1];
}


unicode_block
unicode_block::operator&(const unicode_block& block) const
{
 unicode_block result;
 result.fData[0] = fData[0] & block.fData[0];
 result.fData[1] = fData[1] & block.fData[1];

 return result;
}


unicode_block
unicode_block::operator|(const unicode_block& block) const
{
 unicode_block result;
 result.fData[0] = fData[0] | block.fData[0];
 result.fData[1] = fData[1] | block.fData[1];

 return result;
}


unicode_block&
unicode_block::operator=(const unicode_block& block)
{
 fData[0] = block.fData[0];
 fData[1] = block.fData[1];

 return *this;
}


bool
unicode_block::operator==(const unicode_block& block) const
{
 return fData[0] == block.fData[0] && fData[1] == block.fData[1];
}


bool
unicode_block::operator!=(const unicode_block& block) const
{
 return fData[0] != block.fData[0] || fData[1] != block.fData[1];
}



class BDataIO;
class BMessage;
class BRect;
class BGradient : public BArchivable {
public:
 enum Type {
  TYPE_LINEAR = 0,
  TYPE_RADIAL,
  TYPE_RADIAL_FOCUS,
  TYPE_DIAMOND,
  TYPE_CONIC,
  TYPE_NONE
 };

 struct ColorStop {
  ColorStop(const rgb_color c, float o);
  ColorStop(uint8 r, uint8 g, uint8 b, uint8 a, float o);
  ColorStop(const ColorStop& other);
  ColorStop();

  bool operator!=(const ColorStop& other) const;

  rgb_color color;
  float offset;
 };

public:
        BGradient();
        BGradient(const BGradient& other);
        BGradient(BMessage* archive);
 virtual ~BGradient();

   status_t Archive(BMessage* into,
         bool deep = true) const;

   BGradient& operator=(const BGradient& other);

   bool operator==(const BGradient& other) const;
   bool operator!=(const BGradient& other) const;
   bool ColorStopsAreEqual(
         const BGradient& other) const;

   void SetColorStops(const BGradient& other);

   int32 AddColor(const rgb_color& color,
         float offset);
   bool AddColorStop(const ColorStop& colorStop,
         int32 index);

   bool RemoveColor(int32 index);

   bool SetColorStop(int32 index,
         const ColorStop& colorStop);
   bool SetColor(int32 index, const rgb_color& color);
   bool SetOffset(int32 index, float offset);

   int32 CountColorStops() const;
   ColorStop* ColorStopAt(int32 index) const;
   ColorStop* ColorStopAtFast(int32 index) const;
   ColorStop* ColorStops() const;
   void SortColorStopsByOffset();

   Type GetType() const
         { return fType; }

   void MakeEmpty();

   status_t Flatten(BDataIO* stream) const;
 static status_t Unflatten(BGradient *&output, BDataIO* stream);

private:
 friend class BGradientLinear;
 friend class BGradientRadial;
 friend class BGradientRadialFocus;
 friend class BGradientDiamond;
 friend class BGradientConic;

   union {
    struct {
     float x1, y1, x2, y2;
    } linear;
    struct {
     float cx, cy, radius;
    } radial;
    struct {
     float cx, cy, fx, fy, radius;
    } radial_focus;
    struct {
     float cx, cy;
    } diamond;
    struct {
     float cx, cy, angle;
    } conic;
   } fData;

   BList fColorStops;
   Type fType;
};






enum {
 B_PRIMARY_MOUSE_BUTTON = (1 << ((1) - 1)),
 B_SECONDARY_MOUSE_BUTTON = (1 << ((2) - 1)),
 B_TERTIARY_MOUSE_BUTTON = (1 << ((3) - 1))
};


enum {
 B_ENTERED_VIEW = 0,
 B_INSIDE_VIEW,
 B_EXITED_VIEW,
 B_OUTSIDE_VIEW
};


enum {
 B_POINTER_EVENTS = 0x00000001,
 B_KEYBOARD_EVENTS = 0x00000002
};


enum {
 B_LOCK_WINDOW_FOCUS = 0x00000001,
 B_SUSPEND_VIEW_FOCUS = 0x00000002,
 B_NO_POINTER_HISTORY = 0x00000004,

 B_FULL_POINTER_HISTORY = 0x00000008



};

enum rect_tracking_style {
 B_TRACK_WHOLE_RECT,
 B_TRACK_RECT_CORNER
};


enum set_font_mask {
 B_FONT_FAMILY_AND_STYLE = 0x00000001,
 B_FONT_SIZE = 0x00000002,
 B_FONT_SHEAR = 0x00000004,
 B_FONT_ROTATION = 0x00000008,
 B_FONT_SPACING = 0x00000010,
 B_FONT_ENCODING = 0x00000020,
 B_FONT_FACE = 0x00000040,
 B_FONT_FLAGS = 0x00000080,
 B_FONT_FALSE_BOLD_WIDTH = 0x00000100,
 B_FONT_ALL = 0x000001FF
};

typedef enum {
 B_CURRENT_STATE_COORDINATES,
 B_PREVIOUS_STATE_COORDINATES,
 B_VIEW_COORDINATES,
 B_PARENT_VIEW_DRAW_COORDINATES,
 B_PARENT_VIEW_COORDINATES,
 B_WINDOW_COORDINATES,
 B_SCREEN_COORDINATES
} coordinate_space;


const uint32 B_FULL_UPDATE_ON_RESIZE = 0x80000000UL;
const uint32 _B_RESERVED1_ = 0x40000000UL;
const uint32 B_WILL_DRAW = 0x20000000UL;
const uint32 B_PULSE_NEEDED = 0x10000000UL;
const uint32 B_NAVIGABLE_JUMP = 0x08000000UL;
const uint32 B_FRAME_EVENTS = 0x04000000UL;
const uint32 B_NAVIGABLE = 0x02000000UL;
const uint32 B_SUBPIXEL_PRECISE = 0x01000000UL;
const uint32 B_DRAW_ON_CHILDREN = 0x00800000UL;
const uint32 B_INPUT_METHOD_AWARE = 0x00400000UL;
const uint32 B_SCROLL_VIEW_AWARE = 0x00200000UL;
const uint32 B_SUPPORTS_LAYOUT = 0x00100000UL;
const uint32 B_INVALIDATE_AFTER_LAYOUT = 0x00080000UL;
const uint32 B_TRANSPARENT_BACKGROUND = 0x00040000UL;



const uint32 _VIEW_TOP_ = 1UL;
const uint32 _VIEW_LEFT_ = 2UL;
const uint32 _VIEW_BOTTOM_ = 3UL;
const uint32 _VIEW_RIGHT_ = 4UL;
const uint32 _VIEW_CENTER_ = 5UL;



const uint32 B_FOLLOW_NONE = 0;
const uint32 B_FOLLOW_ALL_SIDES = (((_VIEW_TOP_) << 12) | ((_VIEW_LEFT_) << 8) | ((_VIEW_BOTTOM_) << 4) | (_VIEW_RIGHT_))
                                      ;
const uint32 B_FOLLOW_ALL = B_FOLLOW_ALL_SIDES;

const uint32 B_FOLLOW_LEFT = (((0) << 12) | ((_VIEW_LEFT_) << 8) | ((0) << 4) | (_VIEW_LEFT_));
const uint32 B_FOLLOW_RIGHT = (((0) << 12) | ((_VIEW_RIGHT_) << 8) | ((0) << 4) | (_VIEW_RIGHT_));
const uint32 B_FOLLOW_LEFT_RIGHT = (((0) << 12) | ((_VIEW_LEFT_) << 8) | ((0) << 4) | (_VIEW_RIGHT_));
const uint32 B_FOLLOW_H_CENTER = (((0) << 12) | ((_VIEW_CENTER_) << 8) | ((0) << 4) | (_VIEW_CENTER_));

const uint32 B_FOLLOW_TOP = (((_VIEW_TOP_) << 12) | ((0) << 8) | ((_VIEW_TOP_) << 4) | (0));
const uint32 B_FOLLOW_BOTTOM = (((_VIEW_BOTTOM_) << 12) | ((0) << 8) | ((_VIEW_BOTTOM_) << 4) | (0));
const uint32 B_FOLLOW_TOP_BOTTOM = (((_VIEW_TOP_) << 12) | ((0) << 8) | ((_VIEW_BOTTOM_) << 4) | (0));
const uint32 B_FOLLOW_V_CENTER = (((_VIEW_CENTER_) << 12) | ((0) << 8) | ((_VIEW_CENTER_) << 4) | (0));

const uint32 B_FOLLOW_LEFT_TOP = B_FOLLOW_TOP | B_FOLLOW_LEFT;

class BBitmap;
class BCursor;
class BLayout;
class BLayoutContext;
class BLayoutItem;
class BMessage;
class BPicture;
class BPolygon;
class BRegion;
class BScrollBar;
class BScrollView;
class BShape;
class BShelf;
class BString;
class BToolTip;
class BWindow;
struct _array_data_;
struct _array_hdr_;
struct overlay_restrictions;

namespace BPrivate {
 class ViewState;
};


class BView : public BHandler {
public:
        BView(const char* name, uint32 flags,
         BLayout* layout = __null);
        BView(BRect frame, const char* name,
         uint32 resizingMode, uint32 flags);
 virtual ~BView();

        BView(BMessage* archive);
 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* archive,
         bool deep = true) const;
 virtual status_t AllUnarchived(const BMessage* archive);
 virtual status_t AllArchived(BMessage* archive) const;

 virtual void AttachedToWindow();
 virtual void AllAttached();
 virtual void DetachedFromWindow();
 virtual void AllDetached();

 virtual void MessageReceived(BMessage* message);

   void AddChild(BView* child, BView* before = __null);
   bool AddChild(BLayoutItem* child);
   bool RemoveChild(BView* child);
   int32 CountChildren() const;
   BView* ChildAt(int32 index) const;
   BView* NextSibling() const;
   BView* PreviousSibling() const;
   bool RemoveSelf();

   BWindow* Window() const;

 virtual void Draw(BRect updateRect);
 virtual void MouseDown(BPoint where);
 virtual void MouseUp(BPoint where);
 virtual void MouseMoved(BPoint where, uint32 code,
         const BMessage* dragMessage);
 virtual void WindowActivated(bool active);
 virtual void KeyDown(const char* bytes, int32 numBytes);
 virtual void KeyUp(const char* bytes, int32 numBytes);
 virtual void Pulse();
 virtual void FrameMoved(BPoint newPosition);
 virtual void FrameResized(float newWidth, float newHeight);

 virtual void TargetedByScrollView(BScrollView* scrollView);
   void BeginRectTracking(BRect startRect,
         uint32 style = B_TRACK_WHOLE_RECT);
   void EndRectTracking();

   void GetMouse(BPoint* location, uint32* buttons,
         bool checkMessageQueue = true);

   void DragMessage(BMessage* message, BRect dragRect,
         BHandler* replyTo = __null);
   void DragMessage(BMessage* message, BBitmap* bitmap,
         BPoint offset, BHandler* replyTo = __null);
   void DragMessage(BMessage* message, BBitmap* bitmap,
         drawing_mode dragMode, BPoint offset,
         BHandler* replyTo = __null);

   BView* FindView(const char* name) const;
   BView* Parent() const;
   BRect Bounds() const;
   BRect Frame() const;
   void ConvertToScreen(BPoint* point) const;
   BPoint ConvertToScreen(BPoint point) const;
   void ConvertFromScreen(BPoint* point) const;
   BPoint ConvertFromScreen(BPoint point) const;
   void ConvertToScreen(BRect* rect) const;
   BRect ConvertToScreen(BRect rect) const;
   void ConvertFromScreen(BRect* rect) const;
   BRect ConvertFromScreen(BRect rect) const;
   void ConvertToParent(BPoint* point) const;
   BPoint ConvertToParent(BPoint point) const;
   void ConvertFromParent(BPoint* point) const;
   BPoint ConvertFromParent(BPoint point) const;
   void ConvertToParent(BRect* rect) const;
   BRect ConvertToParent(BRect rect) const;
   void ConvertFromParent(BRect* rect) const;
   BRect ConvertFromParent(BRect rect) const;
   BPoint LeftTop() const;

   void GetClippingRegion(BRegion* region) const;
 virtual void ConstrainClippingRegion(BRegion* region);
   void ClipToPicture(BPicture* picture,
         BPoint where = B_ORIGIN, bool sync = true);
   void ClipToInversePicture(BPicture* picture,
         BPoint where = B_ORIGIN, bool sync = true);

   void ClipToRect(BRect rect);
   void ClipToInverseRect(BRect rect);
   void ClipToShape(BShape* shape);
   void ClipToInverseShape(BShape* shape);

 virtual void SetDrawingMode(drawing_mode mode);
   drawing_mode DrawingMode() const;

   void SetBlendingMode(source_alpha srcAlpha,
         alpha_function alphaFunc);
   void GetBlendingMode(source_alpha* srcAlpha,
         alpha_function* alphaFunc) const;

 virtual void SetPenSize(float size);
   float PenSize() const;

   void SetViewCursor(const BCursor* cursor,
         bool sync = true);

   bool HasDefaultColors() const;
   bool HasSystemColors() const;
   void AdoptParentColors();
   void AdoptSystemColors();
   void AdoptViewColors(BView* view);

 virtual void SetViewColor(rgb_color color);
   void SetViewColor(uchar red, uchar green, uchar blue,
         uchar alpha = 255);
   rgb_color ViewColor() const;

   void SetViewUIColor(color_which which,
         float tint = B_NO_TINT);
   color_which ViewUIColor(float* tint = __null) const;

   void SetViewBitmap(const BBitmap* bitmap,
         BRect srcRect, BRect dstRect,
         uint32 followFlags = B_FOLLOW_LEFT_TOP,
         uint32 options = B_TILE_BITMAP);
   void SetViewBitmap(const BBitmap* bitmap,
         uint32 followFlags = B_FOLLOW_LEFT_TOP,
         uint32 options = B_TILE_BITMAP);
   void ClearViewBitmap();

   status_t SetViewOverlay(const BBitmap* overlay,
         BRect srcRect, BRect dstRect,
         rgb_color* colorKey,
         uint32 followFlags = B_FOLLOW_LEFT_TOP,
         uint32 options = 0);
   status_t SetViewOverlay(const BBitmap* overlay,
         rgb_color* colorKey,
         uint32 followFlags = B_FOLLOW_LEFT_TOP,
         uint32 options = 0);
   void ClearViewOverlay();

 virtual void SetHighColor(rgb_color color);
   void SetHighColor(uchar red, uchar green, uchar blue,
         uchar alpha = 255);
   rgb_color HighColor() const;

   void SetHighUIColor(color_which which,
         float tint = B_NO_TINT);
   color_which HighUIColor(float* tint = __null) const;

 virtual void SetLowColor(rgb_color color);
   void SetLowColor(uchar red, uchar green, uchar blue,
         uchar alpha = 255);
   rgb_color LowColor() const;

   void SetLowUIColor(color_which which,
         float tint = B_NO_TINT);
   color_which LowUIColor(float* tint = __null) const;

   void SetLineMode(cap_mode lineCap,
         join_mode lineJoin,
         float miterLimit = B_DEFAULT_MITER_LIMIT);
   join_mode LineJoinMode() const;
   cap_mode LineCapMode() const;
   float LineMiterLimit() const;

   void SetFillRule(int32 rule);
   int32 FillRule() const;

   void SetOrigin(BPoint where);
   void SetOrigin(float x, float y);
   BPoint Origin() const;




   void SetTransform(BAffineTransform transform);
   BAffineTransform Transform() const;
   void TranslateBy(double x, double y);
   void ScaleBy(double x, double y);
   void RotateBy(double angleRadians);

   BAffineTransform TransformTo(coordinate_space basis) const;

   void PushState();
   void PopState();

   void MovePenTo(BPoint pt);
   void MovePenTo(float x, float y);
   void MovePenBy(float x, float y);
   BPoint PenLocation() const;
   void StrokeLine(BPoint toPoint,
         ::pattern pattern = B_SOLID_HIGH);
   void StrokeLine(BPoint start, BPoint end,
         ::pattern pattern = B_SOLID_HIGH);
   void BeginLineArray(int32 count);
   void AddLine(BPoint start, BPoint end,
         rgb_color color);
   void EndLineArray();

   void StrokePolygon(const BPolygon* polygon,
         bool closed = true,
         ::pattern pattern = B_SOLID_HIGH);
   void StrokePolygon(const BPoint* pointArray,
         int32 numPoints, bool closed = true,
         ::pattern pattern = B_SOLID_HIGH);
   void StrokePolygon(const BPoint* pointArray,
         int32 numPoints, BRect bounds,
         bool closed = true,
         ::pattern pattern = B_SOLID_HIGH);
   void FillPolygon(const BPolygon* polygon,
         ::pattern pattern = B_SOLID_HIGH);
   void FillPolygon(const BPoint* pointArray,
         int32 numPoints,
         ::pattern pattern = B_SOLID_HIGH);
   void FillPolygon(const BPoint* pointArray,
         int32 numPoints, BRect bounds,
         ::pattern pattern = B_SOLID_HIGH);
   void FillPolygon(const BPolygon* polygon,
         const BGradient& gradient);
   void FillPolygon(const BPoint* pointArray,
         int32 numPoints, const BGradient& gradient);
   void FillPolygon(const BPoint* pointArray,
         int32 numPoints, BRect bounds,
         const BGradient& gradient);

   void StrokeTriangle(BPoint point1, BPoint point2,
         BPoint point3, BRect bounds,
         ::pattern pattern = B_SOLID_HIGH);
   void StrokeTriangle(BPoint point1, BPoint point2,
         BPoint point3,
         ::pattern pattern = B_SOLID_HIGH);
   void FillTriangle(BPoint point1, BPoint point2,
         BPoint point3,
         ::pattern pattern = B_SOLID_HIGH);
   void FillTriangle(BPoint point1, BPoint point2,
         BPoint point3, BRect bounds,
         ::pattern pattern = B_SOLID_HIGH);
   void FillTriangle(BPoint point1, BPoint point2,
         BPoint point3, const BGradient& gradient);
   void FillTriangle(BPoint point1, BPoint point2,
         BPoint point3, BRect bounds,
         const BGradient& gradient);

   void StrokeRect(BRect rect,
         ::pattern pattern = B_SOLID_HIGH);
   void FillRect(BRect rect,
         ::pattern pattern = B_SOLID_HIGH);
   void FillRect(BRect rect, const BGradient& gradient);
   void FillRegion(BRegion* rectegion,
         ::pattern pattern = B_SOLID_HIGH);
   void FillRegion(BRegion* rectegion,
         const BGradient& gradient);
   void InvertRect(BRect rect);

   void StrokeRoundRect(BRect rect, float xRadius,
         float yRadius,
         ::pattern pattern = B_SOLID_HIGH);
   void FillRoundRect(BRect rect, float xRadius,
         float yRadius,
         ::pattern pattern = B_SOLID_HIGH);
   void FillRoundRect(BRect rect, float xRadius,
         float yRadius, const BGradient& gradient);

   void StrokeEllipse(BPoint center, float xRadius,
         float yRadius,
         ::pattern pattern = B_SOLID_HIGH);
   void StrokeEllipse(BRect rect,
         ::pattern pattern = B_SOLID_HIGH);
   void FillEllipse(BPoint center, float xRadius,
         float yRadius,
         ::pattern pattern = B_SOLID_HIGH);
   void FillEllipse(BRect rect,
         ::pattern pattern = B_SOLID_HIGH);
   void FillEllipse(BPoint center, float xRadius,
         float yRadius, const BGradient& gradient);
   void FillEllipse(BRect rect,
         const BGradient& gradient);

   void StrokeArc(BPoint center, float xRadius,
         float yRadius, float startAngle,
         float arcAngle,
         ::pattern pattern = B_SOLID_HIGH);
   void StrokeArc(BRect rect, float startAngle,
         float arcAngle,
         ::pattern pattern = B_SOLID_HIGH);
   void FillArc(BPoint center, float xRadius,
         float yRadius, float startAngle,
         float arcAngle,
         ::pattern pattern = B_SOLID_HIGH);
   void FillArc(BRect rect, float startAngle,
         float arcAngle,
         ::pattern pattern = B_SOLID_HIGH);
   void FillArc(BPoint center, float xRadius,
         float yRadius, float startAngle,
         float arcAngle, const BGradient& gradient);
   void FillArc(BRect rect, float startAngle,
         float arcAngle, const BGradient& gradient);

   void StrokeBezier(BPoint* controlPoints,
         ::pattern pattern = B_SOLID_HIGH);
   void FillBezier(BPoint* controlPoints,
         ::pattern pattern = B_SOLID_HIGH);
   void FillBezier(BPoint* controlPoints,
         const BGradient& gradient);

   void StrokeShape(BShape* shape,
         ::pattern pattern = B_SOLID_HIGH);
   void FillShape(BShape* shape,
         ::pattern pattern = B_SOLID_HIGH);
   void FillShape(BShape* shape,
         const BGradient& gradient);

   void CopyBits(BRect src, BRect dst);

   void DrawBitmapAsync(const BBitmap* aBitmap,
         BRect bitmapRect, BRect viewRect,
         uint32 options);
   void DrawBitmapAsync(const BBitmap* aBitmap,
         BRect bitmapRect, BRect viewRect);
   void DrawBitmapAsync(const BBitmap* aBitmap,
         BRect viewRect);
   void DrawBitmapAsync(const BBitmap* aBitmap,
         BPoint where);
   void DrawBitmapAsync(const BBitmap* aBitmap);

   void DrawBitmap(const BBitmap* aBitmap,
         BRect bitmapRect, BRect viewRect,
         uint32 options);
   void DrawBitmap(const BBitmap* aBitmap,
         BRect bitmapRect, BRect viewRect);
   void DrawBitmap(const BBitmap* aBitmap,
         BRect viewRect);
   void DrawBitmap(const BBitmap* aBitmap,
         BPoint where);
   void DrawBitmap(const BBitmap* aBitmap);

   void DrawTiledBitmapAsync(const BBitmap* aBitmap,
         BRect viewRect, BPoint phase = B_ORIGIN);

   void DrawTiledBitmap(const BBitmap* aBitmap,
         BRect viewRect, BPoint phase = B_ORIGIN);

   void DrawChar(char aChar);
   void DrawChar(char aChar, BPoint location);
   void DrawString(const char* string,
         escapement_delta* delta = __null);
   void DrawString(const char* string,
         BPoint location,
         escapement_delta* delta = __null);
   void DrawString(const char* string, int32 length,
         escapement_delta* delta = __null);
   void DrawString(const char* string, int32 length,
         BPoint location,
         escapement_delta* delta = 0L);
   void DrawString(const char* string,
         const BPoint* locations,
         int32 locationCount);
   void DrawString(const char* string, int32 length,
         const BPoint* locations,
         int32 locationCount);

 virtual void SetFont(const BFont* font,
         uint32 mask = B_FONT_ALL);

   void GetFont(BFont* font) const;
   void TruncateString(BString* in_out, uint32 mode,
         float width) const;
   float StringWidth(const char* string) const;
   float StringWidth(const char* string,
         int32 length) const;
   void GetStringWidths(char* stringArray[],
         int32 lengthArray[], int32 numStrings,
         float widthArray[]) const;
   void SetFontSize(float size);
   void ForceFontAliasing(bool enable);
   void GetFontHeight(font_height* height) const;

   void Invalidate(BRect invalRect);
   void Invalidate(const BRegion* invalRegion);
   void Invalidate();
   void DelayedInvalidate(bigtime_t delay);
   void DelayedInvalidate(bigtime_t delay,
         BRect invalRect);

   void SetDiskMode(char* filename, long offset);

   void BeginPicture(BPicture* a_picture);
   void AppendToPicture(BPicture* a_picture);
   BPicture* EndPicture();

   void DrawPicture(const BPicture* a_picture);
   void DrawPicture(const BPicture* a_picture,
         BPoint where);
   void DrawPicture(const char* filename, long offset,
         BPoint where);
   void DrawPictureAsync(const BPicture* a_picture);
   void DrawPictureAsync(const BPicture* a_picture,
         BPoint where);
   void DrawPictureAsync(const char* filename,
         long offset, BPoint where);

   void BeginLayer(uint8 opacity);
   void EndLayer();

   status_t SetEventMask(uint32 mask, uint32 options = 0);
   uint32 EventMask();
   status_t SetMouseEventMask(uint32 mask,
         uint32 options = 0);

 virtual void SetFlags(uint32 flags);
   uint32 Flags() const;
 virtual void SetResizingMode(uint32 mode);
   uint32 ResizingMode() const;
   void MoveBy(float dh, float dv);
   void MoveTo(BPoint where);
   void MoveTo(float x, float y);
   void ResizeBy(float dh, float dv);
   void ResizeTo(float width, float height);
   void ResizeTo(BSize size);
   void ScrollBy(float dh, float dv);
   void ScrollTo(float x, float y);
 virtual void ScrollTo(BPoint where);
 virtual void MakeFocus(bool focus = true);
   bool IsFocus() const;

 virtual void Show();
 virtual void Hide();
   bool IsHidden() const;
   bool IsHidden(const BView* looking_from) const;

   void Flush() const;
   void Sync() const;

 virtual void GetPreferredSize(float* _width, float* _height);
 virtual void ResizeToPreferred();

   BScrollBar* ScrollBar(orientation direction) const;

 virtual BHandler* ResolveSpecifier(BMessage* message, int32 index,
         BMessage* specifier, int32 form,
         const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);

   bool IsPrinting() const;
   void SetScale(float scale) const;
   float Scale() const;


 virtual status_t Perform(perform_code code, void* data);

 virtual void DrawAfterChildren(BRect updateRect);



 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();
 virtual BAlignment LayoutAlignment();

   void SetExplicitMinSize(BSize size);
   void SetExplicitMaxSize(BSize size);
   void SetExplicitPreferredSize(BSize size);
   void SetExplicitSize(BSize size);
   void SetExplicitAlignment(BAlignment alignment);

   BSize ExplicitMinSize() const;
   BSize ExplicitMaxSize() const;
   BSize ExplicitPreferredSize() const;
   BAlignment ExplicitAlignment() const;

 virtual bool HasHeightForWidth();
 virtual void GetHeightForWidth(float width, float* min,
         float* max, float* preferred);

   void InvalidateLayout(bool descendants = false);
 virtual void SetLayout(BLayout* layout);
   BLayout* GetLayout() const;

   void EnableLayoutInvalidation();
   void DisableLayoutInvalidation();
   bool IsLayoutInvalidationDisabled();
   bool IsLayoutValid() const;
   void ResetLayoutInvalidation();

   BLayoutContext* LayoutContext() const;

   void Layout(bool force);
   void Relayout();

 class Private;

protected:
 virtual void LayoutInvalidated(bool descendants = false);
 virtual void DoLayout();

public:


   void SetToolTip(const char* text);
   void SetToolTip(BToolTip* tip);
   BToolTip* ToolTip() const;

   void ShowToolTip(BToolTip* tip = __null);
   void HideToolTip();

protected:
 virtual bool GetToolTipAt(BPoint point, BToolTip** _tip);

 virtual void LayoutChanged();

   status_t ScrollWithMouseWheelDelta(BScrollBar*, float);

private:
   void _Layout(bool force, BLayoutContext* context);
   void _LayoutLeft(BLayout* deleted);
   void _InvalidateParentLayout();

private:

 virtual void _ReservedView13();
 virtual void _ReservedView14();
 virtual void _ReservedView15();
 virtual void _ReservedView16();

        BView(const BView&);
   BView& operator=(const BView&);

private:
 struct LayoutData;

 friend class Private;
 friend class BBitmap;
 friend class BLayout;
 friend class BPrintJob;
 friend class BScrollBar;
 friend class BShelf;
 friend class BTabView;
 friend class BWindow;

   void _InitData(BRect frame, const char* name,
         uint32 resizingMode, uint32 flags);
   status_t _SetViewBitmap(const BBitmap* bitmap,
         BRect srcRect, BRect dstRect,
         uint32 followFlags, uint32 options);
   void _ClipToPicture(BPicture* picture, BPoint where,
         bool invert, bool sync);

   void _ClipToRect(BRect rect, bool inverse);
   void _ClipToShape(BShape* shape, bool inverse);

   bool _CheckOwnerLockAndSwitchCurrent() const;
   bool _CheckOwnerLock() const;
   void _CheckLockAndSwitchCurrent() const;
   void _CheckLock() const;
   void _SwitchServerCurrentView() const;

   void _SetOwner(BWindow* newOwner);
   void _RemoveCommArray();

   BShelf* _Shelf() const;
   void _SetShelf(BShelf* shelf);

   void _MoveTo(int32 x, int32 y);
   void _ResizeBy(int32 deltaWidth, int32 deltaHeight);
   void _ParentResizedBy(int32 deltaWidth,
         int32 deltaHeight);

   void _ConvertToScreen(BPoint* pt,
         bool checkLock) const;
   void _ConvertFromScreen(BPoint* pt,
         bool checkLock) const;

   void _ConvertToParent(BPoint* pt,
         bool checkLock) const;
   void _ConvertFromParent(BPoint* pt,
         bool checkLock) const;

   void _Activate(bool state);
   void _Attach();
   void _ColorsUpdated(BMessage* message);
   void _Detach();
   void _Draw(BRect screenUpdateRect);
   void _DrawAfterChildren(BRect screenUpdateRect);
   void _FontsUpdated(BMessage*);
   void _Pulse();

   void _UpdateStateForRemove();
   void _UpdatePattern(::pattern pattern);

   void _FlushIfNotInTransaction();

   bool _CreateSelf();
   bool _AddChildToList(BView* child,
         BView* before = __null);
   bool _RemoveChildFromList(BView* child);

   bool _AddChild(BView *child, BView *before);
   bool _RemoveSelf();
   void _RemoveLayoutItemsFromLayout(bool deleteItems);


   void _PrintToStream();
   void _PrintTree();

   int32 _unused_int1;

   uint32 fFlags;
   BPoint fParentOffset;
   BWindow* fOwner;
   BView* fParent;
   BView* fNextSibling;
   BView* fPreviousSibling;
   BView* fFirstChild;

   int16 fShowLevel;
   bool fTopLevelView;
   bool fNoISInteraction;
   BPicture* fCurrentPicture;
   _array_data_* fCommArray;

   BScrollBar* fVerScroller;
   BScrollBar* fHorScroller;
   bool fIsPrinting;
   bool fAttached;
   bool _unused_bool1;
   bool _unused_bool2;
   ::BPrivate::ViewState* fState;
   BRect fBounds;
   BShelf* fShelf;
   uint32 fEventMask;
   uint32 fEventOptions;
   uint32 fMouseEventOptions;

   LayoutData* fLayoutData;
   BToolTip* fToolTip;

   uint32 _reserved[6];
};





inline void
BView::ScrollTo(float x, float y)
{
 ScrollTo(BPoint(x, y));
}


inline void
BView::SetViewColor(uchar red, uchar green, uchar blue, uchar alpha)
{
 rgb_color color;
 color.red = red;
 color.green = green;
 color.blue = blue;
 color.alpha = alpha;
 SetViewColor(color);
}


inline void
BView::SetHighColor(uchar red, uchar green, uchar blue, uchar alpha)
{
 rgb_color color;
 color.red = red;
 color.green = green;
 color.blue = blue;
 color.alpha = alpha;
 SetHighColor(color);
}


inline void
BView::SetLowColor(uchar red, uchar green, uchar blue, uchar alpha)
{
 rgb_color color;
 color.red = red;
 color.green = green;
 color.blue = blue;
 color.alpha = alpha;
 SetLowColor(color);
}


class BButton;
class BMenuBar;
class BMenuItem;
class BMessage;
class BMessageRunner;
class BMessenger;
class BView;

namespace BPrivate {
 class PortLink;
};


enum window_type {
 B_UNTYPED_WINDOW = 0,
 B_TITLED_WINDOW = 1,
 B_MODAL_WINDOW = 3,
 B_DOCUMENT_WINDOW = 11,
 B_BORDERED_WINDOW = 20,
 B_FLOATING_WINDOW = 21
};

enum window_look {
 B_BORDERED_WINDOW_LOOK = 20,
 B_NO_BORDER_WINDOW_LOOK = 19,
 B_TITLED_WINDOW_LOOK = 1,
 B_DOCUMENT_WINDOW_LOOK = 11,
 B_MODAL_WINDOW_LOOK = 3,
 B_FLOATING_WINDOW_LOOK = 7
};

enum window_feel {
 B_NORMAL_WINDOW_FEEL = 0,
 B_MODAL_SUBSET_WINDOW_FEEL = 2,
 B_MODAL_APP_WINDOW_FEEL = 1,
 B_MODAL_ALL_WINDOW_FEEL = 3,
 B_FLOATING_SUBSET_WINDOW_FEEL = 5,
 B_FLOATING_APP_WINDOW_FEEL = 4,
 B_FLOATING_ALL_WINDOW_FEEL = 6
};

enum window_alignment {
 B_BYTE_ALIGNMENT = 0,
 B_PIXEL_ALIGNMENT = 1
};


enum {
 B_NOT_MOVABLE = 0x00000001,
 B_NOT_CLOSABLE = 0x00000020,
 B_NOT_ZOOMABLE = 0x00000040,
 B_NOT_MINIMIZABLE = 0x00004000,
 B_NOT_RESIZABLE = 0x00000002,
 B_NOT_H_RESIZABLE = 0x00000004,
 B_NOT_V_RESIZABLE = 0x00000008,
 B_AVOID_FRONT = 0x00000080,
 B_AVOID_FOCUS = 0x00002000,
 B_WILL_ACCEPT_FIRST_CLICK = 0x00000010,
 B_OUTLINE_RESIZE = 0x00001000,
 B_NO_WORKSPACE_ACTIVATION = 0x00000100,
 B_NOT_ANCHORED_ON_ACTIVATE = 0x00020000,
 B_ASYNCHRONOUS_CONTROLS = 0x00080000,
 B_QUIT_ON_WINDOW_CLOSE = 0x00100000,
 B_SAME_POSITION_IN_ALL_WORKSPACES = 0x00200000,
 B_AUTO_UPDATE_SIZE_LIMITS = 0x00400000,
 B_CLOSE_ON_ESCAPE = 0x00800000,
 B_NO_SERVER_SIDE_WINDOW_MODIFIERS = 0x00000200
};





enum {
 B_DO_NOT_RESIZE_TO_FIT = 0x0001,
 B_MOVE_IF_PARTIALLY_OFFSCREEN = 0x0002
};


class BWindow : public BLooper {
public:
        BWindow(BRect frame, const char* title,
         window_type type, uint32 flags,
         uint32 workspace = 0);
        BWindow(BRect frame, const char* title,
         window_look look, window_feel feel,
         uint32 flags, uint32 workspace
          = 0);
 virtual ~BWindow();

        BWindow(BMessage* archive);
 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* archive,
         bool deep = true) const;

 virtual void Quit();
   void Close() { Quit(); }

   void AddChild(BView* child, BView* before = __null);
   void AddChild(BLayoutItem* child);
   bool RemoveChild(BView* child);
   int32 CountChildren() const;
   BView* ChildAt(int32 index) const;

 virtual void DispatchMessage(BMessage* message,
         BHandler* handler);
 virtual void MessageReceived(BMessage* message);
 virtual void FrameMoved(BPoint newPosition);
 virtual void WorkspacesChanged(uint32 oldWorkspaces,
         uint32 newWorkspaces);
 virtual void WorkspaceActivated(int32 workspace,
         bool state);
 virtual void FrameResized(float newWidth, float newHeight);
 virtual void Minimize(bool minimize);
 virtual void Zoom(BPoint origin, float width, float height);
   void Zoom();
   void SetZoomLimits(float maxWidth, float maxHeight);
 virtual void ScreenChanged(BRect screenSize,
         color_space depth);

   void SetPulseRate(bigtime_t rate);
   bigtime_t PulseRate() const;

   void AddShortcut(uint32 key, uint32 modifiers,
         BMessage* message);
   void AddShortcut(uint32 key, uint32 modifiers,
         BMessage* message, BHandler* target);
   bool HasShortcut(uint32 key, uint32 modifiers);
   void RemoveShortcut(uint32 key, uint32 modifiers);

   void SetDefaultButton(BButton* button);
   BButton* DefaultButton() const;

 virtual void MenusBeginning();
 virtual void MenusEnded();

   bool NeedsUpdate() const;
   void UpdateIfNeeded();

   BView* FindView(const char* viewName) const;
   BView* FindView(BPoint) const;
   BView* CurrentFocus() const;

   void Activate(bool = true);
 virtual void WindowActivated(bool focus);

   void ConvertToScreen(BPoint* point) const;
   BPoint ConvertToScreen(BPoint point) const;
   void ConvertFromScreen(BPoint* point) const;
   BPoint ConvertFromScreen(BPoint point) const;
   void ConvertToScreen(BRect* rect) const;
   BRect ConvertToScreen(BRect rect) const;
   void ConvertFromScreen(BRect* rect) const;
   BRect ConvertFromScreen(BRect rect) const;

   void MoveBy(float dx, float dy);
   void MoveTo(BPoint);
   void MoveTo(float x, float y);
   void ResizeBy(float dx, float dy);
   void ResizeTo(float width, float height);
   void ResizeToPreferred();

   void CenterIn(const BRect& rect);
   void CenterOnScreen();
   void CenterOnScreen(screen_id id);
   void MoveOnScreen(uint32 flags = 0);

 virtual void Show();
 virtual void Hide();
   bool IsHidden() const;
   bool IsMinimized() const;

   void Flush() const;
   void Sync() const;

   status_t SendBehind(const BWindow* window);

   void DisableUpdates();
   void EnableUpdates();

   void BeginViewTransaction();


   void EndViewTransaction();


   bool InViewTransaction() const;

   BRect Bounds() const;
   BRect Frame() const;
   BRect DecoratorFrame() const;
   BSize Size() const;
   const char* Title() const;
   void SetTitle(const char* title);
   bool IsFront() const;
   bool IsActive() const;

   void SetKeyMenuBar(BMenuBar* bar);
   BMenuBar* KeyMenuBar() const;

   void SetSizeLimits(float minWidth, float maxWidth,
         float minHeight, float maxHeight);
   void GetSizeLimits(float* minWidth, float* maxWidth,
         float* minHeight, float* maxHeight);
   void UpdateSizeLimits();

   status_t SetDecoratorSettings(const BMessage& settings);
   status_t GetDecoratorSettings(BMessage* settings) const;

   uint32 Workspaces() const;
   void SetWorkspaces(uint32);

   BView* LastMouseMovedView() const;

 virtual BHandler* ResolveSpecifier(BMessage* message,
         int32 index, BMessage* specifier,
         int32 what, const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);

   status_t AddToSubset(BWindow* window);
   status_t RemoveFromSubset(BWindow* window);

 virtual status_t Perform(perform_code code, void* data);

   status_t SetType(window_type type);
   window_type Type() const;

   status_t SetLook(window_look look);
   window_look Look() const;

   status_t SetFeel(window_feel feel);
   window_feel Feel() const;

   status_t SetFlags(uint32);
   uint32 Flags() const;

   bool IsModal() const;
   bool IsFloating() const;

   status_t SetWindowAlignment(window_alignment mode,
         int32 h, int32 hOffset = 0,
         int32 width = 0, int32 widthOffset = 0,
         int32 v = 0, int32 vOffset = 0,
         int32 height = 0, int32 heightOffset = 0);
   status_t GetWindowAlignment(
         window_alignment* mode = __null,
         int32* h = __null, int32* hOffset = __null,
         int32* width = __null,
         int32* widthOffset = __null,
         int32* v = __null, int32* vOffset = __null,
         int32* height = __null,
         int32* heightOffset = __null) const;

 virtual bool QuitRequested();
 virtual thread_id Run();

 virtual void SetLayout(BLayout* layout);
   BLayout* GetLayout() const;

   void InvalidateLayout(bool descendants = false);
   void Layout(bool force);
   bool IsOffscreenWindow() const;
private:

 virtual void _ReservedWindow2();
 virtual void _ReservedWindow3();
 virtual void _ReservedWindow4();
 virtual void _ReservedWindow5();
 virtual void _ReservedWindow6();
 virtual void _ReservedWindow7();
 virtual void _ReservedWindow8();

        BWindow();
        BWindow(BWindow&);
   BWindow& operator=(BWindow&);

private:
 typedef BLooper inherited;
 struct unpack_cookie;
 class Shortcut;

 friend class BAlert;
 friend class BApplication;
 friend class BBitmap;
 friend class BView;
 friend class BMenuItem;
 friend class BWindowScreen;
 friend class BDirectWindow;
 friend class BFilePanel;
 friend class BWindowStack;

 friend void _set_menu_sem_(BWindow* w, sem_id sem);
 friend status_t _safe_get_server_token_(const BLooper*, int32*);

        BWindow(BRect frame, int32 bitmapToken);
   void _InitData(BRect frame, const char* title,
         window_look look, window_feel feel,
         uint32 flags, uint32 workspace,
         int32 bitmapToken = -1);

 virtual void task_looper();

   BPoint AlertPosition(const BRect& frame);
 virtual BMessage* ConvertToMessage(void* raw, int32 code);

   void AddShortcut(uint32 key, uint32 modifiers,
         BMenuItem* item);
   BHandler* _DetermineTarget(BMessage* message,
         BHandler* target);
   bool _IsFocusMessage(BMessage* message);
   bool _UnpackMessage(unpack_cookie& state,
         BMessage** _message, BHandler** _target,
         bool* _usePreferred);
   void _SanitizeMessage(BMessage* message,
         BHandler* target, bool usePreferred);
   bool _StealMouseMessage(BMessage* message,
         bool& deleteMessage);
   uint32 _TransitForMouseMoved(BView* view,
         BView* viewUnderMouse) const;

   bool InUpdate();
   void _DequeueAll();
   window_type _ComposeType(window_look look,
         window_feel feel) const;
   void _DecomposeType(window_type type,
         window_look* look,
         window_feel* feel) const;

   void SetIsFilePanel(bool yes);
   bool IsFilePanel() const;

   void _CreateTopView();
   void _AdoptResize();
   void _SetFocus(BView* focusView,
         bool notifyIputServer = false);
   void _SetName(const char* title);

   Shortcut* _FindShortcut(uint32 key, uint32 modifiers);
   BView* _FindView(BView* view, BPoint point) const;
   BView* _FindView(int32 token);
   BView* _LastViewChild(BView* parent);

   BView* _FindNextNavigable(BView* focus, uint32 flags);
   BView* _FindPreviousNavigable(BView* focus,
         uint32 flags);
   void _Switcher(int32 rawKey, uint32 modifiers,
         bool repeat);
   bool _HandleKeyDown(BMessage* event);
   bool _HandleUnmappedKeyDown(BMessage* event);
   void _KeyboardNavigation();

   void _GetDecoratorSize(float* _borderWidth,
         float* _tabHeight) const;
   void _SendShowOrHideMessage();
   void _PropagateMessageToChildViews(BMessage*);

private:
   char* fTitle;
   int32 _unused0;
   bool fInTransaction;
   bool fActive;
   short fShowLevel;
   uint32 fFlags;

   BView* fTopView;
   BView* fFocus;
   BView* fLastMouseMovedView;
   uint32 _unused1;
   BMenuBar* fKeyMenuBar;
   BButton* fDefaultButton;
   BList fShortcuts;
   int32 fTopViewToken;
   bool fUpdateRequested;
   bool fOffscreen;
   bool fIsFilePanel;
   bool _unused4;
   bigtime_t fPulseRate;
   bool _unused5;
   bool fMinimized;
   bool fNoQuitShortcut;
   bool _unused6;
   sem_id fMenuSem;
   float fMaxZoomHeight;
   float fMaxZoomWidth;
   float fMinHeight;
   float fMinWidth;
   float fMaxHeight;
   float fMaxWidth;
   BRect fFrame;
   window_look fLook;
   window_feel fFeel;
   int32 fLastViewToken;
   ::BPrivate::PortLink* fLink;
   BMessageRunner* fPulseRunner;
   BRect fPreviousFrame;

   uint32 _reserved[9];
};


class BFile;

class Preferences
{
public:
  Preferences();
  ~Preferences();

 void Update();

 uint32 GetToggleModMask() { return fToggleModMask; }
 uint32 GetClickKeyMask() { return fClickKeyMask; }

 void SetToggleModMask(uint32 mask) { fToggleModMask = mask; }
 void SetClickKeyMask(uint32 mask) { fClickKeyMask = mask; }

 uint32 GetDefaultToggleModMask() { return B_OPTION_KEY; }
 uint32 GetDefaultClickKeyMask() { return B_SPACE; }

 bool GetEnabled() { return fEnabled; }
 void SetEnabledToDefault() { fEnabled = true; }

 float GetAcceleration() { return fAcceleration; }
 void SetDefaultAcceleration() { fAcceleration = 20.0; }

 void SetToDefault();


 void Save();

 void SetEnabled(bool enabled) { fEnabled = enabled; }
 void SetAcceleration(float accel) {fAcceleration = accel; }

 BPoint WindowCorner() const { return fCorner; }
 void SetWindowCorner(BPoint corner);


protected:
 BFile* OpenFile(uint32 openMode);
 void Load();

private:
 uint32 fToggleModMask;
 uint32 fClickKeyMask;
 bool fEnabled;
 float fAcceleration;


 BPoint fCorner;

};


class BView;
class BSlider;
class BCheckBox;
class ModifierView;
class ModifierBox;

class SettingsWin : public BWindow
{
public:
     SettingsWin();
     ~SettingsWin();

 virtual void MessageReceived(BMessage* message);
 virtual bool QuitRequested();

private:
   void SendUpdateMessage();

   BView* fBGView;
 ModifierBox* fModBox;
 BCheckBox* fEnabled;
 BSlider* fAccelSlider;

 Preferences fPrefs;
};


class SettingsWin;

class SettingsApp : public BApplication
{
public:
     SettingsApp();
     ~SettingsApp();

 virtual void ReadyToRun();

private:
 SettingsWin* fWindow;
};


SettingsApp::SettingsApp()
 :
 BApplication("application/x-vnd.OscarL-KeyCursorSettings")
{
}


SettingsApp::~SettingsApp()
{
}


void
SettingsApp::ReadyToRun()
{
 fWindow = new SettingsWin();
 fWindow->Show();
}


int
main()
{
 SettingsApp app;
 app.Run();
 return 0;
}

class BBox : public BView {
 public:
       BBox(BRect frame, const char* name = __null,
        uint32 resizingMode = B_FOLLOW_LEFT_TOP,
        uint32 flags = B_WILL_DRAW | B_FRAME_EVENTS
         | B_NAVIGABLE_JUMP,
        border_style border = B_FANCY_BORDER);
       BBox(const char* name,
        uint32 flags = B_WILL_DRAW | B_FRAME_EVENTS
         | B_NAVIGABLE_JUMP,
        border_style border = B_FANCY_BORDER,
        BView* child = __null);
       BBox(border_style border, BView* child);
  virtual ~BBox();


       BBox(BMessage* archive);
  static BArchivable* Instantiate(BMessage* archive);
  virtual status_t Archive(BMessage* archive, bool deep = true) const;

  virtual void SetBorder(border_style border);
  border_style Border() const;

  float TopBorderOffset();
  BRect InnerFrame();

  void SetLabel(const char* string);
  status_t SetLabel(BView* viewLabel);

  const char* Label() const;
  BView* LabelView() const;

  virtual void Draw(BRect updateRect);
  virtual void AttachedToWindow();
  virtual void DetachedFromWindow();
  virtual void AllAttached();
  virtual void AllDetached();
  virtual void FrameResized(float width, float height);
  virtual void MessageReceived(BMessage* message);
  virtual void MouseDown(BPoint point);
  virtual void MouseUp(BPoint point);
  virtual void WindowActivated(bool active);
  virtual void MouseMoved(BPoint point, uint32 transit,
        const BMessage* dragMessage);
  virtual void FrameMoved(BPoint newLocation);

  virtual BHandler* ResolveSpecifier(BMessage* message,
        int32 index, BMessage* specifier,
        int32 what, const char* property);

  virtual void ResizeToPreferred();
  virtual void GetPreferredSize(float* _width, float* _height);
  virtual void MakeFocus(bool focused = true);
  virtual status_t GetSupportedSuites(BMessage* message);

  virtual status_t Perform(perform_code d, void* arg);

  virtual BSize MinSize();
  virtual BSize MaxSize();
  virtual BSize PreferredSize();
  virtual BAlignment LayoutAlignment();

 protected:
  virtual void LayoutInvalidated(bool descendants = false);
  virtual void DoLayout();

 private:
  struct LayoutData;

  virtual void _ReservedBox1();
  virtual void _ReservedBox2();

  BBox &operator=(const BBox &);

  void _InitObject(BMessage* data = __null);
  void _DrawPlain(BRect labelBox);
  void _DrawFancy(BRect labelBox);
  void _ClearLabel();

  BView* _Child() const;
  void _ValidateLayoutData();

  char* fLabel;
  BRect fBounds;
  border_style fStyle;
  BView* fLabelView;
  LayoutData* fLayoutData;
};
class BHandler;
class BLooper;
class BMessage;


class BInvoker {
public:
        BInvoker();
        BInvoker(BMessage* message,
         const BHandler* handler,
         const BLooper* looper = __null);
        BInvoker(BMessage* message, BMessenger target);
 virtual ~BInvoker();

 virtual status_t SetMessage(BMessage* message);
   BMessage* Message() const;
   uint32 Command() const;

 virtual status_t SetTarget(const BHandler* handler,
         const BLooper* looper = __null);
 virtual status_t SetTarget(BMessenger messenger);
   bool IsTargetLocal() const;
   BHandler* Target(BLooper** _looper = __null) const;
   BMessenger Messenger() const;

 virtual status_t SetHandlerForReply(BHandler* handler);
   BHandler* HandlerForReply() const;

 virtual status_t Invoke(BMessage* message = __null);
   status_t InvokeNotify(BMessage* message,
         uint32 kind = B_CONTROL_INVOKED);
   status_t SetTimeout(bigtime_t timeout);
   bigtime_t Timeout() const;

protected:
   uint32 InvokeKind(bool* _notify = __null);
   void BeginInvokeNotify(
         uint32 kind = B_CONTROL_INVOKED);
   void EndInvokeNotify();

private:
 virtual void _ReservedInvoker1();
 virtual void _ReservedInvoker2();
 virtual void _ReservedInvoker3();

        BInvoker(const BInvoker&);
   BInvoker& operator=(const BInvoker&);

   BMessage* fMessage;
   BMessenger fMessenger;
   BHandler* fReplyTo;
   bigtime_t fTimeout;
   uint32 fNotifyKind;
   uint32 _reserved[1];
};


class ModifierView;

class ModifierBox : public BInvoker, public BBox
{
public:
     ModifierBox(const char* label = 0, uint32 modifier = 0, uint32 button = 0);
     ~ModifierBox();

 virtual void MessageReceived(BMessage* message);
 virtual void AttachedToWindow();

   uint32 GetModifierMask();
   void SetModifierMask(uint32 mask);
   void SetDefaultModifierMask(uint32 mask);

   bool IsEnabled() { return fControlsEnabled; };
   void SetEnabled(bool enabled);

private:
 struct MaskListType
 {
  uint32 mask;
  const char* label;
 };

 static const MaskListType ModifierList[];
 ModifierView** fModifierViewList;
 uint32 fDefaultModifier;

 static const uint32 MODIFIER_CHANGED = 'modc';

 bool fControlsEnabled;
};

enum {
 B_CONTROL_OFF = 0,
 B_CONTROL_ON = 1,
 B_CONTROL_PARTIALLY_ON = 2
};

class BBitmap;
class BWindow;

namespace BPrivate {
 class BIcon;
};


class BControl : public BView, public BInvoker {
public:
        BControl(BRect frame, const char* name,
         const char* label, BMessage* message,
         uint32 resizingMode, uint32 flags);
        BControl(const char* name, const char* label,
         BMessage* message, uint32 flags);
 virtual ~BControl();

        BControl(BMessage* data);
 static BArchivable* Instantiate(BMessage* data);
 virtual status_t Archive(BMessage* data, bool deep = true) const;

 virtual void WindowActivated(bool active);

 virtual void AttachedToWindow();
 virtual void DetachedFromWindow();
 virtual void AllAttached();
 virtual void AllDetached();

 virtual void MessageReceived(BMessage* message);
 virtual void MakeFocus(bool focus = true);

 virtual void KeyDown(const char* bytes, int32 numBytes);
 virtual void MouseDown(BPoint where);
 virtual void MouseUp(BPoint where);
 virtual void MouseMoved(BPoint where, uint32 code,
         const BMessage* dragMessage);

 virtual void SetLabel(const char* string);
   const char* Label() const;

 virtual void SetValue(int32 value);
   int32 Value() const;

 virtual void SetEnabled(bool enabled);
   bool IsEnabled() const;

 virtual void GetPreferredSize(float* _width,
         float* _height);
 virtual void ResizeToPreferred();

 virtual status_t Invoke(BMessage* message = __null);
 virtual BHandler* ResolveSpecifier(BMessage* message,
         int32 index, BMessage* specifier,
         int32 what, const char* property);
 virtual status_t GetSupportedSuites(BMessage* message);

 virtual status_t Perform(perform_code d, void* arg);

 virtual status_t SetIcon(const BBitmap* bitmap,
         uint32 flags = 0);
   status_t SetIconBitmap(const BBitmap* bitmap,
         uint32 which, uint32 flags = 0);
   const BBitmap* IconBitmap(uint32 which) const;

protected:
   bool IsFocusChanging() const;
   bool IsTracking() const;
   void SetTracking(bool state);

   void SetValueNoUpdate(int32 value);

private:
   struct IconData;

private:
 virtual void _ReservedControl2();
 virtual void _ReservedControl3();
 virtual void _ReservedControl4();

   BControl& operator=(const BControl&);

   void InitData(BMessage* data = __null);

private:
   char* fLabel;
   int32 fValue;
   bool fEnabled;
   bool fFocusChanging;
   bool fTracking;
   bool fWantsNav;
   BPrivate::BIcon* fIcon;


   uint32 _reserved[2];



};


class BCheckBox : public BControl {
public:
        BCheckBox(BRect frame, const char* name,
         const char* label, BMessage* message,
         uint32 resizingMode = B_FOLLOW_LEFT_TOP,
         uint32 flags = B_WILL_DRAW | B_NAVIGABLE);
        BCheckBox(const char* name, const char* label,
         BMessage* message, uint32 flags
          = B_WILL_DRAW | B_NAVIGABLE);
        BCheckBox(const char* label,
         BMessage* message = __null);
        BCheckBox(BMessage* data);

 virtual ~BCheckBox();

 static BArchivable* Instantiate(BMessage* data);
 virtual status_t Archive(BMessage* data, bool deep = true) const;

 virtual void Draw(BRect updateRect);

 virtual void AttachedToWindow();
 virtual void DetachedFromWindow();
 virtual void AllAttached();
 virtual void AllDetached();

 virtual void FrameMoved(BPoint newPosition);
 virtual void FrameResized(float newWidth, float newHeight);
 virtual void WindowActivated(bool active);

 virtual void MessageReceived(BMessage* message);

 virtual void KeyDown(const char* bytes, int32 numBytes);

 virtual void MouseDown(BPoint where);
 virtual void MouseUp(BPoint where);
 virtual void MouseMoved(BPoint where, uint32 code,
         const BMessage* dragMessage);

 virtual void GetPreferredSize(float* _width,
         float* _height);
 virtual void ResizeToPreferred();

 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();
 virtual BAlignment LayoutAlignment();

 virtual void MakeFocus(bool focused = true);

 virtual void SetValue(int32 value);
 virtual status_t Invoke(BMessage* message = __null);

 virtual BHandler* ResolveSpecifier(BMessage* message,
         int32 index, BMessage* specifier,
         int32 what, const char* property);
 virtual status_t GetSupportedSuites(BMessage* message);

 virtual status_t Perform(perform_code code, void* data);

 virtual status_t SetIcon(const BBitmap* icon, uint32 flags = 0);

   bool IsPartialStateToOff() const;
   void SetPartialStateToOff(bool partialToOff);

protected:
 virtual void LayoutInvalidated(bool descendants = false);

private:

 virtual void _ReservedCheckBox1();
 virtual void _ReservedCheckBox2();
 virtual void _ReservedCheckBox3();

private:
 inline BRect _CheckBoxFrame(const font_height& fontHeight)
         const;
   BRect _CheckBoxFrame() const;
   BSize _ValidatePreferredSize();
   int32 _NextState() const;

private:

   BCheckBox& operator=(const BCheckBox&);

private:
   BSize fPreferredSize;
   bool fOutlined;
   bool fPartialToOff;
};


class ModifierView : public BCheckBox
{
public:
   ModifierView(uint32 modifierMask, const char* label, bool initialValue, BMessage* msg);
   ~ModifierView();

 uint32 GetMask();

private:
 uint32 fModifierMask;
};


extern "C" {
struct sched_param {
 int sched_priority;
};


extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);


}
struct __pthread_cleanup_handler {
 struct __pthread_cleanup_handler *previous;
 void (*function)(void *argument);
 void *argument;
};
extern "C" {
extern int pthread_mutex_destroy(pthread_mutex_t *mutex);
extern int pthread_mutex_getprioceiling(const pthread_mutex_t *mutex,
 int *_priorityCeiling);
extern int pthread_mutex_init(pthread_mutex_t *mutex,
 const pthread_mutexattr_t *attr);
extern int pthread_mutex_lock(pthread_mutex_t *mutex);
extern int pthread_mutex_setprioceiling(pthread_mutex_t *mutex,
 int newPriorityCeiling, int *_oldPriorityCeiling);
extern int pthread_mutex_clocklock(pthread_mutex_t *mutex,
 clockid_t clock_id, const struct timespec *abstime);
extern int pthread_mutex_timedlock(pthread_mutex_t *mutex,
 const struct timespec *abstime);
extern int pthread_mutex_trylock(pthread_mutex_t *mutex);
extern int pthread_mutex_unlock(pthread_mutex_t *mutex);


extern int pthread_mutexattr_destroy(pthread_mutexattr_t *mutexAttr);
extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *mutexAttr,
 int *_priorityCeiling);
extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *mutexAttr,
 int *_protocol);
extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *mutexAttr,
 int *_processShared);
extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *mutexAttr,
 int *_type);
extern int pthread_mutexattr_init(pthread_mutexattr_t *mutexAttr);
extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *mutexAttr,
 int priorityCeiling);
extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *mutexAttr,
 int protocol);
extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *mutexAttr,
 int processShared);
extern int pthread_mutexattr_settype(pthread_mutexattr_t *mutexAttr, int type);


extern int pthread_barrier_init(pthread_barrier_t *barrier,
 const pthread_barrierattr_t *attr, unsigned count);
extern int pthread_barrier_destroy(pthread_barrier_t *barrier);
extern int pthread_barrier_wait(pthread_barrier_t *barrier);


extern int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);
extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *attr,
 int *shared);
extern int pthread_barrierattr_init(pthread_barrierattr_t *attr);
extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *attr,
 int shared);


extern int pthread_cond_destroy(pthread_cond_t *cond);
extern int pthread_cond_init(pthread_cond_t *cond,
 const pthread_condattr_t *attr);
extern int pthread_cond_broadcast(pthread_cond_t *cond);
extern int pthread_cond_signal(pthread_cond_t *cond);
extern int pthread_cond_clockwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
 clockid_t clock_id, const struct timespec *abstime);
extern int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
 const struct timespec *abstime);
extern int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);


extern int pthread_condattr_destroy(pthread_condattr_t *condAttr);
extern int pthread_condattr_init(pthread_condattr_t *condAttr);
extern int pthread_condattr_getpshared(const pthread_condattr_t *condAttr,
 int *processShared);
extern int pthread_condattr_setpshared(pthread_condattr_t *condAttr,
 int processShared);
extern int pthread_condattr_getclock(const pthread_condattr_t *condAttr,
 clockid_t *clockID);
extern int pthread_condattr_setclock(pthread_condattr_t *condAttr,
 clockid_t clockID);


extern int pthread_rwlock_init(pthread_rwlock_t *lock,
 const pthread_rwlockattr_t *attr);
extern int pthread_rwlock_destroy(pthread_rwlock_t *lock);
extern int pthread_rwlock_rdlock(pthread_rwlock_t *lock);
extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *lock);
extern int pthread_rwlock_clockrdlock(pthread_rwlock_t* rwlock,
 clockid_t clock_id, const struct timespec* abstime);
extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *lock,
 const struct timespec *abstime);
extern int pthread_rwlock_wrlock(pthread_rwlock_t *lock);
extern int pthread_rwlock_trywrlock(pthread_rwlock_t *lock);
extern int pthread_rwlock_clockwrlock(pthread_rwlock_t* rwlock,
 clockid_t clock_id, const struct timespec* abstime);
extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *lock,
 const struct timespec *abstime);
extern int pthread_rwlock_unlock(pthread_rwlock_t *lock);


extern int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *attr,
 int *shared);
extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr,
 int shared);


extern int pthread_spin_init(pthread_spinlock_t* spinlock, int pshared);
extern int pthread_spin_destroy(pthread_spinlock_t* spinlock);
extern int pthread_spin_lock(pthread_spinlock_t* spinlock);
extern int pthread_spin_trylock(pthread_spinlock_t* spinlock);
extern int pthread_spin_unlock(pthread_spinlock_t* spinlock);


extern int pthread_atfork(void (*prepare)(void), void (*parent)(void),
 void (*child)(void));
extern int pthread_once(pthread_once_t *once_control,
 void (*init_routine)(void));


extern int pthread_attr_destroy(pthread_attr_t *attr);
extern int pthread_attr_init(pthread_attr_t *attr);
extern int pthread_attr_getdetachstate(const pthread_attr_t *attr,
 int *detachstate);
extern int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
extern int pthread_attr_getstacksize(const pthread_attr_t *attr,
 size_t *stacksize);
extern int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
extern int pthread_attr_getscope(const pthread_attr_t *attr,
 int *contentionScope);
extern int pthread_attr_setscope(pthread_attr_t *attr, int contentionScope);

extern int pthread_attr_getschedparam(const pthread_attr_t *attr,
 struct sched_param *param);
extern int pthread_attr_setschedparam(pthread_attr_t *attr,
 const struct sched_param *param);

extern int pthread_attr_getguardsize(const pthread_attr_t *attr,
 size_t *guardsize);
extern int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);

extern int pthread_attr_getstack(const pthread_attr_t *attr,
 void **stackaddr, size_t *stacksize);
extern int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr,
 size_t stacksize);
extern int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
 void *(*start_routine)(void*), void *arg);
extern int pthread_detach(pthread_t thread);
extern int pthread_equal(pthread_t t1, pthread_t t2);
extern void pthread_exit(void *value_ptr) __attribute__ ((noreturn));
extern int pthread_join(pthread_t thread, void **_value);
extern pthread_t pthread_self(void);
extern int pthread_getconcurrency(void);
extern int pthread_setconcurrency(int newLevel);

extern int pthread_cancel(pthread_t thread);
extern int pthread_setcancelstate(int state, int *_oldState);
extern int pthread_setcanceltype(int type, int *_oldType);
extern void pthread_testcancel(void);

extern int pthread_getschedparam(pthread_t thread, int *policy,
 struct sched_param *param);
extern int pthread_setschedparam(pthread_t thread, int policy,
 const struct sched_param *param);


extern int pthread_key_create(pthread_key_t *key,
 void (*destructorFunc)(void*));
extern int pthread_key_delete(pthread_key_t key);
extern void *pthread_getspecific(pthread_key_t key);
extern int pthread_setspecific(pthread_key_t key, const void *value);


extern void __pthread_cleanup_push_handler(
 struct __pthread_cleanup_handler *handler);
extern struct __pthread_cleanup_handler *__pthread_cleanup_pop_handler(void);


}







extern "C" {



extern int pthread_attr_get_np(pthread_t thread, pthread_attr_t* attr);



}





class BBitmap;
class BCatalog;
class BCollator;
class BCountry;
class BDateFormat;
class BFormattingConventions;
class BLanguage;
class BLocale;
class BMessage;
class BTimeZone;


namespace BPrivate {
 struct LocaleRosterData;
}


enum {
 B_LOCALE_CHANGED = '_LCC',
};


class BLocaleRoster {

public:
        ~BLocaleRoster();

 static BLocaleRoster* Default();

   status_t GetDefaultTimeZone(BTimeZone* timezone) const;

   status_t GetLanguage(const char* languageCode,
         BLanguage** _language) const;

   status_t GetPreferredLanguages(BMessage* message) const;

   status_t GetAvailableLanguages(BMessage* message) const;
   status_t GetAvailableCountries(
         BMessage* timeZones) const;
   status_t GetAvailableTimeZones(
         BMessage* timeZones) const;
   status_t GetAvailableTimeZonesWithRegionInfo(
         BMessage* timeZonesWithRegonInfo) const;
   status_t GetAvailableTimeZonesForCountry(
         BMessage* message,
         const char* countryCode) const;

   status_t GetFlagIconForCountry(BBitmap* flagIcon,
         const char* countryCode);
   status_t GetFlagIconForLanguage(BBitmap* flagIcon,
         const char* languageCode);

   status_t GetAvailableCatalogs(BMessage* message,
         const char* sigPattern = __null,
         const char* langPattern = __null,
         int32 fingerprint = 0) const;


   status_t Refresh();



   BCatalog* GetCatalog();



   const BLocale* GetDefaultLocale() const;

   bool IsFilesystemTranslationPreferred() const;

   status_t GetLocalizedFileName(BString& localizedFileName,
         const entry_ref& ref,
         bool traverse = false);

 static const char* kCatLangAttr;
 static const char* kCatSigAttr;
 static const char* kCatFingerprintAttr;

 static const char* kEmbeddedCatAttr;
 static int32 kEmbeddedCatResId;

protected:
        BLocaleRoster();

protected:
   BPrivate::LocaleRosterData* fData;

private:
 static BCatalog* _GetCatalog(BCatalog* catalog,
         int32* catalogInitStatus);

   status_t _PrepareCatalogEntry(const entry_ref& ref,
         BString& signature, BString& context,
         BString& string, bool traverse);

};
class BLocker {
public:
        BLocker();
        BLocker(const char* name);
        BLocker(bool benaphoreStyle);
        BLocker(const char* name, bool benaphoreStyle);
 virtual ~BLocker();

   status_t InitCheck() const;

   bool Lock();
   status_t LockWithTimeout(bigtime_t timeout);
   void Unlock();

   thread_id LockingThread() const;
   bool IsLocked() const;
   int32 CountLocks() const;
   int32 CountLockRequests() const;
   sem_id Sem() const;

private:
        BLocker(const char* name, bool benaphoreStyle,
         bool _ignored);
        BLocker(const BLocker&);
        BLocker& operator=(const BLocker&);
   void InitLocker(const char* name,
         bool benaphoreStyle);
   bool AcquireLock(bigtime_t timeout, status_t* error);

   int32 fBenaphoreCount;
   sem_id fSemaphoreID;
   thread_id fLockOwner;
   int32 fRecursiveCount;

   int32 _reserved[4];
};




class BCatalogData;
class BLocale;
class BMessage;
struct entry_ref;


class BCatalog {
public:
        BCatalog();
        BCatalog(const entry_ref& catalogOwner,
         const char* language = __null,
         uint32 fingerprint = 0);
        BCatalog(const char* signature,
         const char* language = __null);

 virtual ~BCatalog();

   const char* GetString(const char* string,
         const char* context = __null,
         const char* comment = __null);
   const char* GetString(uint32 id);

   status_t GetData(const char* name, BMessage* msg);
   status_t GetData(uint32 id, BMessage* msg);

   status_t GetSignature(BString* signature);
   status_t GetLanguage(BString* language);
   status_t GetFingerprint(uint32* fingerprint);

   status_t SetTo(const entry_ref& catalogOwner,
         const char* language = __null,
         uint32 fingerprint = 0);
   status_t SetTo(const char* signature,
         const char* language = __null);

   status_t InitCheck() const;
   int32 CountItems() const;

protected:
        BCatalog(const BCatalog&);
   const BCatalog& operator= (const BCatalog&);


   BCatalogData* fCatalogData;
 mutable BLocker fLock;

private:
 friend class BLocale;
 friend status_t get_add_on_catalog(BCatalog*, const char*);
};







class BLayout;
class BView;


class BLayoutItem : public BArchivable {
public:
        BLayoutItem();
        BLayoutItem(BMessage* from);
 virtual ~BLayoutItem();

   BLayout* Layout() const;
   bool RemoveSelf();

 virtual BSize MinSize() = 0;
 virtual BSize MaxSize() = 0;
 virtual BSize PreferredSize() = 0;
 virtual BAlignment Alignment() = 0;

 virtual void SetExplicitMinSize(BSize size) = 0;
 virtual void SetExplicitMaxSize(BSize size) = 0;
 virtual void SetExplicitPreferredSize(BSize size) = 0;
   void SetExplicitSize(BSize size);
 virtual void SetExplicitAlignment(BAlignment alignment) = 0;

 virtual bool IsVisible() = 0;
 virtual void SetVisible(bool visible) = 0;

 virtual BRect Frame() = 0;
 virtual void SetFrame(BRect frame) = 0;

 virtual bool HasHeightForWidth();
 virtual void GetHeightForWidth(float width, float* min,
         float* max, float* preferred);

 virtual BView* View();

 virtual void InvalidateLayout(bool children = false);
 virtual void Relayout(bool immediate = false);

   void* LayoutData() const;
   void SetLayoutData(void* data);

   void AlignInFrame(BRect frame);

 virtual status_t Archive(BMessage* into, bool deep = true) const;

 virtual status_t Perform(perform_code d, void* arg);

protected:

 virtual status_t AllArchived(BMessage* into) const;
 virtual status_t AllUnarchived(const BMessage* from);


 virtual void LayoutInvalidated(bool children);

 virtual void AttachedToLayout();
 virtual void DetachedFromLayout(BLayout* layout);

 virtual void AncestorVisibilityChanged(bool shown);

private:
   void SetLayout(BLayout* layout);

 virtual void _ReservedLayoutItem1();
 virtual void _ReservedLayoutItem2();
 virtual void _ReservedLayoutItem3();
 virtual void _ReservedLayoutItem4();
 virtual void _ReservedLayoutItem5();
 virtual void _ReservedLayoutItem6();
 virtual void _ReservedLayoutItem7();
 virtual void _ReservedLayoutItem8();
 virtual void _ReservedLayoutItem9();
 virtual void _ReservedLayoutItem10();


        BLayoutItem(const BLayoutItem&);
   void operator =(const BLayoutItem&);

   friend class BLayout;

   BLayout* fLayout;
   void* fLayoutData;

   uint32 _reserved[5];
};




class BLayoutContext;
class BLayoutItem;
class BView;


class BLayout : public BLayoutItem {
public:
        BLayout();
        BLayout(BMessage* archive);
 virtual ~BLayout();

   BView* Owner() const;
   BView* TargetView() const;
 virtual BView* View();


 virtual BLayoutItem* AddView(BView* child);
 virtual BLayoutItem* AddView(int32 index, BView* child);

 virtual bool AddItem(BLayoutItem* item);
 virtual bool AddItem(int32 index, BLayoutItem* item);

 virtual bool RemoveView(BView* child);
 virtual bool RemoveItem(BLayoutItem* item);
 virtual BLayoutItem* RemoveItem(int32 index);

   BLayoutItem* ItemAt(int32 index) const;
   int32 CountItems() const;
   int32 IndexOfItem(const BLayoutItem* item) const;
   int32 IndexOfView(BView* child) const;

   bool AncestorsVisible() const;



 virtual void InvalidateLayout(bool children = false);
 virtual void Relayout(bool immediate = false);

   void RequireLayout();
   bool IsValid();
   void EnableLayoutInvalidation();
   void DisableLayoutInvalidation();

   void LayoutItems(bool force = false);
   BRect LayoutArea();
   BLayoutContext* LayoutContext() const;

 virtual status_t Archive(BMessage* into, bool deep = true) const;

 virtual status_t Perform(perform_code d, void* arg);

protected:

 virtual status_t AllArchived(BMessage* archive) const;
 virtual status_t AllUnarchived(const BMessage* from);

 virtual status_t ItemArchived(BMessage* into, BLayoutItem* item,
         int32 index) const;
 virtual status_t ItemUnarchived(const BMessage* from,
         BLayoutItem* item, int32 index);

 virtual bool ItemAdded(BLayoutItem* item, int32 atIndex);
 virtual void ItemRemoved(BLayoutItem* item, int32 fromIndex);
 virtual void LayoutInvalidated(bool children);
 virtual void DoLayout() = 0;
 virtual void OwnerChanged(BView* was);


 virtual void AttachedToLayout();
 virtual void DetachedFromLayout(BLayout* layout);
 virtual void AncestorVisibilityChanged(bool shown);


   void VisibilityChanged(bool show);

   void ResetLayoutInvalidation();

private:


 virtual void _ReservedLayout1();
 virtual void _ReservedLayout2();
 virtual void _ReservedLayout3();
 virtual void _ReservedLayout4();
 virtual void _ReservedLayout5();
 virtual void _ReservedLayout6();
 virtual void _ReservedLayout7();
 virtual void _ReservedLayout8();
 virtual void _ReservedLayout9();
 virtual void _ReservedLayout10();


        BLayout(const BLayout&);
   void operator =(const BLayout&);

   friend class BView;

   void SetOwner(BView* owner);
   void SetTarget(BView* target);

   void _LayoutWithinContext(bool force,
         BLayoutContext* context);

   uint32 fState;
   bool fAncestorsVisible;
   int32 fInvalidationDisabled;
   BLayoutContext* fContext;
   BView* fOwner;
   BView* fTarget;
   BList fItems;
   BList fNestedLayouts;

   uint32 _reserved[10];
};


class BAbstractLayout : public BLayout {
public:
        BAbstractLayout();
        BAbstractLayout(BMessage* from);
 virtual ~BAbstractLayout();

 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();
 virtual BAlignment Alignment();

 virtual void SetExplicitMinSize(BSize size);
 virtual void SetExplicitMaxSize(BSize size);
 virtual void SetExplicitPreferredSize(BSize size);
 virtual void SetExplicitAlignment(BAlignment alignment);

 virtual BSize BaseMinSize();
 virtual BSize BaseMaxSize();
 virtual BSize BasePreferredSize();
 virtual BAlignment BaseAlignment();

 virtual BRect Frame();
 virtual void SetFrame(BRect frame);

 virtual bool IsVisible();
 virtual void SetVisible(bool visible);

 virtual status_t Archive(BMessage* into, bool deep = true) const;

 virtual status_t Perform(perform_code d, void* arg);

protected:

 virtual status_t AllArchived(BMessage* archive) const;
 virtual status_t AllUnarchived(const BMessage* from);

 virtual status_t ItemArchived(BMessage* into, BLayoutItem* item,
         int32 index) const;
 virtual status_t ItemUnarchived(const BMessage* from,
         BLayoutItem* item, int32 index);

 virtual bool ItemAdded(BLayoutItem* item, int32 atIndex);
 virtual void ItemRemoved(BLayoutItem* item, int32 fromIndex);
 virtual void LayoutInvalidated(bool children);
 virtual void OwnerChanged(BView* was);


 virtual void AttachedToLayout();
 virtual void DetachedFromLayout(BLayout* layout);
 virtual void AncestorVisibilityChanged(bool shown);

private:
 virtual void _ReservedAbstractLayout1();
 virtual void _ReservedAbstractLayout2();
 virtual void _ReservedAbstractLayout3();
 virtual void _ReservedAbstractLayout4();
 virtual void _ReservedAbstractLayout5();
 virtual void _ReservedAbstractLayout6();
 virtual void _ReservedAbstractLayout7();
 virtual void _ReservedAbstractLayout8();
 virtual void _ReservedAbstractLayout9();
 virtual void _ReservedAbstractLayout10();


        BAbstractLayout(const BAbstractLayout&);
   void operator =(const BAbstractLayout&);

   struct Proxy;
   struct ViewProxy;
   struct DataProxy;

   Proxy* fExplicitData;
   uint32 _reserved[4];
};


class BCardLayout : public BAbstractLayout {
public:
        BCardLayout();
        BCardLayout(BMessage* from);
 virtual ~BCardLayout();

   BLayoutItem* VisibleItem() const;
   int32 VisibleIndex() const;
   void SetVisibleItem(int32 index);
   void SetVisibleItem(BLayoutItem* item);

 virtual BSize BaseMinSize();
 virtual BSize BaseMaxSize();
 virtual BSize BasePreferredSize();
 virtual BAlignment BaseAlignment();

 virtual bool HasHeightForWidth();
 virtual void GetHeightForWidth(float width, float* min,
         float* max, float* preferred);

 virtual status_t Archive(BMessage* into, bool deep = true) const;
 static BArchivable* Instantiate(BMessage* from);

 virtual status_t Perform(perform_code d, void* arg);

protected:
 virtual status_t AllArchived(BMessage* archive) const;
 virtual status_t AllUnarchived(const BMessage* from);

 virtual status_t ItemArchived(BMessage* into, BLayoutItem* item,
         int32 index) const;
 virtual status_t ItemUnarchived(const BMessage* from,
         BLayoutItem* item, int32 index);

 virtual void LayoutInvalidated(bool children = false);
 virtual void DoLayout();
 virtual bool ItemAdded(BLayoutItem* item, int32 atIndex);
 virtual void ItemRemoved(BLayoutItem* item, int32 fromIndex);

private:

   void _ValidateMinMax();


 virtual void _ReservedCardLayout1();
 virtual void _ReservedCardLayout2();
 virtual void _ReservedCardLayout3();
 virtual void _ReservedCardLayout4();
 virtual void _ReservedCardLayout5();
 virtual void _ReservedCardLayout6();
 virtual void _ReservedCardLayout7();
 virtual void _ReservedCardLayout8();
 virtual void _ReservedCardLayout9();
 virtual void _ReservedCardLayout10();


        BCardLayout(const BCardLayout&);
   void operator =(const BCardLayout&);

   BSize fMin;
   BSize fMax;
   BSize fPreferred;
   BLayoutItem* fVisibleItem;
   bool fMinMaxValid;

   uint32 _reserved[5];
};
class BCardLayout;

class BCardView : public BView {
public:
        BCardView();
        BCardView(const char* name);
        BCardView(BMessage* from);
 virtual ~BCardView();

 virtual void SetLayout(BLayout* layout);
   BCardLayout* CardLayout() const;

 static BArchivable* Instantiate(BMessage* from);

 virtual status_t Perform(perform_code d, void* arg);

private:


 virtual void _ReservedCardView1();
 virtual void _ReservedCardView2();
 virtual void _ReservedCardView3();
 virtual void _ReservedCardView4();
 virtual void _ReservedCardView5();
 virtual void _ReservedCardView6();
 virtual void _ReservedCardView7();
 virtual void _ReservedCardView8();
 virtual void _ReservedCardView9();
 virtual void _ReservedCardView10();


        BCardView(const BCardView&);
   void operator =(const BCardView&);

   uint32 _reserved[10];
};
class BLayoutContext;


class BTwoDimensionalLayout : public BAbstractLayout {
public:
        BTwoDimensionalLayout();
        BTwoDimensionalLayout(BMessage* from);
 virtual ~BTwoDimensionalLayout();

   void SetInsets(float left, float top, float right,
         float bottom);
   void SetInsets(float horizontal, float vertical);
   void SetInsets(float insets);
   void GetInsets(float* left, float* top, float* right,
         float* bottom) const;

   void AlignLayoutWith(BTwoDimensionalLayout* other,
         orientation orientation);

 virtual BSize BaseMinSize();
 virtual BSize BaseMaxSize();
 virtual BSize BasePreferredSize();
 virtual BAlignment BaseAlignment();

 virtual bool HasHeightForWidth();
 virtual void GetHeightForWidth(float width, float* min,
         float* max, float* preferred);

 virtual void SetFrame(BRect frame);

 virtual status_t Archive(BMessage* into, bool deep = true) const;

 virtual status_t Perform(perform_code d, void* arg);

protected:
   struct ColumnRowConstraints {
    float weight;
    float min;
    float max;
   };

   struct Dimensions {
    int32 x;
    int32 y;
    int32 width;
    int32 height;
   };

 virtual status_t AllArchived(BMessage* into) const;
 virtual status_t AllUnarchived(const BMessage* from);

 virtual status_t ItemArchived(BMessage* into, BLayoutItem* item,
         int32 index) const;
 virtual status_t ItemUnarchived(const BMessage* from,
         BLayoutItem* item, int32 index);
 virtual void LayoutInvalidated(bool children = false);

 virtual void DoLayout();

   BSize AddInsets(BSize size);
   void AddInsets(float* minHeight, float* maxHeight,
         float* preferredHeight);
   BSize SubtractInsets(BSize size);

 virtual void PrepareItems(orientation orientation);
 virtual bool HasMultiColumnItems();
 virtual bool HasMultiRowItems();

 virtual int32 InternalCountColumns() = 0;
 virtual int32 InternalCountRows() = 0;
 virtual void GetColumnRowConstraints(
         orientation orientation,
         int32 index,
         ColumnRowConstraints* constraints) = 0;
 virtual void GetItemDimensions(BLayoutItem* item,
         Dimensions* dimensions) = 0;

private:
   class CompoundLayouter;
   class LocalLayouter;
   class VerticalCompoundLayouter;

   friend class LocalLayouter;

   void _ValidateMinMax();

protected:
   float fLeftInset;
   float fRightInset;
   float fTopInset;
   float fBottomInset;
   float fHSpacing;
   float fVSpacing;

private:


 virtual void _ReservedTwoDimensionalLayout1();
 virtual void _ReservedTwoDimensionalLayout2();
 virtual void _ReservedTwoDimensionalLayout3();
 virtual void _ReservedTwoDimensionalLayout4();
 virtual void _ReservedTwoDimensionalLayout5();
 virtual void _ReservedTwoDimensionalLayout6();
 virtual void _ReservedTwoDimensionalLayout7();
 virtual void _ReservedTwoDimensionalLayout8();
 virtual void _ReservedTwoDimensionalLayout9();
 virtual void _ReservedTwoDimensionalLayout10();


        BTwoDimensionalLayout(
         const BTwoDimensionalLayout&);
   void operator =(const BTwoDimensionalLayout&);

   LocalLayouter* fLocalLayouter;

   uint32 _reserved[5];
};


class BGridLayout : public BTwoDimensionalLayout {
public:
        BGridLayout(float horizontal
          = B_USE_DEFAULT_SPACING,
         float vertical = B_USE_DEFAULT_SPACING);
        BGridLayout(BMessage* from);
 virtual ~BGridLayout();

   int32 CountColumns() const;
   int32 CountRows() const;

   float HorizontalSpacing() const;
   float VerticalSpacing() const;

   void SetHorizontalSpacing(float spacing);
   void SetVerticalSpacing(float spacing);
   void SetSpacing(float horizontal, float vertical);

   float ColumnWeight(int32 column) const;
   void SetColumnWeight(int32 column, float weight);

   float MinColumnWidth(int32 column) const;
   void SetMinColumnWidth(int32 column, float width);

   float MaxColumnWidth(int32 column) const;
   void SetMaxColumnWidth(int32 column, float width);

   float RowWeight(int32 row) const;
   void SetRowWeight(int32 row, float weight);

   float MinRowHeight(int row) const;
   void SetMinRowHeight(int32 row, float height);

   float MaxRowHeight(int32 row) const;
   void SetMaxRowHeight(int32 row, float height);

   BLayoutItem* ItemAt(int32 column, int32 row) const;

 virtual BLayoutItem* AddView(BView* child);
 virtual BLayoutItem* AddView(int32 index, BView* child);
 virtual BLayoutItem* AddView(BView* child, int32 column, int32 row,
         int32 columnCount = 1, int32 rowCount = 1);

 virtual bool AddItem(BLayoutItem* item);
 virtual bool AddItem(int32 index, BLayoutItem* item);
 virtual bool AddItem(BLayoutItem* item, int32 column,
         int32 row, int32 columnCount = 1,
         int32 rowCount = 1);

 virtual status_t Archive(BMessage* into, bool deep = true) const;
 static BArchivable* Instantiate(BMessage* from);

 virtual status_t Perform(perform_code d, void* arg);

protected:
 virtual status_t AllArchived(BMessage* into) const;
 virtual status_t AllUnarchived(const BMessage* from);
 virtual status_t ItemArchived(BMessage* into,
         BLayoutItem* item, int32 index) const;
 virtual status_t ItemUnarchived(const BMessage* from,
         BLayoutItem* item, int32 index);

 virtual bool ItemAdded(BLayoutItem* item, int32 atIndex);
 virtual void ItemRemoved(BLayoutItem* item, int32 fromIndex);

 virtual bool HasMultiColumnItems();
 virtual bool HasMultiRowItems();

 virtual int32 InternalCountColumns();
 virtual int32 InternalCountRows();
 virtual void GetColumnRowConstraints(
         orientation orientation,
         int32 index,
         ColumnRowConstraints* constraints);
 virtual void GetItemDimensions(BLayoutItem* item,
         Dimensions* dimensions);
private:
   class DummyLayoutItem;
   class RowInfoArray;
   struct ItemLayoutData;

   bool _IsGridCellEmpty(int32 column, int32 row);
   bool _AreGridCellsEmpty(int32 column, int32 row,
         int32 columnCount, int32 rowCount);

   bool _InsertItemIntoGrid(BLayoutItem* item);
   bool _ResizeGrid(int32 columnCount, int32 rowCount);

   ItemLayoutData* _LayoutDataForItem(BLayoutItem* item) const;

private:


 virtual void _ReservedGridLayout1();
 virtual void _ReservedGridLayout2();
 virtual void _ReservedGridLayout3();
 virtual void _ReservedGridLayout4();
 virtual void _ReservedGridLayout5();
 virtual void _ReservedGridLayout6();
 virtual void _ReservedGridLayout7();
 virtual void _ReservedGridLayout8();
 virtual void _ReservedGridLayout9();
 virtual void _ReservedGridLayout10();


        BGridLayout(const BGridLayout&);
   void operator =(const BGridLayout&);

   BLayoutItem*** fGrid;
   int32 fColumnCount;
   int32 fRowCount;

   RowInfoArray* fRowInfos;
   RowInfoArray* fColumnInfos;

   int32 fMultiColumnItems;
   int32 fMultiRowItems;

   uint32 _reserved[5];
};
class BGridView : public BView {
public:
        BGridView(float horizontal
          = B_USE_DEFAULT_SPACING,
         float vertical = B_USE_DEFAULT_SPACING);
        BGridView(const char* name,
         float horizontal = B_USE_DEFAULT_SPACING,
         float vertical = B_USE_DEFAULT_SPACING);
        BGridView(BMessage* from);
 virtual ~BGridView();

 virtual void SetLayout(BLayout* layout);
   BGridLayout* GridLayout() const;

 static BArchivable* Instantiate(BMessage* from);

 virtual status_t Perform(perform_code d, void* arg);

private:


 virtual void _ReservedGridView1();
 virtual void _ReservedGridView2();
 virtual void _ReservedGridView3();
 virtual void _ReservedGridView4();
 virtual void _ReservedGridView5();
 virtual void _ReservedGridView6();
 virtual void _ReservedGridView7();
 virtual void _ReservedGridView8();
 virtual void _ReservedGridView9();
 virtual void _ReservedGridView10();


        BGridView(const BGridView&);
   void operator =(const BGridView&);

   uint32 _reserved[2];
};
class BGroupLayout : public BTwoDimensionalLayout {
public:
        BGroupLayout(orientation orientation,
         float spacing = B_USE_DEFAULT_SPACING);
        BGroupLayout(BMessage* from);
 virtual ~BGroupLayout();

   float Spacing() const;
   void SetSpacing(float spacing);

   orientation Orientation() const;
   void SetOrientation(orientation orientation);

   float ItemWeight(int32 index) const;
   void SetItemWeight(int32 index, float weight);

 virtual BLayoutItem* AddView(BView* child);
 virtual BLayoutItem* AddView(int32 index, BView* child);
 virtual BLayoutItem* AddView(BView* child, float weight);
 virtual BLayoutItem* AddView(int32 index, BView* child,
         float weight);

 virtual bool AddItem(BLayoutItem* item);
 virtual bool AddItem(int32 index, BLayoutItem* item);
 virtual bool AddItem(BLayoutItem* item, float weight);
 virtual bool AddItem(int32 index, BLayoutItem* item,
         float weight);

 virtual status_t Archive(BMessage* into, bool deep = true) const;
 static BArchivable* Instantiate(BMessage* from);

 virtual status_t Perform(perform_code d, void* arg);

protected:
 virtual status_t AllArchived(BMessage* into) const;
 virtual status_t AllUnarchived(const BMessage* from);
 virtual status_t ItemArchived(BMessage* into, BLayoutItem* item,
         int32 index) const;
 virtual status_t ItemUnarchived(const BMessage* from,
         BLayoutItem* item, int32 index);

 virtual bool ItemAdded(BLayoutItem* item, int32 atIndex);
 virtual void ItemRemoved(BLayoutItem* item, int32 fromIndex);

 virtual void PrepareItems(orientation orientation);

 virtual int32 InternalCountColumns();
 virtual int32 InternalCountRows();
 virtual void GetColumnRowConstraints(
         orientation orientation,
         int32 index,
         ColumnRowConstraints* constraints);
 virtual void GetItemDimensions(BLayoutItem* item,
         Dimensions* dimensions);

private:


 virtual void _ReservedGroupLayout1();
 virtual void _ReservedGroupLayout2();
 virtual void _ReservedGroupLayout3();
 virtual void _ReservedGroupLayout4();
 virtual void _ReservedGroupLayout5();
 virtual void _ReservedGroupLayout6();
 virtual void _ReservedGroupLayout7();
 virtual void _ReservedGroupLayout8();
 virtual void _ReservedGroupLayout9();
 virtual void _ReservedGroupLayout10();


        BGroupLayout(const BGroupLayout&);
   void operator =(const BGroupLayout&);

   struct ItemLayoutData;

   ItemLayoutData* _LayoutDataForItem(BLayoutItem* item) const;

   orientation fOrientation;
   BList fVisibleItems;

   uint32 _reserved[5];
};
class BGroupView : public BView {
public:
        BGroupView(
         orientation orientation = B_HORIZONTAL,
         float spacing = B_USE_DEFAULT_SPACING);
        BGroupView(const char* name,
         orientation orientation = B_HORIZONTAL,
         float spacing = B_USE_DEFAULT_SPACING);
        BGroupView(BMessage* from);
 virtual ~BGroupView();

 virtual void SetLayout(BLayout* layout);
   BGroupLayout* GroupLayout() const;

 static BArchivable* Instantiate(BMessage* from);

 virtual status_t Perform(perform_code d, void* arg);

private:


 virtual void _ReservedGroupView1();
 virtual void _ReservedGroupView2();
 virtual void _ReservedGroupView3();
 virtual void _ReservedGroupView4();
 virtual void _ReservedGroupView5();
 virtual void _ReservedGroupView6();
 virtual void _ReservedGroupView7();
 virtual void _ReservedGroupView8();
 virtual void _ReservedGroupView9();
 virtual void _ReservedGroupView10();


        BGroupView(const BGroupView&);
   void operator =(const BGroupView&);

   uint32 _reserved[2];
};
class BMenu;
class BMenuBar;
class BMenuItem;


namespace BPrivate {
 class BMenuWindow;
 class ExtraMenuData;
 class TriggerList;
 class MenuPrivate;
}

enum menu_layout {
 B_ITEMS_IN_ROW = 0,
 B_ITEMS_IN_COLUMN,
 B_ITEMS_IN_MATRIX
};

struct menu_info {
 float font_size;
 font_family f_family;
 font_style f_style;
 rgb_color background_color;
 int32 separator;
 bool click_to_open;
 bool triggers_always_shown;
};

status_t get_menu_info(menu_info* info);
status_t set_menu_info(menu_info* info);

typedef bool (*menu_tracking_hook)(BMenu* menu, void* state);


class BMenu : public BView {
public:
        BMenu(const char* name,
         menu_layout layout = B_ITEMS_IN_COLUMN);
        BMenu(const char* name, float width,
         float height);
        BMenu(BMessage* archive);

 virtual ~BMenu();

 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* archive,
         bool deep = true) const;

 virtual void AttachedToWindow();
 virtual void DetachedFromWindow();
 virtual void AllAttached();
 virtual void AllDetached();

 virtual void Draw(BRect updateRect);

 virtual void MessageReceived(BMessage* message);
 virtual void KeyDown(const char* bytes, int32 numBytes);

 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();
 virtual void GetPreferredSize(float* _width,
         float* _height);
 virtual void ResizeToPreferred();
 virtual void DoLayout();
 virtual void FrameMoved(BPoint where);
 virtual void FrameResized(float width, float height);

   void InvalidateLayout();

 virtual void MakeFocus(bool focus = true);

   bool AddItem(BMenuItem* item);
   bool AddItem(BMenuItem* item, int32 index);
   bool AddItem(BMenuItem* item, BRect frame);
   bool AddItem(BMenu* menu);
   bool AddItem(BMenu* menu, int32 index);
   bool AddItem(BMenu* menu, BRect frame);
   bool AddList(BList* list, int32 index);

   bool AddSeparatorItem();

   bool RemoveItem(BMenuItem* item);
   BMenuItem* RemoveItem(int32 index);
   bool RemoveItems(int32 index, int32 count,
         bool deleteItems = false);
   bool RemoveItem(BMenu* menu);

   BMenuItem* ItemAt(int32 index) const;
   BMenu* SubmenuAt(int32 index) const;
   int32 CountItems() const;
   int32 IndexOf(BMenuItem* item) const;
   int32 IndexOf(BMenu* menu) const;
   BMenuItem* FindItem(uint32 command) const;
   BMenuItem* FindItem(const char* name) const;

 virtual status_t SetTargetForItems(BHandler* target);
 virtual status_t SetTargetForItems(BMessenger messenger);
 virtual void SetEnabled(bool enable);
 virtual void SetRadioMode(bool on);
 virtual void SetTriggersEnabled(bool enable);
 virtual void SetMaxContentWidth(float maxWidth);

   void SetLabelFromMarked(bool on);
   bool IsLabelFromMarked();
   bool IsEnabled() const;
   bool IsRadioMode() const;
   bool AreTriggersEnabled() const;
   bool IsRedrawAfterSticky() const;
   float MaxContentWidth() const;

   BMenuItem* FindMarked();
   int32 FindMarkedIndex();

   BMenu* Supermenu() const;
   BMenuItem* Superitem() const;


 virtual BHandler* ResolveSpecifier(BMessage* message,
         int32 index, BMessage* specifier,
         int32 form, const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);

 virtual status_t Perform(perform_code d, void* arg);

protected:
        BMenu(BRect frame, const char* name,
         uint32 resizeMask, uint32 flags,
         menu_layout layout, bool resizeToFit);

 virtual void LayoutInvalidated(bool descendants);

 virtual BPoint ScreenLocation();

   void SetItemMargins(float left, float top,
         float right, float bottom);
   void GetItemMargins(float* _left, float* _top,
         float* _right, float* _bottom) const;

   menu_layout Layout() const;

 virtual void Show();
   void Show(bool selectFirstItem);
   void Hide();
   BMenuItem* Track(bool startOpened = false,
         BRect* specialRect = __null);

public:
 enum add_state {
  B_INITIAL_ADD,
  B_PROCESSING,
  B_ABORT
 };
 virtual bool AddDynamicItem(add_state state);
 virtual void DrawBackground(BRect updateRect);

   void SetTrackingHook(menu_tracking_hook hook,
         void* state);


   void SortItems(int (*compare)(const BMenuItem*,
         const BMenuItem*));
   bool SwapItems(int32 indexA, int32 indexB);
   bool MoveItem(int32 indexFrom, int32 indexTo);

private:
 friend class BMenuBar;
 friend class BSeparatorItem;
 friend class BPrivate::MenuPrivate;
 friend status_t _init_interface_kit_();
 friend status_t set_menu_info(menu_info* info);
 friend status_t get_menu_info(menu_info* info);

 struct LayoutData;

 virtual void _ReservedMenu3();
 virtual void _ReservedMenu4();
 virtual void _ReservedMenu5();
 virtual void _ReservedMenu6();

   BMenu& operator=(const BMenu& other);

   void _InitData(BMessage* archive);
   bool _Show(bool selectFirstItem = false,
         bool keyDown = false);
   void _Hide();
   BMenuItem* _Track(int* action, long start = -1);
   void _ScriptReceived(BMessage* message);
   void _ItemScriptReceived(BMessage* message,
         BMenuItem* item);
   status_t _ResolveItemSpecifier(const BMessage& specifier,
         int32 what, BMenuItem*& item,
         int32 *index = __null);
   status_t _InsertItemAtSpecifier(
         const BMessage& specifier, int32 what,
         BMenuItem* item);

   void _UpdateNavigationArea(BPoint position,
         BRect& navAreaRectAbove,
         BRect& navAreaBelow);

   void _UpdateStateOpenSelect(BMenuItem* item,
         BPoint position, BRect& navAreaRectAbove,
         BRect& navAreaBelow,
         bigtime_t& selectedTime,
         bigtime_t& navigationAreaTime);
   void _UpdateStateClose(BMenuItem* item,
         const BPoint& where,
         const uint32& buttons);

   bool _AddItem(BMenuItem* item, int32 index);
   bool _RemoveItems(int32 index, int32 count,
         BMenuItem* item, bool deleteItems = false);
   bool _RelayoutIfNeeded();
   void _LayoutItems(int32 index);
   BSize _ValidatePreferredSize();
   void _ComputeLayout(int32 index, bool bestFit,
         bool moveItems, float* width,
         float* height);
   void _ComputeColumnLayout(int32 index, bool bestFit,
         bool moveItems, BRect* override, BRect& outRect);
   void _ComputeRowLayout(int32 index, bool bestFit,
         bool moveItems, BRect& outRect);
   void _ComputeMatrixLayout(BRect& outRect);

   BRect _CalcFrame(BPoint where, bool* scrollOn);

protected:
   void DrawItems(BRect updateRect);

private:
   bool _OverSuper(BPoint loc);
   bool _OverSubmenu(BMenuItem* item, BPoint loc);
   BPrivate::BMenuWindow* _MenuWindow();
   void _DeleteMenuWindow();
   BMenuItem* _HitTestItems(BPoint where,
         BPoint slop = B_ORIGIN) const;
   BRect _Superbounds() const;
   void _CacheFontInfo();

   void _ItemMarked(BMenuItem* item);
   void _Install(BWindow* target);
   void _Uninstall();
   void _SelectItem(BMenuItem* item,
         bool showSubmenu = true,
         bool selectFirstItem = false,
         bool keyDown = false);
   bool _SelectNextItem(BMenuItem* item, bool forward);
   BMenuItem* _NextItem(BMenuItem* item, bool forward) const;
   void _SetIgnoreHidden(bool ignoreHidden)
         { fIgnoreHidden = ignoreHidden; }
   void _SetStickyMode(bool on);
   bool _IsStickyMode() const;


   void _GetShiftKey(uint32 &value) const;
   void _GetControlKey(uint32 &value) const;
   void _GetCommandKey(uint32 &value) const;
   void _GetOptionKey(uint32 &value) const;
   void _GetMenuKey(uint32 &value) const;

   void _CalcTriggers();
   bool _ChooseTrigger(const char* title, int32& index,
         uint32& trigger,
         BPrivate::TriggerList& triggers);
   void _UpdateWindowViewSize(const bool &updatePosition);
   bool _AddDynamicItems(bool keyDown = false);
   bool _OkToProceed(BMenuItem* item,
         bool keyDown = false);

   bool _CustomTrackingWantsToQuit();

   int _State(BMenuItem** _item = __null) const;
   void _InvokeItem(BMenuItem* item, bool now = false);
   void _QuitTracking(bool onlyThis = true);

 static menu_info sMenuInfo;



 static uint32 sShiftKey;
 static uint32 sControlKey;
 static uint32 sOptionKey;
 static uint32 sCommandKey;
 static uint32 sMenuKey;

   BMenuItem* fChosenItem;
   BList fItems;
   BRect fPad;
   BMenuItem* fSelected;
   BPrivate::BMenuWindow* fCachedMenuWindow;
   BMenu* fSuper;
   BMenuItem* fSuperitem;
   BRect fSuperbounds;
   float fAscent;
   float fDescent;
   float fFontHeight;
   uint32 fState;
   menu_layout fLayout;
   BRect* fExtraRect;
   float fMaxContentWidth;
   BPoint* fInitMatrixSize;
   BPrivate::ExtraMenuData* fExtraMenuData;

   LayoutData* fLayoutData;

   int32 _reserved;

   char fTrigger;
   bool fResizeToFit;
   bool fUseCachedMenuLayout;
   bool fEnabled;
   bool fDynamicName;
   bool fRadioMode;
   bool fTrackNewBounds;
   bool fStickyMode;
   bool fIgnoreHidden;
   bool fTriggerEnabled;
   bool fHasSubmenus;
   bool fAttachAborted;
};
class BMenuBar;
class BMessageFilter;


class BMenuField : public BView {
public:
        BMenuField(BRect frame, const char* name,
         const char* label, BMenu* menu,
         uint32 resizingMode = B_FOLLOW_LEFT_TOP,
         uint32 flags = B_WILL_DRAW | B_NAVIGABLE);
        BMenuField(BRect frame, const char* name,
         const char* label, BMenu* menu,
         bool fixed_size,
         uint32 resizingMode = B_FOLLOW_LEFT_TOP,
         uint32 flags = B_WILL_DRAW | B_NAVIGABLE);
        BMenuField(const char* name,
         const char* label, BMenu* menu,
         uint32 flags = B_WILL_DRAW | B_NAVIGABLE);
        BMenuField(const char* name,
         const char* label, BMenu* menu,
         bool fixed_size,
         uint32 flags = B_WILL_DRAW | B_NAVIGABLE);
        BMenuField(const char* label, BMenu* menu,
         uint32 flags = B_WILL_DRAW | B_NAVIGABLE);
        BMenuField(BMessage* data);
 virtual ~BMenuField();

 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* archive,
         bool deep = true) const;

 virtual void Draw(BRect updateRect);
 virtual void AttachedToWindow();
 virtual void AllAttached();
 virtual void MouseDown(BPoint where);
 virtual void KeyDown(const char* bytes, int32 numBytes);
 virtual void MakeFocus(bool focused);
 virtual void MessageReceived(BMessage* message);
 virtual void WindowActivated(bool active);
 virtual void MouseUp(BPoint where);
 virtual void MouseMoved(BPoint where, uint32 transit,
         const BMessage* dragMessage);
 virtual void DetachedFromWindow();
 virtual void AllDetached();
 virtual void FrameMoved(BPoint where);
 virtual void FrameResized(float width, float height);

   BMenu* Menu() const;
   BMenuBar* MenuBar() const;
   BMenuItem* MenuItem() const;

 virtual void SetLabel(const char* label);
   const char* Label() const;

 virtual void SetEnabled(bool on);
   bool IsEnabled() const;

 virtual void SetAlignment(alignment label);
   alignment Alignment() const;
 virtual void SetDivider(float position);
   float Divider() const;

   void ShowPopUpMarker();
   void HidePopUpMarker();

 virtual BHandler* ResolveSpecifier(BMessage* message,
         int32 index, BMessage* specifier,
         int32 form, const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);

 virtual void ResizeToPreferred();
 virtual void GetPreferredSize(float* width, float* height);

 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();

   BLayoutItem* CreateLabelLayoutItem();
   BLayoutItem* CreateMenuBarLayoutItem();

 virtual status_t Perform(perform_code d, void* arg);

protected:
 virtual status_t AllArchived(BMessage* into) const;
 virtual status_t AllUnarchived(const BMessage* from);

 virtual void LayoutInvalidated(bool descendants);
 virtual void DoLayout();

private:

 virtual void _ReservedMenuField1();
 virtual void _ReservedMenuField2();
 virtual void _ReservedMenuField3();


   BMenuField& operator=(const BMenuField& other);

private:
 class LabelLayoutItem;
 class MenuBarLayoutItem;
 struct LayoutData;

 friend class _BMCMenuBar_;
 friend class LabelLayoutItem;
 friend class MenuBarLayoutItem;
 friend struct LayoutData;

   void _DrawLabel(BRect updateRect);
   void _DrawMenuBar(BRect updateRect);

   void InitObject(const char* label);
   void InitObject2();

 static void InitMenu(BMenu* menu);

   int32 _MenuTask();
 static int32 _thread_entry(void *arg);

   void _UpdateFrame();
   void _InitMenuBar(BMenu* menu,
         BRect frame, bool fixedSize);
   void _InitMenuBar(const BMessage* archive);
   void _AddMenu(BMenu* menu);

   void _ValidateLayoutData();
   float _MenuBarOffset() const;
   float _MenuBarWidth() const;

private:
   char* fLabel;
   BMenu* fMenu;
   BMenuBar* fMenuBar;
   alignment fAlign;
   float fDivider;
   bool fEnabled;
   bool fFixedSizeMB;
   thread_id fMenuTaskID;

   LayoutData* fLayoutData;
   BMessageFilter* fMouseDownFilter;

   uint32 _reserved[2];
};
class BMessage;
class BWindow;

namespace BPrivate {
 class MenuItemPrivate;
}

class BMenuItem : public BArchivable, public BInvoker {
public:
        BMenuItem(const char* label, BMessage* message,
         char shortcut = 0, uint32 modifiers = 0);
        BMenuItem(BMenu* menu,
         BMessage* message = __null);
        BMenuItem(BMessage* data);
 virtual ~BMenuItem();

 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* archive,
         bool deep = true) const;

 virtual void SetLabel(const char* name);
 virtual void SetEnabled(bool enable);
 virtual void SetMarked(bool mark);
 virtual void SetTrigger(char trigger);
 virtual void SetShortcut(char shortcut, uint32 modifiers);

   const char* Label() const;
   bool IsEnabled() const;
   bool IsMarked() const;
   char Trigger() const;
   char Shortcut(uint32* _modifiers = __null) const;

   BMenu* Submenu() const;
   BMenu* Menu() const;
   BRect Frame() const;

protected:
 virtual void GetContentSize(float* _width, float* _height);
 virtual void TruncateLabel(float maxWidth, char* newLabel);
 virtual void DrawContent();
 virtual void Draw();
 virtual void Highlight(bool highlight);
   bool IsSelected() const;
   BPoint ContentLocation() const;

private:
 friend class BMenu;
 friend class BPopUpMenu;
 friend class BMenuBar;
 friend class BPrivate::MenuItemPrivate;

 virtual void _ReservedMenuItem1();
 virtual void _ReservedMenuItem2();
 virtual void _ReservedMenuItem3();
 virtual void _ReservedMenuItem4();

   void Install(BWindow* window);
   void Uninstall();
   void SetSuper(BMenu* superMenu);
   void Select(bool select);
   void SetAutomaticTrigger(int32 index,
         uint32 trigger);

protected:
 virtual status_t Invoke(BMessage* message = __null);

private:
        BMenuItem(const BMenuItem& other);
   BMenuItem& operator=(const BMenuItem& other);

private:
   void _InitData();
   void _InitMenuData(BMenu* menu);

   bool _IsActivated();
   rgb_color _LowColor();
   rgb_color _HighColor();

   void _DrawMarkSymbol();
   void _DrawShortcutSymbol(bool);
   void _DrawSubmenuSymbol();
   void _DrawControlChar(char shortcut, BPoint where);

private:
   char* fLabel;
   BMenu* fSubmenu;
   BWindow* fWindow;
   BMenu* fSuper;
   BRect fBounds;
   uint32 fModifiers;
   float fCachedWidth;
   int16 fTriggerIndex;
   char fUserTrigger;
   char fShortcutChar;
   bool fMark;
   bool fEnabled;
   bool fSelected;
   uint32 fTrigger;

   uint32 _reserved[3];
};




class BMessage;


class BSeparatorItem : public BMenuItem {
public:
        BSeparatorItem();
        BSeparatorItem(BMessage* data);
 virtual ~BSeparatorItem();

 static BArchivable* Instantiate(BMessage* data);
 virtual status_t Archive(BMessage* data,
         bool deep = true) const;

 virtual void SetEnabled(bool enable);

protected:
 virtual void GetContentSize(float* _width, float* _height);
 virtual void Draw();

private:

 virtual void _ReservedSeparatorItem1();
 virtual void _ReservedSeparatorItem2();

   BSeparatorItem& operator=(const BSeparatorItem& other);

   uint32 _reserved[1];
};
class BSpaceLayoutItem : public BLayoutItem {
public:
        BSpaceLayoutItem(BSize minSize, BSize maxSize,
         BSize preferredSize, BAlignment alignment);
        BSpaceLayoutItem(BMessage* archive);
 virtual ~BSpaceLayoutItem();

 static BSpaceLayoutItem* CreateGlue();
 static BSpaceLayoutItem* CreateHorizontalStrut(float width);
 static BSpaceLayoutItem* CreateVerticalStrut(float height);

 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();
 virtual BAlignment Alignment();

 virtual void SetExplicitMinSize(BSize size);
 virtual void SetExplicitMaxSize(BSize size);
 virtual void SetExplicitPreferredSize(BSize size);
 virtual void SetExplicitAlignment(BAlignment alignment);

 virtual bool IsVisible();
 virtual void SetVisible(bool visible);

 virtual BRect Frame();
 virtual void SetFrame(BRect frame);

 virtual status_t Archive(BMessage* into, bool deep = true) const;
 static BArchivable* Instantiate(BMessage* from);

private:

 virtual void _ReservedSpaceLayoutItem1();
 virtual void _ReservedSpaceLayoutItem2();
 virtual void _ReservedSpaceLayoutItem3();
 virtual void _ReservedSpaceLayoutItem4();
 virtual void _ReservedSpaceLayoutItem5();
 virtual void _ReservedSpaceLayoutItem6();
 virtual void _ReservedSpaceLayoutItem7();
 virtual void _ReservedSpaceLayoutItem8();
 virtual void _ReservedSpaceLayoutItem9();
 virtual void _ReservedSpaceLayoutItem10();


        BSpaceLayoutItem(const BSpaceLayoutItem&);
   void operator =(const BSpaceLayoutItem&);

   BRect fFrame;
   BSize fMinSize;
   BSize fMaxSize;
   BSize fPreferredSize;
   BAlignment fAlignment;
   bool fVisible;

   uint32 _reserved[2];
};
class BSplitLayout;


class BSplitView : public BView {
public:
        BSplitView(
         orientation orientation = B_HORIZONTAL,
         float spacing = B_USE_DEFAULT_SPACING);
        BSplitView(BMessage* from);
 virtual ~BSplitView();

   void SetInsets(float left, float top, float right,
         float bottom);
   void SetInsets(float horizontal, float vertical);
   void SetInsets(float insets);
   void GetInsets(float* left, float* top,
         float* right, float* bottom) const;

   float Spacing() const;
   void SetSpacing(float spacing);

   orientation Orientation() const;
   void SetOrientation(orientation orientation);

   float SplitterSize() const;
   void SetSplitterSize(float size);

   int32 CountItems() const;
   float ItemWeight(int32 index) const;
   float ItemWeight(BLayoutItem* item) const;
   void SetItemWeight(int32 index, float weight,
         bool invalidateLayout);
   void SetItemWeight(BLayoutItem* item, float weight);

   bool IsCollapsible(int32 index) const;
   void SetCollapsible(bool collapsible);
   void SetCollapsible(int32 index, bool collapsible);
   void SetCollapsible(int32 first, int32 last,
         bool collapsible);

   bool IsItemCollapsed(int32 index) const;
   void SetItemCollapsed(int32 index, bool collapsed);


   void AddChild(BView* child, BView* sibling = __null);
   bool AddChild(BView* child, float weight);
   bool AddChild(int32 index, BView* child,
         float weight);

   bool AddChild(BLayoutItem* child);
   bool AddChild(BLayoutItem* child, float weight);
   bool AddChild(int32 index, BLayoutItem* child,
         float weight);

 virtual void AttachedToWindow();
 virtual void Draw(BRect updateRect);
 virtual void DrawAfterChildren(BRect updateRect);
 virtual void MouseDown(BPoint where);
 virtual void MouseUp(BPoint where);
 virtual void MouseMoved(BPoint where, uint32 transit,
         const BMessage* message);

 virtual void MessageReceived(BMessage* message);


 virtual void SetLayout(BLayout* layout);


 virtual status_t Archive(BMessage* into, bool deep = true) const;
 static BArchivable* Instantiate(BMessage* from);

 virtual status_t Perform(perform_code d, void* arg);

protected:
 virtual status_t AllArchived(BMessage* into) const;
 virtual status_t AllUnarchived(const BMessage* from);

 virtual void DrawSplitter(BRect frame,
         const BRect& updateRect,
         orientation orientation,
         bool pressed);

private:


 virtual void _ReservedSplitView1();
 virtual void _ReservedSplitView2();
 virtual void _ReservedSplitView3();
 virtual void _ReservedSplitView4();
 virtual void _ReservedSplitView5();
 virtual void _ReservedSplitView6();
 virtual void _ReservedSplitView7();
 virtual void _ReservedSplitView8();
 virtual void _ReservedSplitView9();
 virtual void _ReservedSplitView10();


        BSplitView(const BSplitView&);
   void operator =(const BSplitView&);

 static void _DrawDefaultSplitter(BView* view, BRect frame,
         const BRect& updateRect,
         orientation orientation,
         bool pressed);

private:
   BSplitLayout* fSplitLayout;
   uint32 _reserved[3];
};
class BBitmap;
class BClipboard;
class BFile;
class BList;
class BMessageRunner;

struct text_run {
 int32 offset;
 BFont font;
 rgb_color color;
};

struct text_run_array {
 int32 count;
 text_run runs[1];
};

enum undo_state {
 B_UNDO_UNAVAILABLE,
 B_UNDO_TYPING,
 B_UNDO_CUT,
 B_UNDO_PASTE,
 B_UNDO_CLEAR,
 B_UNDO_DROP
};

namespace BPrivate {
 class TextGapBuffer;
}


class BTextView : public BView {
public:
        BTextView(BRect frame, const char* name,
         BRect textRect, uint32 resizeMask,
         uint32 flags
          = B_WILL_DRAW | B_PULSE_NEEDED);
        BTextView(BRect frame, const char* name,
         BRect textRect, const BFont* initialFont,
         const rgb_color* initialColor,
         uint32 resizeMask, uint32 flags);

        BTextView(const char* name,
         uint32 flags
          = B_WILL_DRAW | B_PULSE_NEEDED);
        BTextView(const char* name,
         const BFont* initialFont,
         const rgb_color* initialColor,
         uint32 flags);

        BTextView(BMessage* archive);

 virtual ~BTextView();

 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* archive,
         bool deep = true) const;

 virtual void AttachedToWindow();
 virtual void DetachedFromWindow();
 virtual void Draw(BRect updateRect);
 virtual void MouseDown(BPoint where);
 virtual void MouseUp(BPoint where);
 virtual void MouseMoved(BPoint where, uint32 code,
         const BMessage* dragMessage);
 virtual void WindowActivated(bool active);
 virtual void KeyDown(const char* bytes, int32 numBytes);
 virtual void Pulse();
 virtual void FrameResized(float newWidth, float newHeight);
 virtual void MakeFocus(bool focus = true);
 virtual void MessageReceived(BMessage* message);

 virtual BHandler* ResolveSpecifier(BMessage* message,
         int32 index, BMessage* specifier,
         int32 form, const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);
 virtual status_t Perform(perform_code code, void* data);

   void SetText(const char* text,
         const text_run_array* runs = __null);
   void SetText(const char* text, int32 length,
         const text_run_array* runs = __null);
   void SetText(BFile* file, int32 offset,
         int32 length,
         const text_run_array* runs = __null);

   void Insert(const char* text,
         const text_run_array* runs = __null);
   void Insert(const char* text, int32 length,
         const text_run_array* runs = __null);
   void Insert(int32 offset, const char* text,
         int32 length,
         const text_run_array* runs = __null);

   void Delete();
   void Delete(int32 startOffset, int32 endOffset);

   const char* Text() const;
   int32 TextLength() const;
   void GetText(int32 offset, int32 length,
         char* buffer) const;
   uint8 ByteAt(int32 offset) const;

   int32 CountLines() const;
   int32 CurrentLine() const;
   void GoToLine(int32 lineNumber);

 virtual void Cut(BClipboard* clipboard);
 virtual void Copy(BClipboard* clipboard);
 virtual void Paste(BClipboard* clipboard);
   void Clear();

 virtual bool AcceptsPaste(BClipboard* clipboard);
 virtual bool AcceptsDrop(const BMessage* message);

 virtual void Select(int32 startOffset, int32 endOffset);
   void SelectAll();
   void GetSelection(int32* _start, int32* _end) const;

   void SetFontAndColor(const BFont* font,
         uint32 mode = B_FONT_ALL,
         const rgb_color* color = __null);
   void SetFontAndColor(int32 startOffset,
         int32 endOffset, const BFont* font,
         uint32 mode = B_FONT_ALL,
         const rgb_color* color = __null);

   void GetFontAndColor(int32 offset, BFont* _font,
         rgb_color* _color = __null) const;
   void GetFontAndColor(BFont* _font, uint32* _mode,
         rgb_color* _color = __null,
         bool* _sameColor = __null) const;

   void SetRunArray(int32 startOffset, int32 endOffset,
         const text_run_array* runs);
   text_run_array* RunArray(int32 startOffset, int32 endOffset,
         int32* _size = __null) const;

   int32 LineAt(int32 offset) const;
   int32 LineAt(BPoint point) const;
   BPoint PointAt(int32 offset,
         float* _height = __null) const;
   int32 OffsetAt(BPoint point) const;
   int32 OffsetAt(int32 line) const;

 virtual void FindWord(int32 offset, int32* _fromOffset,
         int32* _toOffset);

 virtual bool CanEndLine(int32 offset);

   float LineWidth(int32 lineNumber = 0) const;
   float LineHeight(int32 lineNumber = 0) const;
   float TextHeight(int32 startLine,
         int32 endLine) const;

   void GetTextRegion(int32 startOffset,
         int32 endOffset, BRegion* outRegion) const;

 virtual void ScrollToOffset(int32 offset);
   void ScrollToSelection();

   void Highlight(int32 startOffset, int32 endOffset);

   void SetTextRect(BRect rect);
   BRect TextRect() const;
   void SetInsets(float left, float top, float right,
         float bottom);
   void GetInsets(float* _left, float* _top,
         float* _right, float* _bottom) const;

   void SetStylable(bool stylable);
   bool IsStylable() const;
   void SetTabWidth(float width);
   float TabWidth() const;
   void MakeSelectable(bool selectable = true);
   bool IsSelectable() const;
   void MakeEditable(bool editable = true);
   bool IsEditable() const;
   void SetWordWrap(bool wrap);
   bool DoesWordWrap() const;
   void SetMaxBytes(int32 max);
   int32 MaxBytes() const;
   void DisallowChar(uint32 character);
   void AllowChar(uint32 character);
   void SetAlignment(alignment align);
   alignment Alignment() const;
   void SetAutoindent(bool state);
   bool DoesAutoindent() const;
   void SetColorSpace(color_space colors);
   color_space ColorSpace() const;
   void MakeResizable(bool resize,
         BView* resizeView = __null);
   bool IsResizable() const;
   void SetDoesUndo(bool undo);
   bool DoesUndo() const;
   void HideTyping(bool enabled);
   bool IsTypingHidden() const;

 virtual void ResizeToPreferred();
 virtual void GetPreferredSize(float* _width, float* _height);

 virtual void AllAttached();
 virtual void AllDetached();

 static text_run_array* AllocRunArray(int32 entryCount,
         int32* outSize = __null);
 static text_run_array* CopyRunArray(const text_run_array* orig,
         int32 countDelta = 0);
 static void FreeRunArray(text_run_array* array);
 static void* FlattenRunArray(const text_run_array* runArray,
         int32* _size = __null);
 static text_run_array* UnflattenRunArray(const void* data,
         int32* _size = __null);

protected:
 virtual void InsertText(const char* text, int32 length,
         int32 offset, const text_run_array* runs);
 virtual void DeleteText(int32 fromOffset, int32 toOffset);

public:
 virtual void Undo(BClipboard* clipboard);
   undo_state UndoState(bool* isRedo) const;

protected:
 virtual void GetDragParameters(BMessage* drag,
         BBitmap** _bitmap, BPoint* point,
         BHandler** _handler);

 virtual void LayoutInvalidated(bool descendants);
 virtual void DoLayout();

public:
 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();

 virtual bool HasHeightForWidth();
 virtual void GetHeightForWidth(float width, float* min,
         float* max, float* preferred);

private:

 virtual void _ReservedTextView3();
 virtual void _ReservedTextView4();
 virtual void _ReservedTextView5();
 virtual void _ReservedTextView6();
 virtual void _ReservedTextView7();
 virtual void _ReservedTextView8();
 virtual void _ReservedTextView9();
 virtual void _ReservedTextView10();
 virtual void _ReservedTextView11();
 virtual void _ReservedTextView12();

private:
   class InlineInput;
   struct LayoutData;
   class LineBuffer;
   class StyleBuffer;
   class TextTrackState;
   class UndoBuffer;


   class CutUndoBuffer;
   class PasteUndoBuffer;
   class ClearUndoBuffer;
   class DropUndoBuffer;
   class TypingUndoBuffer;

   friend class TextTrackState;

   void _InitObject(BRect textRect,
         const BFont* initialFont,
         const rgb_color* initialColor);

   void _ValidateLayoutData();
   void _ResetTextRect();

   void _HandleBackspace(int32 modifiers = -1);
   void _HandleArrowKey(uint32 arrowKey,
         int32 modifiers = -1);
   void _HandleDelete(int32 modifiers = -1);
   void _HandlePageKey(uint32 pageKey,
         int32 modifiers = -1);
   void _HandleAlphaKey(const char* bytes,
         int32 numBytes);

   void _Refresh(int32 fromOffset, int32 toOffset,
         int32 scrollTo = (-(2147483647)-1));
   void _RecalculateLineBreaks(int32* startLine,
         int32* endLine);
   void _ValidateTextRect();
   int32 _FindLineBreak(int32 fromOffset,
         float* _ascent, float* _descent,
         float* inOutWidth);

   float _StyledWidth(int32 fromOffset, int32 length,
         float* _ascent = __null,
         float* _descent = __null) const;
   float _TabExpandedStyledWidth(int32 offset,
         int32 length, float* _ascent = __null,
         float* _descent = __null) const;

   float _ActualTabWidth(float location) const;

   void _DoInsertText(const char* text, int32 length,
         int32 offset, const text_run_array* runs);

   void _DoDeleteText(int32 fromOffset,
         int32 toOffset);

   void _DrawLine(BView* view, const int32 &startLine,
         const int32& startOffset,
         const bool& erase, BRect& eraseRect,
         BRegion& inputRegion);

   void _DrawLines(int32 startLine, int32 endLine,
         int32 startOffset = -1,
         bool erase = false);
   void _RequestDrawLines(int32 startLine,
         int32 endLine);

   void _DrawCaret(int32 offset, bool visible);
   void _ShowCaret();
   void _HideCaret();
   void _InvertCaret();
   void _DragCaret(int32 offset);

   void _StopMouseTracking();
   bool _PerformMouseUp(BPoint where);
   bool _PerformMouseMoved(BPoint where, uint32 code);

   void _TrackMouse(BPoint where,
         const BMessage* message,
         bool force = false);

   void _TrackDrag(BPoint where);
   void _InitiateDrag();
   bool _MessageDropped(BMessage* message,
         BPoint where, BPoint offset);

   void _PerformAutoScrolling();
   void _UpdateScrollbars();
   void _ScrollBy(float horizontalStep,
         float verticalStep);
   void _ScrollTo(float x, float y);

   void _AutoResize(bool doRedraw = true);

   void _NewOffscreen(float padding = 0.0);
   void _DeleteOffscreen();

   void _Activate();
   void _Deactivate();

   void _NormalizeFont(BFont* font);

   void _SetRunArray(int32 startOffset, int32 endOffset,
         const text_run_array* runs);

   void _ApplyStyleRange(int32 fromOffset,
         int32 toOffset,
         uint32 mode = B_FONT_ALL,
         const BFont* font = __null,
         const rgb_color* color = __null,
         bool syncNullStyle = true);

   uint32 _CharClassification(int32 offset) const;
   int32 _NextInitialByte(int32 offset) const;
   int32 _PreviousInitialByte(int32 offset) const;

   int32 _PreviousLineStart(int32 offset);
   int32 _NextLineEnd(int32 offset);

   int32 _PreviousWordBoundary(int32 offset);
   int32 _NextWordBoundary(int32 offset);

   int32 _PreviousWordStart(int32 offset);
   int32 _NextWordEnd(int32 offset);

   bool _GetProperty(BMessage* message,
         BMessage* specifier,
         const char* property, BMessage* reply);
   bool _SetProperty(BMessage* message,
         BMessage* specifier,
         const char* property, BMessage* reply);
   bool _CountProperties(BMessage* message,
         BMessage* specifier, const char* property,
         BMessage* reply);

   void _HandleInputMethodChanged(BMessage* message);
   void _HandleInputMethodLocationRequest();
   void _CancelInputMethod();

   int32 _LineAt(int32 offset) const;
   int32 _LineAt(const BPoint& point) const;
   bool _IsOnEmptyLastLine(int32 offset) const;

   float _NullStyleHeight() const;

   void _ShowContextMenu(BPoint where);

   void _FilterDisallowedChars(char* text,
         ssize_t& length, text_run_array* runArray);

   void _UpdateInsets(const BRect& rect);

private:
   BPrivate::TextGapBuffer* fText;
   LineBuffer* fLines;
   StyleBuffer* fStyles;
   BRect fTextRect;
   int32 fSelStart;
   int32 fSelEnd;
   bool fCaretVisible;
   bigtime_t fCaretTime;
   int32 fCaretOffset;
   int32 fClickCount;
   bigtime_t fClickTime;
   int32 fDragOffset;
   uint8 fCursor;
   bool fActive;
   bool fStylable;
   float fTabWidth;
   bool fSelectable;
   bool fEditable;
   bool fWrap;
   int32 fMaxBytes;
   BList* fDisallowedChars;
   alignment fAlignment;
   bool fAutoindent;
   BBitmap* fOffscreen;
   color_space fColorSpace;
   bool fResizable;
   BView* fContainerView;
   UndoBuffer* fUndo;
   InlineInput* fInline;
   BMessageRunner* fDragRunner;
   BMessageRunner* fClickRunner;
   BPoint fWhere;
   TextTrackState* fTrackingMouse;

   float fMinTextRectWidth;
   LayoutData* fLayoutData;
   int32 fLastClickOffset;

   bool fInstalledNavigateCommandWordwiseShortcuts : 1;
   bool fInstalledNavigateOptionWordwiseShortcuts : 1;
   bool fInstalledNavigateOptionLinewiseShortcuts : 1;
   bool fInstalledNavigateHomeEndDocwiseShortcuts : 1;

   bool fInstalledSelectCommandWordwiseShortcuts : 1;
   bool fInstalledSelectOptionWordwiseShortcuts : 1;
   bool fInstalledSelectOptionLinewiseShortcuts : 1;
   bool fInstalledSelectHomeEndDocwiseShortcuts : 1;

   bool fInstalledRemoveCommandWordwiseShortcuts : 1;
   bool fInstalledRemoveOptionWordwiseShortcuts : 1;

   uint32 _reserved[6];
};


class BLayoutItem;
namespace BPrivate {
 class _BTextInput_;
}


class BTextControl : public BControl {
public:
        BTextControl(BRect frame, const char* name,
         const char* label, const char* initialText,
         BMessage* message,
         uint32 resizeMask = B_FOLLOW_LEFT_TOP,
         uint32 flags = B_WILL_DRAW | B_NAVIGABLE);
        BTextControl(const char* name,
         const char* label, const char* initialText,
         BMessage* message,
         uint32 flags = B_WILL_DRAW | B_NAVIGABLE);
        BTextControl(const char* label,
         const char* initialText,
         BMessage* message);
 virtual ~BTextControl();

        BTextControl(BMessage* archive);
 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* archive,
         bool deep = true) const;

 virtual void SetText(const char* text);
   const char* Text() const;
   int32 TextLength() const;
   void MarkAsInvalid(bool invalid);

 virtual void SetValue(int32 value);
 virtual status_t Invoke(BMessage* message = __null);

   BTextView* TextView() const;

 virtual void SetModificationMessage(BMessage* message);
   BMessage* ModificationMessage() const;

 virtual void SetAlignment(alignment label, alignment text);
   void GetAlignment(alignment* _label,
         alignment* _text) const;
 virtual void SetDivider(float position);
   float Divider() const;

 virtual void Draw(BRect updateRect);
 virtual void MouseDown(BPoint where);
 virtual void AttachedToWindow();
 virtual void MakeFocus(bool focus = true);
 virtual void SetEnabled(bool enable);
 virtual void FrameMoved(BPoint newPosition);
 virtual void FrameResized(float newWidth, float newHeight);
 virtual void WindowActivated(bool active);

 virtual void GetPreferredSize(float* _width,
         float* _height);
 virtual void ResizeToPreferred();

 virtual void MessageReceived(BMessage* message);
 virtual BHandler* ResolveSpecifier(BMessage* message,
         int32 index, BMessage* specifier,
         int32 what, const char* property);

 virtual void MouseUp(BPoint where);
 virtual void MouseMoved(BPoint where, uint32 transit,
         const BMessage* dragMessage);
 virtual void DetachedFromWindow();

 virtual void AllAttached();
 virtual void AllDetached();
 virtual status_t GetSupportedSuites(BMessage* data);
 virtual void SetFlags(uint32 flags);

 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();
 virtual BAlignment LayoutAlignment();

   BLayoutItem* CreateLabelLayoutItem();
   BLayoutItem* CreateTextViewLayoutItem();

protected:
 virtual status_t AllArchived(BMessage* into) const;
 virtual status_t AllUnarchived(const BMessage* from);

 virtual void LayoutInvalidated(bool descendants);
 virtual void DoLayout();

 virtual status_t SetIcon(const BBitmap* icon, uint32 flags = 0);

private:

 virtual status_t Perform(perform_code d, void* arg);

 virtual void _ReservedTextControl1();
 virtual void _ReservedTextControl2();
 virtual void _ReservedTextControl3();
 virtual void _ReservedTextControl4();

   BTextControl& operator=(const BTextControl& other);

private:
 class LabelLayoutItem;
 class TextViewLayoutItem;
 struct LayoutData;

 friend class _BTextInput_;
 friend class LabelLayoutItem;
 friend class TextViewLayoutItem;

   void _CommitValue();
   void _UpdateTextViewColors(bool enable);
   void _InitData(const char* label,
         const BMessage* archive = __null);
   void _InitText(const char* initialText,
         const BMessage* archive = __null);
   void _ValidateLayout();
   void _LayoutTextView();
   void _UpdateFrame();

   void _ValidateLayoutData();

private:
   BPrivate::_BTextInput_* fText;
   BMessage* fModificationMessage;
   alignment fLabelAlign;
   float fDivider;

   LayoutData* fLayoutData;
   uint32 fLook;

   uint32 _reserved[8];
};



namespace BLayoutBuilder {

template<typename ParentBuilder> class Base;
template<typename ParentBuilder = void*> class Group;
template<typename ParentBuilder = void*> class Grid;
template<typename ParentBuilder = void*> class Split;
template<typename ParentBuilder = void*> class Cards;
template<typename ParentBuilder = void*> class Menu;
template<typename ParentBuilder = void*> class MenuItem;


template<typename ParentBuilder>
class Base {
protected:
 inline Base();

public:
 inline void SetParent(ParentBuilder* parent);

 inline ParentBuilder& End();

protected:
   ParentBuilder* fParent;
};


template<typename ParentBuilder>
class Group : public Base<ParentBuilder> {
public:
 typedef Group<ParentBuilder> ThisBuilder;
 typedef Group<ThisBuilder> GroupBuilder;
 typedef Grid<ThisBuilder> GridBuilder;
 typedef Split<ThisBuilder> SplitBuilder;
 typedef Cards<ThisBuilder> CardBuilder;

public:
 inline Group(orientation orientation = B_HORIZONTAL,
         float spacing = B_USE_DEFAULT_SPACING);
 inline Group(BWindow* window,
         orientation orientation = B_HORIZONTAL,
         float spacing = B_USE_DEFAULT_SPACING);
 inline Group(BView* view,
         orientation orientation = B_HORIZONTAL,
         float spacing = B_USE_DEFAULT_SPACING);
 inline Group(BGroupLayout* layout);
 inline Group(BGroupView* view);

 inline BGroupLayout* Layout() const;
 inline BView* View() const;
 inline ThisBuilder& GetLayout(BGroupLayout** _layout);
 inline ThisBuilder& GetView(BView** _view);

 inline ThisBuilder& Add(BView* view);
 inline ThisBuilder& Add(BView* view, float weight);
 inline ThisBuilder& Add(BLayoutItem* item);
 inline ThisBuilder& Add(BLayoutItem* item, float weight);

 inline GroupBuilder AddGroup(orientation orientation,
         float spacing = B_USE_DEFAULT_SPACING,
         float weight = 1.0f);
 inline GroupBuilder AddGroup(BGroupView* groupView,
         float weight = 1.0f);
 inline GroupBuilder AddGroup(BGroupLayout* groupLayout,
         float weight = 1.0f);

 inline GridBuilder AddGrid(float horizontal
          = B_USE_DEFAULT_SPACING,
         float vertical = B_USE_DEFAULT_SPACING,
         float weight = 1.0f);
 inline GridBuilder AddGrid(BGridLayout* gridLayout,
         float weight = 1.0f);
 inline GridBuilder AddGrid(BGridView* gridView,
         float weight = 1.0f);

 inline SplitBuilder AddSplit(orientation orientation,
         float spacing = B_USE_DEFAULT_SPACING,
         float weight = 1.0f);
 inline SplitBuilder AddSplit(BSplitView* splitView,
         float weight = 1.0f);

 inline CardBuilder AddCards(float weight = 1.0f);
 inline CardBuilder AddCards(BCardLayout* cardLayout,
         float weight = 1.0f);
 inline CardBuilder AddCards(BCardView* cardView,
         float weight = 1.0f);

 inline ThisBuilder& AddGlue(float weight = 1.0f);
 inline ThisBuilder& AddStrut(float size);

 inline ThisBuilder& SetInsets(float left, float top, float right,
         float bottom);
 inline ThisBuilder& SetInsets(float horizontal, float vertical);
 inline ThisBuilder& SetInsets(float insets);

 inline ThisBuilder& SetExplicitMinSize(BSize size);
 inline ThisBuilder& SetExplicitMaxSize(BSize size);
 inline ThisBuilder& SetExplicitPreferredSize(BSize size);
 inline ThisBuilder& SetExplicitAlignment(BAlignment alignment);

 inline operator BGroupLayout*();

private:
   BGroupLayout* fLayout;
};


template<typename ParentBuilder>
class Grid : public Base<ParentBuilder> {
public:
 typedef Grid<ParentBuilder> ThisBuilder;
 typedef Group<ThisBuilder> GroupBuilder;
 typedef Grid<ThisBuilder> GridBuilder;
 typedef Split<ThisBuilder> SplitBuilder;
 typedef Cards<ThisBuilder> CardBuilder;

public:
 inline Grid(float horizontal
          = B_USE_DEFAULT_SPACING,
         float vertical = B_USE_DEFAULT_SPACING);
 inline Grid(BWindow* window,
         float horizontal = B_USE_DEFAULT_SPACING,
         float vertical = B_USE_DEFAULT_SPACING);
 inline Grid(BView* view,
         float horizontal = B_USE_DEFAULT_SPACING,
         float vertical = B_USE_DEFAULT_SPACING);
 inline Grid(BGridLayout* layout);
 inline Grid(BGridView* view);

 inline BGridLayout* Layout() const;
 inline BView* View() const;
 inline ThisBuilder& GetLayout(BGridLayout** _layout);
 inline ThisBuilder& GetView(BView** _view);

 inline ThisBuilder& Add(BView* view, int32 column, int32 row,
         int32 columnCount = 1, int32 rowCount = 1);
 inline ThisBuilder& Add(BLayoutItem* item, int32 column, int32 row,
         int32 columnCount = 1, int32 rowCount = 1);
 inline ThisBuilder& AddMenuField(BMenuField* menuField,
         int32 column, int32 row,
         alignment labelAlignment
          = B_ALIGN_HORIZONTAL_UNSET,
         int32 labelColumnCount = 1,
         int32 fieldColumnCount = 1,
         int32 rowCount = 1);
 inline ThisBuilder& AddTextControl(BTextControl* textControl,
         int32 column, int32 row,
         alignment labelAlignment
          = B_ALIGN_HORIZONTAL_UNSET,
         int32 labelColumnCount = 1,
         int32 textColumnCount = 1,
         int32 rowCount = 1);

 inline GroupBuilder AddGroup(orientation orientation,
         float spacing, int32 column, int32 row,
         int32 columnCount = 1, int32 rowCount = 1);
 inline GroupBuilder AddGroup(BGroupView* groupView, int32 column,
         int32 row, int32 columnCount = 1,
         int32 rowCount = 1);
 inline GroupBuilder AddGroup(BGroupLayout* groupLayout,
         int32 column, int32 row,
         int32 columnCount = 1, int32 rowCount = 1);

 inline GridBuilder AddGrid(float horizontalSpacing,
         float verticalSpacing, int32 column,
         int32 row, int32 columnCount = 1,
         int32 rowCount = 1);
 inline GridBuilder AddGrid(BGridLayout* gridLayout,
         int32 column, int32 row,
         int32 columnCount = 1, int32 rowCount = 1);
 inline GridBuilder AddGrid(BGridView* gridView,
         int32 column, int32 row,
         int32 columnCount = 1, int32 rowCount = 1);

 inline SplitBuilder AddSplit(orientation orientation,
         float spacing, int32 column, int32 row,
         int32 columnCount = 1, int32 rowCount = 1);
 inline SplitBuilder AddSplit(BSplitView* splitView, int32 column,
         int32 row, int32 columnCount = 1,
         int32 rowCount = 1);

 inline CardBuilder AddCards(int32 column, int32 row,
         int32 columnCount = 1, int32 rowCount = 1);
 inline CardBuilder AddCards(BCardLayout* cardLayout, int32 column,
         int32 row, int32 columnCount = 1,
         int32 rowCount = 1);
 inline CardBuilder AddCards(BCardView* cardView, int32 column,
         int32 row, int32 columnCount = 1,
         int32 rowCount = 1);

 inline ThisBuilder& AddGlue(int32 column, int32 row,
         int32 columnCount = 1, int32 rowCount = 1);

 inline ThisBuilder& SetHorizontalSpacing(float spacing);
 inline ThisBuilder& SetVerticalSpacing(float spacing);
 inline ThisBuilder& SetSpacing(float horizontal, float vertical);

 inline ThisBuilder& SetColumnWeight(int32 column, float weight);
 inline ThisBuilder& SetRowWeight(int32 row, float weight);

 inline ThisBuilder& SetInsets(float left, float top, float right,
         float bottom);
 inline ThisBuilder& SetInsets(float horizontal, float vertical);
 inline ThisBuilder& SetInsets(float insets);

 inline ThisBuilder& SetExplicitMinSize(BSize size);
 inline ThisBuilder& SetExplicitMaxSize(BSize size);
 inline ThisBuilder& SetExplicitPreferredSize(BSize size);
 inline ThisBuilder& SetExplicitAlignment(BAlignment alignment);

 inline operator BGridLayout*();

private:
   BGridLayout* fLayout;
};


template<typename ParentBuilder>
class Split : public Base<ParentBuilder> {
public:
 typedef Split<ParentBuilder> ThisBuilder;
 typedef Group<ThisBuilder> GroupBuilder;
 typedef Grid<ThisBuilder> GridBuilder;
 typedef Split<ThisBuilder> SplitBuilder;
 typedef Cards<ThisBuilder> CardBuilder;

public:
 inline Split(orientation orientation = B_HORIZONTAL,
         float spacing = B_USE_DEFAULT_SPACING);
 inline Split(BSplitView* view);

 inline BSplitView* View() const;
 inline ThisBuilder& GetView(BView** _view);
 inline ThisBuilder& GetSplitView(BSplitView** _view);

 inline ThisBuilder& Add(BView* view);
 inline ThisBuilder& Add(BView* view, float weight);
 inline ThisBuilder& Add(BLayoutItem* item);
 inline ThisBuilder& Add(BLayoutItem* item, float weight);

 inline GroupBuilder AddGroup(orientation orientation,
         float spacing = B_USE_DEFAULT_SPACING,
         float weight = 1.0f);
 inline GroupBuilder AddGroup(BGroupView* groupView,
         float weight = 1.0f);
 inline GroupBuilder AddGroup(BGroupLayout* groupLayout,
         float weight = 1.0f);

 inline GridBuilder AddGrid(float horizontal
           = B_USE_DEFAULT_SPACING,
         float vertical = B_USE_DEFAULT_SPACING,
         float weight = 1.0f);
 inline GridBuilder AddGrid(BGridView* gridView,
         float weight = 1.0f);
 inline GridBuilder AddGrid(BGridLayout* gridLayout,
         float weight = 1.0f);

 inline SplitBuilder AddSplit(orientation orientation,
         float spacing = B_USE_DEFAULT_SPACING,
         float weight = 1.0f);
 inline SplitBuilder AddSplit(BSplitView* splitView,
         float weight = 1.0f);

 inline CardBuilder AddCards(float weight = 1.0f);
 inline CardBuilder AddCards(BCardLayout* cardLayout,
         float weight = 1.0f);
 inline CardBuilder AddCards(BCardView* cardView,
         float weight = 1.0f);

 inline ThisBuilder& SetCollapsible(bool collapsible);
 inline ThisBuilder& SetCollapsible(int32 index, bool collapsible);
 inline ThisBuilder& SetCollapsible(int32 first, int32 last,
         bool collapsible);

 inline ThisBuilder& SetInsets(float left, float top, float right,
         float bottom);
 inline ThisBuilder& SetInsets(float horizontal, float vertical);
 inline ThisBuilder& SetInsets(float insets);

 inline operator BSplitView*();

private:
   BSplitView* fView;
};

template<typename ParentBuilder>
class Cards : public Base<ParentBuilder> {
public:
 typedef Cards<ParentBuilder> ThisBuilder;
 typedef Group<ThisBuilder> GroupBuilder;
 typedef Grid<ThisBuilder> GridBuilder;
 typedef Split<ThisBuilder> SplitBuilder;
 typedef Cards<ThisBuilder> CardBuilder;

public:
 inline Cards();
 inline Cards(BWindow* window);
 inline Cards(BView* view);
 inline Cards(BCardLayout* layout);
 inline Cards(BCardView* view);

 inline BCardLayout* Layout() const;
 inline BView* View() const;
 inline ThisBuilder& GetLayout(BCardLayout** _layout);
 inline ThisBuilder& GetView(BView** _view);

 inline ThisBuilder& Add(BView* view);
 inline ThisBuilder& Add(BLayoutItem* item);

 inline GroupBuilder AddGroup(orientation orientation,
         float spacing = B_USE_DEFAULT_SPACING);
 inline GroupBuilder AddGroup(BGroupView* groupView);
 inline GroupBuilder AddGroup(BGroupLayout* groupLayout);

 inline GridBuilder AddGrid(float horizontal
          = B_USE_DEFAULT_SPACING,
         float vertical = B_USE_DEFAULT_SPACING);
 inline GridBuilder AddGrid(BGridLayout* gridLayout);
 inline GridBuilder AddGrid(BGridView* gridView);

 inline SplitBuilder AddSplit(orientation orientation,
         float spacing = B_USE_DEFAULT_SPACING);
 inline SplitBuilder AddSplit(BSplitView* splitView);

 inline CardBuilder AddCards();
 inline CardBuilder AddCards(BCardLayout* cardLayout);
 inline CardBuilder AddCards(BCardView* cardView);

 inline ThisBuilder& SetExplicitMinSize(BSize size);
 inline ThisBuilder& SetExplicitMaxSize(BSize size);
 inline ThisBuilder& SetExplicitPreferredSize(BSize size);
 inline ThisBuilder& SetExplicitAlignment(BAlignment alignment);

 inline ThisBuilder& SetVisibleItem(int32 index);

 inline operator BCardLayout*();

private:
   BCardLayout* fLayout;
};


template<typename ParentBuilder>
class Menu : public Base<ParentBuilder> {
public:
 typedef Menu<ParentBuilder> ThisBuilder;
 typedef MenuItem<ParentBuilder> ItemBuilder;
 typedef Menu<ThisBuilder> MenuBuilder;

public:
 inline Menu(BMenu* menu);

 inline ThisBuilder& GetMenu(BMenu*& _menu);

 inline ItemBuilder AddItem(BMenuItem* item);
 inline ItemBuilder AddItem(BMenu* menu);
 inline ItemBuilder AddItem(const char* label, BMessage* message,
         char shortcut = 0, uint32 modifiers = 0);
 inline ItemBuilder AddItem(const char* label, uint32 messageWhat,
         char shortcut = 0, uint32 modifiers = 0);

 inline MenuBuilder AddMenu(BMenu* menu);
 inline MenuBuilder AddMenu(const char* title,
         menu_layout layout = B_ITEMS_IN_COLUMN);

 inline ThisBuilder& AddSeparator();

private:
   BMenu* fMenu;
};


template<typename ParentBuilder>
class MenuItem : public Menu<ParentBuilder> {
public:
 typedef MenuItem<ParentBuilder> ThisBuilder;

public:
 inline MenuItem(ParentBuilder* parentBuilder,
         BMenu* menu, BMenuItem* item);

 inline ThisBuilder& GetItem(BMenuItem*& _item);

 inline ThisBuilder& SetEnabled(bool enabled);

private:
   BMenuItem* fMenuItem;
};





template<typename ParentBuilder>
Base<ParentBuilder>::Base()
 :
 fParent(__null)
{
}


template<typename ParentBuilder>
void
Base<ParentBuilder>::SetParent(ParentBuilder* parent)
{
 fParent = parent;
}


template<typename ParentBuilder>
ParentBuilder&
Base<ParentBuilder>::End()
{
 return *fParent;
}





template<typename ParentBuilder>
Group<ParentBuilder>::Group(orientation orientation, float spacing)
 :
 fLayout((new BGroupView(orientation, spacing))->GroupLayout())
{
}


template<typename ParentBuilder>
Group<ParentBuilder>::Group(BWindow* window, orientation orientation,
  float spacing)
 :
 fLayout(new BGroupLayout(orientation, spacing))
{
 window->SetLayout(fLayout);
 fLayout->Owner()->AdoptSystemColors();
}


template<typename ParentBuilder>
Group<ParentBuilder>::Group(BView* view, orientation orientation,
  float spacing)
 :
 fLayout(new BGroupLayout(orientation, spacing))
{

 if (view->HasDefaultColors())
  view->AdoptSystemColors();

 view->SetLayout(fLayout);
}


template<typename ParentBuilder>
Group<ParentBuilder>::Group(BGroupLayout* layout)
 :
 fLayout(layout)
{
}


template<typename ParentBuilder>
Group<ParentBuilder>::Group(BGroupView* view)
 :
 fLayout(view->GroupLayout())
{
}


template<typename ParentBuilder>
BGroupLayout*
Group<ParentBuilder>::Layout() const
{
 return fLayout;
}


template<typename ParentBuilder>
BView*
Group<ParentBuilder>::View() const
{
 return fLayout->Owner();
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::GetLayout(BGroupLayout** _layout)
{
 *_layout = fLayout;
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::GetView(BView** _view)
{
 *_view = fLayout->Owner();
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::Add(BView* view)
{
 fLayout->AddView(view);
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::Add(BView* view, float weight)
{
 fLayout->AddView(view, weight);
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::Add(BLayoutItem* item)
{
 fLayout->AddItem(item);
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::Add(BLayoutItem* item, float weight)
{
 fLayout->AddItem(item, weight);
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::GroupBuilder
Group<ParentBuilder>::AddGroup(orientation orientation, float spacing,
  float weight)
{
 GroupBuilder builder(new BGroupLayout(orientation, spacing));
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::GroupBuilder
Group<ParentBuilder>::AddGroup(BGroupView* groupView, float weight)
{
 GroupBuilder builder(groupView);
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::GroupBuilder
Group<ParentBuilder>::AddGroup(BGroupLayout* groupLayout, float weight)
{
 GroupBuilder builder(groupLayout);
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::GridBuilder
Group<ParentBuilder>::AddGrid(float horizontalSpacing,
 float verticalSpacing, float weight)
{
 GridBuilder builder(new BGridLayout(horizontalSpacing, verticalSpacing));
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::GridBuilder
Group<ParentBuilder>::AddGrid(BGridLayout* gridLayout, float weight)
{
 GridBuilder builder(gridLayout);
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::GridBuilder
Group<ParentBuilder>::AddGrid(BGridView* gridView, float weight)
{
 GridBuilder builder(gridView);
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::SplitBuilder
Group<ParentBuilder>::AddSplit(orientation orientation, float spacing,
  float weight)
{
 SplitBuilder builder(orientation, spacing);
 builder.SetParent(this);
 fLayout->AddView(builder.View(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::SplitBuilder
Group<ParentBuilder>::AddSplit(BSplitView* splitView, float weight)
{
 SplitBuilder builder(splitView);
 builder.SetParent(this);
 fLayout->AddView(builder.View(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::CardBuilder
Group<ParentBuilder>::AddCards(float weight)
{
 CardBuilder builder;
 builder.SetParent(this);
 fLayout->AddView(builder.View(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::CardBuilder
Group<ParentBuilder>::AddCards(BCardLayout* cardLayout, float weight)
{
 CardBuilder builder(cardLayout);
 builder.SetParent(this);
 fLayout->AddView(builder.View(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::CardBuilder
Group<ParentBuilder>::AddCards(BCardView* cardView, float weight)
{
 CardBuilder builder(cardView);
 builder.SetParent(this);
 fLayout->AddView(builder.View(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::AddGlue(float weight)
{
 fLayout->AddItem(BSpaceLayoutItem::CreateGlue(), weight);
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::AddStrut(float size)
{
 if (fLayout->Orientation() == B_HORIZONTAL)
  fLayout->AddItem(BSpaceLayoutItem::CreateHorizontalStrut(size));
 else
  fLayout->AddItem(BSpaceLayoutItem::CreateVerticalStrut(size));

 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::SetInsets(float left, float top, float right,
 float bottom)
{
 fLayout->SetInsets(left, top, right, bottom);
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::SetInsets(float horizontal, float vertical)
{
 fLayout->SetInsets(horizontal, vertical);
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::SetInsets(float insets)
{
 fLayout->SetInsets(insets);
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::SetExplicitMinSize(BSize size)
{
 fLayout->SetExplicitMinSize(size);
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::SetExplicitMaxSize(BSize size)
{
 fLayout->SetExplicitMaxSize(size);
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::SetExplicitPreferredSize(BSize size)
{
 fLayout->SetExplicitPreferredSize(size);
 return *this;
}


template<typename ParentBuilder>
typename Group<ParentBuilder>::ThisBuilder&
Group<ParentBuilder>::SetExplicitAlignment(BAlignment alignment)
{
 fLayout->SetExplicitAlignment(alignment);
 return *this;
}


template<typename ParentBuilder>
Group<ParentBuilder>::operator BGroupLayout*()
{
 return fLayout;
}





template<typename ParentBuilder>
Grid<ParentBuilder>::Grid(float horizontalSpacing, float verticalSpacing)
 :
 fLayout((new BGridView(horizontalSpacing, verticalSpacing))->GridLayout())
{
}


template<typename ParentBuilder>
Grid<ParentBuilder>::Grid(BWindow* window, float horizontalSpacing,
 float verticalSpacing)
 :
 fLayout(new BGridLayout(horizontalSpacing, verticalSpacing))
{
 window->SetLayout(fLayout);
 fLayout->Owner()->AdoptSystemColors();
}


template<typename ParentBuilder>
Grid<ParentBuilder>::Grid(BView* view, float horizontalSpacing,
 float verticalSpacing)
 :
 fLayout(new BGridLayout(horizontalSpacing, verticalSpacing))
{
 if (view->HasDefaultColors())
  view->AdoptSystemColors();

 view->SetLayout(fLayout);
}


template<typename ParentBuilder>
Grid<ParentBuilder>::Grid(BGridLayout* layout)
 :
 fLayout(layout)
{
}


template<typename ParentBuilder>
Grid<ParentBuilder>::Grid(BGridView* view)
 :
 fLayout(view->GridLayout())
{
}


template<typename ParentBuilder>
BGridLayout*
Grid<ParentBuilder>::Layout() const
{
 return fLayout;
}


template<typename ParentBuilder>
BView*
Grid<ParentBuilder>::View() const
{
 return fLayout->Owner();
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::GetLayout(BGridLayout** _layout)
{
 *_layout = fLayout;
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::GetView(BView** _view)
{
 *_view = fLayout->Owner();
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::Add(BView* view, int32 column, int32 row,
 int32 columnCount, int32 rowCount)
{
 fLayout->AddView(view, column, row, columnCount, rowCount);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::Add(BLayoutItem* item, int32 column, int32 row,
 int32 columnCount, int32 rowCount)
{
 fLayout->AddItem(item, column, row, columnCount, rowCount);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::AddMenuField(BMenuField* menuField, int32 column,
 int32 row, alignment labelAlignment, int32 labelColumnCount,
 int32 fieldColumnCount, int32 rowCount)
{
 BLayoutItem* item = menuField->CreateLabelLayoutItem();
 item->SetExplicitAlignment(
  BAlignment(labelAlignment, B_ALIGN_VERTICAL_UNSET));
 fLayout->AddItem(item, column, row, labelColumnCount, rowCount);
 fLayout->AddItem(menuField->CreateMenuBarLayoutItem(),
  column + labelColumnCount, row, fieldColumnCount, rowCount);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::AddTextControl(BTextControl* textControl, int32 column,
 int32 row, alignment labelAlignment, int32 labelColumnCount,
 int32 textColumnCount, int32 rowCount)
{
 BLayoutItem* item = textControl->CreateLabelLayoutItem();
 item->SetExplicitAlignment(
  BAlignment(labelAlignment, B_ALIGN_VERTICAL_UNSET));
 fLayout->AddItem(item, column, row, labelColumnCount, rowCount);
 fLayout->AddItem(textControl->CreateTextViewLayoutItem(),
  column + labelColumnCount, row, textColumnCount, rowCount);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::GroupBuilder
Grid<ParentBuilder>::AddGroup(orientation orientation, float spacing,
  int32 column, int32 row, int32 columnCount, int32 rowCount)
{
 GroupBuilder builder(new BGroupLayout(orientation, spacing));
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout(), column, row, columnCount, rowCount);
 return builder;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::GroupBuilder
Grid<ParentBuilder>::AddGroup(BGroupView* groupView, int32 column, int32 row,
 int32 columnCount, int32 rowCount)
{
 GroupBuilder builder(groupView);
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout(), column, row, columnCount, rowCount);
 return builder;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::GroupBuilder
Grid<ParentBuilder>::AddGroup(BGroupLayout* groupLayout, int32 column,
 int32 row, int32 columnCount, int32 rowCount)
{
 GroupBuilder builder(groupLayout);
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout(), column, row, columnCount, rowCount);
 return builder;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::GridBuilder
Grid<ParentBuilder>::AddGrid(float horizontalSpacing, float verticalSpacing,
 int32 column, int32 row, int32 columnCount, int32 rowCount)
{
 GridBuilder builder(new BGridLayout(horizontalSpacing, verticalSpacing));
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout(), column, row, columnCount, rowCount);
 return builder;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::GridBuilder
Grid<ParentBuilder>::AddGrid(BGridView* gridView, int32 column, int32 row,
 int32 columnCount, int32 rowCount)
{
 GridBuilder builder(gridView);
 builder.SetParent(this);
 fLayout->AddView(builder.View(), column, row, columnCount, rowCount);
 return builder;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::SplitBuilder
Grid<ParentBuilder>::AddSplit(orientation orientation, float spacing,
 int32 column, int32 row, int32 columnCount, int32 rowCount)
{
 SplitBuilder builder(orientation, spacing);
 builder.SetParent(this);
 fLayout->AddView(builder.View(), column, row, columnCount, rowCount);
 return builder;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::SplitBuilder
Grid<ParentBuilder>::AddSplit(BSplitView* splitView, int32 column, int32 row,
 int32 columnCount, int32 rowCount)
{
 SplitBuilder builder(splitView);
 builder.SetParent(this);
 fLayout->AddView(builder.View(), column, row, columnCount, rowCount);
 return builder;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::CardBuilder
Grid<ParentBuilder>::AddCards(int32 column, int32 row, int32 columnCount,
 int32 rowCount)
{
 CardBuilder builder;
 builder.SetParent(this);
 fLayout->AddView(builder.View(), column, row, columnCount, rowCount);
 return builder;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::CardBuilder
Grid<ParentBuilder>::AddCards(BCardLayout* cardLayout, int32 column, int32 row,
 int32 columnCount, int32 rowCount)
{
 CardBuilder builder(cardLayout);
 builder.SetParent(this);
 fLayout->AddView(builder.View(), column, row, columnCount, rowCount);
 return builder;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::CardBuilder
Grid<ParentBuilder>::AddCards(BCardView* cardView, int32 column, int32 row,
 int32 columnCount, int32 rowCount)
{
 CardBuilder builder(cardView);
 builder.SetParent(this);
 fLayout->AddView(builder.View(), column, row, columnCount, rowCount);
 return builder;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::AddGlue(int32 column, int32 row, int32 columnCount,
 int32 rowCount)
{
 fLayout->AddItem(BSpaceLayoutItem::CreateGlue(), column, row, columnCount,
  rowCount);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::SetHorizontalSpacing(float spacing)
{
 fLayout->SetHorizontalSpacing(spacing);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::SetVerticalSpacing(float spacing)
{
 fLayout->SetVerticalSpacing(spacing);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::SetSpacing(float horizontal, float vertical)
{
 fLayout->SetSpacing(horizontal, vertical);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::SetColumnWeight(int32 column, float weight)
{
 fLayout->SetColumnWeight(column, weight);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::SetRowWeight(int32 row, float weight)
{
 fLayout->SetRowWeight(row, weight);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::SetInsets(float left, float top, float right,
 float bottom)
{
 fLayout->SetInsets(left, top, right, bottom);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::SetInsets(float horizontal, float vertical)
{
 fLayout->SetInsets(horizontal, vertical);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::SetInsets(float insets)
{
 fLayout->SetInsets(insets);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::SetExplicitMinSize(BSize size)
{
 fLayout->SetExplicitMinSize(size);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::SetExplicitMaxSize(BSize size)
{
 fLayout->SetExplicitMaxSize(size);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::SetExplicitPreferredSize(BSize size)
{
 fLayout->SetExplicitPreferredSize(size);
 return *this;
}


template<typename ParentBuilder>
typename Grid<ParentBuilder>::ThisBuilder&
Grid<ParentBuilder>::SetExplicitAlignment(BAlignment alignment)
{
 fLayout->SetExplicitAlignment(alignment);
 return *this;
}


template<typename ParentBuilder>
Grid<ParentBuilder>::operator BGridLayout*()
{
 return fLayout;
}





template<typename ParentBuilder>
Split<ParentBuilder>::Split(orientation orientation, float spacing)
 :
 fView(new BSplitView(orientation, spacing))
{
}


template<typename ParentBuilder>
Split<ParentBuilder>::Split(BSplitView* view)
 :
 fView(view)
{
}


template<typename ParentBuilder>
BSplitView*
Split<ParentBuilder>::View() const
{
 return fView;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::ThisBuilder&
Split<ParentBuilder>::GetView(BView** _view)
{
 *_view = fView;
 return *this;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::ThisBuilder&
Split<ParentBuilder>::GetSplitView(BSplitView** _view)
{
 *_view = fView;
 return *this;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::ThisBuilder&
Split<ParentBuilder>::Add(BView* view)
{
 fView->AddChild(view);
 return *this;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::ThisBuilder&
Split<ParentBuilder>::Add(BView* view, float weight)
{
 fView->AddChild(view, weight);
 return *this;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::ThisBuilder&
Split<ParentBuilder>::Add(BLayoutItem* item)
{
 fView->AddChild(item);
 return *this;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::ThisBuilder&
Split<ParentBuilder>::Add(BLayoutItem* item, float weight)
{
 fView->AddChild(item, weight);
 return *this;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::GroupBuilder
Split<ParentBuilder>::AddGroup(orientation orientation, float spacing,
  float weight)
{
 GroupBuilder builder(new BGroupLayout(orientation, spacing));
 builder.SetParent(this);
 fView->AddChild(builder.Layout(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::GroupBuilder
Split<ParentBuilder>::AddGroup(BGroupView* groupView, float weight)
{
 GroupBuilder builder(groupView);
 builder.SetParent(this);
 fView->AddChild(builder.Layout(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::GroupBuilder
Split<ParentBuilder>::AddGroup(BGroupLayout* groupLayout, float weight)
{
 GroupBuilder builder(groupLayout);
 builder.SetParent(this);
 fView->AddChild(builder.Layout(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::GridBuilder
Split<ParentBuilder>::AddGrid(float horizontalSpacing, float verticalSpacing,
 float weight)
{
 GridBuilder builder(new BGridLayout(horizontalSpacing, verticalSpacing));
 builder.SetParent(this);
 fView->AddChild(builder.Layout(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::GridBuilder
Split<ParentBuilder>::AddGrid(BGridView* gridView, float weight)
{
 GridBuilder builder(gridView);
 builder.SetParent(this);
 fView->AddChild(builder.Layout(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::GridBuilder
Split<ParentBuilder>::AddGrid(BGridLayout* layout, float weight)
{
 GridBuilder builder(layout);
 builder.SetParent(this);
 fView->AddChild(builder.Layout(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::SplitBuilder
Split<ParentBuilder>::AddSplit(orientation orientation, float spacing,
  float weight)
{
 SplitBuilder builder(orientation, spacing);
 builder.SetParent(this);
 fView->AddChild(builder.View(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::CardBuilder
Split<ParentBuilder>::AddCards(float weight)
{
 CardBuilder builder;
 builder.SetParent(this);
 fView->AddChild(builder.View(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::CardBuilder
Split<ParentBuilder>::AddCards(BCardLayout* cardLayout, float weight)
{
 CardBuilder builder(cardLayout);
 builder.SetParent(this);
 fView->AddChild(builder.View(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::CardBuilder
Split<ParentBuilder>::AddCards(BCardView* cardView, float weight)
{
 CardBuilder builder(cardView);
 builder.SetParent(this);
 fView->AddChild(builder.View(), weight);
 return builder;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::ThisBuilder&
Split<ParentBuilder>::SetCollapsible(bool collapsible)
{
 fView->SetCollapsible(collapsible);
 return *this;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::ThisBuilder&
Split<ParentBuilder>::SetCollapsible(int32 index, bool collapsible)
{
 fView->SetCollapsible(index, collapsible);
 return *this;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::ThisBuilder&
Split<ParentBuilder>::SetCollapsible(int32 first, int32 last, bool collapsible)
{
 fView->SetCollapsible(first, last, collapsible);
 return *this;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::ThisBuilder&
Split<ParentBuilder>::SetInsets(float left, float top, float right,
 float bottom)
{
 fView->SetInsets(left, top, right, bottom);
 return *this;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::ThisBuilder&
Split<ParentBuilder>::SetInsets(float horizontal, float vertical)
{
 fView->SetInsets(horizontal, vertical);
 return *this;
}


template<typename ParentBuilder>
typename Split<ParentBuilder>::ThisBuilder&
Split<ParentBuilder>::SetInsets(float insets)
{
 fView->SetInsets(insets);
 return *this;
}


template<typename ParentBuilder>
Split<ParentBuilder>::operator BSplitView*()
{
 return fView;
}





template<typename ParentBuilder>
Cards<ParentBuilder>::Cards()
 :
 fLayout((new BCardView())->CardLayout())
{
}


template<typename ParentBuilder>
Cards<ParentBuilder>::Cards(BWindow* window)
 :
 fLayout(new BCardLayout())
{
 window->SetLayout(fLayout);

 fLayout->Owner()->SetViewColor(ui_color(B_PANEL_BACKGROUND_COLOR));
}


template<typename ParentBuilder>
Cards<ParentBuilder>::Cards(BView* view)
 :
 fLayout(new BCardLayout())
{
 view->SetLayout(fLayout);
 view->SetViewColor(ui_color(B_PANEL_BACKGROUND_COLOR));
}


template<typename ParentBuilder>
Cards<ParentBuilder>::Cards(BCardLayout* layout)
 :
 fLayout(layout)
{
}


template<typename ParentBuilder>
Cards<ParentBuilder>::Cards(BCardView* view)
 :
 fLayout(view->CardLayout())
{
}


template<typename ParentBuilder>
BCardLayout*
Cards<ParentBuilder>::Layout() const
{
 return fLayout;
}


template<typename ParentBuilder>
BView*
Cards<ParentBuilder>::View() const
{
 return fLayout->Owner();
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::ThisBuilder&
Cards<ParentBuilder>::GetLayout(BCardLayout** _layout)
{
 *_layout = fLayout;
 return *this;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::ThisBuilder&
Cards<ParentBuilder>::GetView(BView** _view)
{
 *_view = fLayout->Owner();
 return *this;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::ThisBuilder&
Cards<ParentBuilder>::Add(BView* view)
{
 fLayout->AddView(view);
 return *this;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::ThisBuilder&
Cards<ParentBuilder>::Add(BLayoutItem* item)
{
 fLayout->AddItem(item);
 return *this;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::GroupBuilder
Cards<ParentBuilder>::AddGroup(orientation orientation, float spacing)
{
 GroupBuilder builder(new BGroupLayout(orientation, spacing));
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout());
 return builder;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::GroupBuilder
Cards<ParentBuilder>::AddGroup(BGroupView* groupView)
{
 GroupBuilder builder(groupView);
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout());
 return builder;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::GroupBuilder
Cards<ParentBuilder>::AddGroup(BGroupLayout* groupLayout)
{
 GroupBuilder builder(groupLayout);
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout());
 return builder;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::GridBuilder
Cards<ParentBuilder>::AddGrid(float horizontal, float vertical)
{
 GridBuilder builder(horizontal, vertical);
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout());
 return builder;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::GridBuilder
Cards<ParentBuilder>::AddGrid(BGridLayout* gridLayout)
{
 GridBuilder builder(gridLayout);
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout());
 return builder;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::GridBuilder
Cards<ParentBuilder>::AddGrid(BGridView* gridView)
{
 GridBuilder builder(gridView);
 builder.SetParent(this);
 fLayout->AddItem(builder.Layout());
 return builder;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::SplitBuilder
Cards<ParentBuilder>::AddSplit(orientation orientation, float spacing)
{
 SplitBuilder builder(orientation, spacing);
 builder.SetParent(this);
 fLayout->AddView(builder.View());
 return builder;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::SplitBuilder
Cards<ParentBuilder>::AddSplit(BSplitView* splitView)
{
 SplitBuilder builder(splitView);
 builder.SetParent(this);
 fLayout->AddView(builder.View());
 return builder;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::CardBuilder
Cards<ParentBuilder>::AddCards()
{
 CardBuilder builder;
 builder.SetParent(this);
 fLayout->AddView(builder.View());
 return builder;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::CardBuilder
Cards<ParentBuilder>::AddCards(BCardLayout* cardLayout)
{
 CardBuilder builder(cardLayout);
 builder.SetParent(this);
 fLayout->AddView(builder.View());
 return builder;
}

template<typename ParentBuilder>
typename Cards<ParentBuilder>::CardBuilder
Cards<ParentBuilder>::AddCards(BCardView* cardView)
{
 CardBuilder builder(cardView);
 builder.SetParent(this);
 fLayout->AddView(builder.View());
 return builder;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::ThisBuilder&
Cards<ParentBuilder>::SetExplicitMinSize(BSize size)
{
 fLayout->SetExplicitMinSize(size);
 return *this;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::ThisBuilder&
Cards<ParentBuilder>::SetExplicitMaxSize(BSize size)
{
 fLayout->SetExplicitMaxSize(size);
 return *this;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::ThisBuilder&
Cards<ParentBuilder>::SetExplicitPreferredSize(BSize size)
{
 fLayout->SetExplicitPreferredSize(size);
 return *this;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::ThisBuilder&
Cards<ParentBuilder>::SetExplicitAlignment(BAlignment alignment)
{
 fLayout->SetExplicitAlignment(alignment);
 return *this;
}


template<typename ParentBuilder>
typename Cards<ParentBuilder>::ThisBuilder&
Cards<ParentBuilder>::SetVisibleItem(int32 item)
{
 fLayout->SetVisibleItem(item);
 return *this;
}


template<typename ParentBuilder>
Cards<ParentBuilder>::operator BCardLayout*()
{
 return fLayout;
}





template<typename ParentBuilder>
Menu<ParentBuilder>::Menu(BMenu* menu)
 :
 fMenu(menu)
{
}


template<typename ParentBuilder>
typename Menu<ParentBuilder>::ThisBuilder&
Menu<ParentBuilder>::GetMenu(BMenu*& _menu)
{
 _menu = fMenu;
 return *this;
}


template<typename ParentBuilder>
typename Menu<ParentBuilder>::ItemBuilder
Menu<ParentBuilder>::AddItem(BMenuItem* item)
{
 fMenu->AddItem(item);
 return MenuItem<ParentBuilder>(this->fParent, fMenu, item);
}


template<typename ParentBuilder>
typename Menu<ParentBuilder>::ItemBuilder
Menu<ParentBuilder>::AddItem(BMenu* menu)
{
 if (!fMenu->AddItem(menu))
  throw std::bad_alloc();

 return MenuItem<ParentBuilder>(this->fParent, fMenu,
  fMenu->ItemAt(fMenu->CountItems() - 1));
}


template<typename ParentBuilder>
typename Menu<ParentBuilder>::ItemBuilder
Menu<ParentBuilder>::AddItem(const char* label, BMessage* message,
 char shortcut, uint32 modifiers)
{
 BMenuItem* item = new BMenuItem(label, message, shortcut, modifiers);
 if (!fMenu->AddItem(item)) {
  delete item;
  item = __null;
 }

 return MenuItem<ParentBuilder>(this->fParent, fMenu, item);
}


template<typename ParentBuilder>
typename Menu<ParentBuilder>::ItemBuilder
Menu<ParentBuilder>::AddItem(const char* label, uint32 messageWhat,
 char shortcut, uint32 modifiers)
{
 BMessage* message = new BMessage(messageWhat);
 BMenuItem* item;
 try {
  item = new BMenuItem(label, message, shortcut, modifiers);
 } catch (...) {
  delete message;
  throw;
 }

 if (!fMenu->AddItem(item)) {
  delete item;
  item = __null;
 }

 return MenuItem<ParentBuilder>(this->fParent, fMenu, item);
}


template<typename ParentBuilder>
typename Menu<ParentBuilder>::ThisBuilder&
Menu<ParentBuilder>::AddSeparator()
{
 fMenu->AddSeparatorItem();
 return *this;
}


template<typename ParentBuilder>
typename Menu<ParentBuilder>::MenuBuilder
Menu<ParentBuilder>::AddMenu(BMenu* menu)
{
 if (!fMenu->AddItem(menu))
  throw std::bad_alloc();

 MenuBuilder builder(menu);
 builder.SetParent(this);
 return builder;
}


template<typename ParentBuilder>
typename Menu<ParentBuilder>::MenuBuilder
Menu<ParentBuilder>::AddMenu(const char* title, menu_layout layout)
{
 BMenu* menu = new BMenu(title, layout);
 if (!fMenu->AddItem(menu)) {
  delete menu;
  throw std::bad_alloc();
 }

 MenuBuilder builder(menu);
 builder.SetParent(this);
 return builder;
}





template<typename ParentBuilder>
MenuItem<ParentBuilder>::MenuItem(ParentBuilder* parentBuilder, BMenu* menu,
 BMenuItem* item)
 :
 Menu<ParentBuilder>(menu),
 fMenuItem(item)
{
 this->SetParent(parentBuilder);
}


template<typename ParentBuilder>
typename MenuItem<ParentBuilder>::ThisBuilder&
MenuItem<ParentBuilder>::GetItem(BMenuItem*& _item)
{
 _item = fMenuItem;
 return *this;
}


template<typename ParentBuilder>
typename MenuItem<ParentBuilder>::ThisBuilder&
MenuItem<ParentBuilder>::SetEnabled(bool enabled)
{
 fMenuItem->SetEnabled(enabled);
 return *this;
}


}






const ModifierBox::MaskListType ModifierBox::ModifierList[] =
{
 { B_SHIFT_KEY, 
                 B_CATKEY((
                 "Shift"
                 ), 
                 "ModifierBox"
                 ) 
                                      },
 { B_CONTROL_KEY, 
                 B_CATKEY((
                 "Control"
                 ), 
                 "ModifierBox"
                 ) 
                                        },
 { B_COMMAND_KEY, 
                 B_CATKEY((
                 "Command"
                 ), 
                 "ModifierBox"
                 ) 
                                        },
 { B_OPTION_KEY, 
                 B_CATKEY((
                 "Option"
                 ), 
                 "ModifierBox"
                 ) 
                                       },
 { B_MENU_KEY, 
                 B_CATKEY((
                 "Menu"
                 ), 
                 "ModifierBox"
                 ) 
                                     }
};


ModifierBox::ModifierBox(const char* label, uint32 modifier, uint32 )
 :
 BBox(label),
 fDefaultModifier(0)
{
 if (label)
  SetLabel(label);

 fModifierViewList = new ModifierView*[5];

 fModifierViewList[0] = new ModifierView(ModifierList[0].mask,
  ModifierList[0].label, ModifierList[0].mask & modifier, new BMessage(MODIFIER_CHANGED));
 fModifierViewList[1] = new ModifierView(ModifierList[1].mask,
  ModifierList[1].label, ModifierList[1].mask & modifier, new BMessage(MODIFIER_CHANGED));
 fModifierViewList[2] = new ModifierView(ModifierList[2].mask,
  ModifierList[2].label, ModifierList[2].mask & modifier, new BMessage(MODIFIER_CHANGED));
 fModifierViewList[3] = new ModifierView(ModifierList[3].mask,
  ModifierList[3].label, ModifierList[3].mask & modifier, new BMessage(MODIFIER_CHANGED));
 fModifierViewList[4] = new ModifierView(ModifierList[4].mask,
  ModifierList[4].label, ModifierList[4].mask & modifier, new BMessage(MODIFIER_CHANGED));

 BLayoutBuilder::Group<>(this, B_HORIZONTAL, B_USE_DEFAULT_SPACING)
  .SetInsets(B_USE_ITEM_INSETS)
  .AddGroup(B_VERTICAL, 0)
   .SetInsets(0, B_USE_DEFAULT_SPACING, 0, 0)
   .Add(fModifierViewList[0])
   .Add(fModifierViewList[1])
   .Add(fModifierViewList[2])
  .End()
  .AddGroup(B_VERTICAL, 0)
   .SetInsets(0, B_USE_DEFAULT_SPACING, 0, 0)
   .Add(fModifierViewList[3])
   .Add(fModifierViewList[4])
   .AddGlue()
  .End();
}


ModifierBox::~ModifierBox()
{
 delete fModifierViewList;
}


void
ModifierBox::MessageReceived(BMessage* message)
{
 uint32 mask = 0;

 switch (message->what) {
  case MODIFIER_CHANGED:
   for (int32 i = 0; i < 5; i++)
    mask |= fModifierViewList[i]->GetMask();
   if (!mask) {
    mask = fDefaultModifier;
    for (int32 i = 0; i < 5; i++)
     fModifierViewList[i]->SetValue(ModifierList[i].mask & mask);
   }
   InvokeNotify(Message());
   break;

  default:
   BBox::MessageReceived(message);
 }
}


void
ModifierBox::AttachedToWindow()
{
 for (int32 i = 0; i < 5; i++)
  fModifierViewList[i]->SetTarget(this);
}


uint32
ModifierBox::GetModifierMask()
{
 uint32 mask = 0;

 for (int32 i = 0; i < 5; i++)
  mask |= fModifierViewList[i]->GetMask();

 return mask;
}


void
ModifierBox::SetModifierMask(uint32 mask)
{
 for (int32 i = 0; i < 5; i++)
  fModifierViewList[i]->SetValue(ModifierList[i].mask & mask);
}


void
ModifierBox::SetDefaultModifierMask(uint32 mask)
{
 fDefaultModifier = mask;
}


void
ModifierBox::SetEnabled(bool enabled)
{
 for (int i = 0; i < 5; i++)
  fModifierViewList[i]->SetEnabled(enabled);

 fControlsEnabled = enabled;
}
ModifierView::ModifierView(uint32 modifierMask, const char* label, bool initialValue, BMessage* msg)
 :
 BCheckBox(
          __null
              , label, msg),
 fModifierMask(modifierMask)
{
 SetValue(initialValue);
}


ModifierView::~ModifierView()
{
}


uint32
ModifierView::GetMask()
{
 if (Value())
  return fModifierMask;

 return 0;
}

typedef struct dirent {
 dev_t d_dev;
 dev_t d_pdev;
 ino_t d_ino;
 ino_t d_pino;
 unsigned short d_reclen;



 char d_name[];

} dirent_t;

typedef struct __DIR DIR;
extern "C" {


DIR* fdopendir(int fd);
DIR* opendir(const char* dirName);
struct dirent* readdir(DIR* dir);
int readdir_r(DIR* dir, struct dirent* entry,
     struct dirent** _result);
int closedir(DIR* dir);
void rewinddir(DIR* dir);
void seekdir(DIR* dir, long int position);
long int telldir(DIR* dir);
int dirfd(DIR* dir);

int alphasort(const struct dirent** entry1,
     const struct dirent** entry2);
int scandir(const char* dir, struct dirent*** _entryArray,
     int (*selectFunc)(const struct dirent*),
     int (*compareFunc)(const struct dirent** entry1,
      const struct dirent** entry2));


}




class BEntry;
struct entry_ref;






class BEntryList {
public:
        BEntryList();
 virtual ~BEntryList();

 virtual status_t GetNextEntry(BEntry* entry,
         bool traverse = false) = 0;
 virtual status_t GetNextRef(entry_ref* ref) = 0;
 virtual int32 GetNextDirents(struct dirent* direntBuffer,
         size_t bufferSize,
         int32 maxEntries = 0x7fffffff) = 0;
 virtual status_t Rewind() = 0;
 virtual int32 CountEntries() = 0;

private:
 virtual void _ReservedEntryList1();
 virtual void _ReservedEntryList2();
 virtual void _ReservedEntryList3();
 virtual void _ReservedEntryList4();
 virtual void _ReservedEntryList5();
 virtual void _ReservedEntryList6();
 virtual void _ReservedEntryList7();
 virtual void _ReservedEntryList8();
};



class BFile;
class BSymLink;
struct stat_beos;


class BDirectory : public BNode, public BEntryList {
 public:
  BDirectory();
  BDirectory(const BDirectory &dir);
  BDirectory(const entry_ref *ref);
  BDirectory(const node_ref *nref);
  BDirectory(const BEntry *entry);
  BDirectory(const char *path);
  BDirectory(const BDirectory *dir, const char *path);

  virtual ~BDirectory();

  status_t SetTo(const entry_ref *ref);
  status_t SetTo(const node_ref *nref);
  status_t SetTo(const BEntry *entry);
  status_t SetTo(const char *path);
  status_t SetTo(const BDirectory *dir, const char *path);

  status_t GetEntry(BEntry *entry) const;

  bool IsRootDirectory() const;

  status_t FindEntry(const char *path, BEntry *entry,
   bool traverse = false) const;

  bool Contains(const char *path, int32 nodeFlags = B_ANY_NODE) const;
  bool Contains(const BEntry *entry, int32 nodeFlags = B_ANY_NODE) const;

  status_t GetStatFor(const char *path, struct stat *st) const;

  virtual status_t GetNextEntry(BEntry *entry, bool traverse = false);
  virtual status_t GetNextRef(entry_ref *ref);
  virtual int32 GetNextDirents(dirent *buf, size_t bufSize,
   int32 count = 0x7fffffff);
  virtual status_t Rewind();
  virtual int32 CountEntries();

  status_t CreateDirectory(const char *path, BDirectory *dir);
  status_t CreateFile(const char *path, BFile *file,
   bool failIfExists = false);
  status_t CreateSymLink(const char *path, const char *linkToPath,
   BSymLink *link);

  BDirectory &operator=(const BDirectory &dir);

 private:
  friend class BNode;
  friend class BEntry;
  friend class BFile;

  status_t _GetStatFor(const char *path, struct stat *st) const;
  status_t _GetStatFor(const char *path, struct stat_beos *st) const;

  virtual void _ErectorDirectory1();
  virtual void _ErectorDirectory2();
  virtual void _ErectorDirectory3();
  virtual void _ErectorDirectory4();
  virtual void _ErectorDirectory5();
  virtual void _ErectorDirectory6();

 private:
  virtual void close_fd();
  int get_fd() const;

 private:
  uint32 _reservedData[7];
  int fDirFd;
};

status_t create_directory(const char *path, mode_t mode);
class BEntry;


class BFile : public BNode, public BPositionIO {
 public:
  BFile();
  BFile(const BFile &file);
  BFile(const entry_ref *ref, uint32 openMode);
  BFile(const BEntry *entry, uint32 openMode);
  BFile(const char *path, uint32 openMode);
  BFile(const BDirectory *dir, const char *path, uint32 openMode);
  virtual ~BFile();

  status_t SetTo(const entry_ref *ref, uint32 openMode);
  status_t SetTo(const BEntry *entry, uint32 openMode);
  status_t SetTo(const char *path, uint32 openMode);
  status_t SetTo(const BDirectory *dir, const char *path, uint32 openMode);

  bool IsReadable() const;
  bool IsWritable() const;

  virtual ssize_t Read(void *buffer, size_t size);
  virtual ssize_t ReadAt(off_t location, void *buffer, size_t size);
  virtual ssize_t Write(const void *buffer, size_t size);
  virtual ssize_t WriteAt(off_t location, const void *buffer, size_t size);

  virtual off_t Seek(off_t offset, uint32 seekMode);
  virtual off_t Position() const;

  virtual status_t SetSize(off_t size);
  virtual status_t GetSize(off_t* size) const;

  BFile &operator=(const BFile &file);

 private:
  virtual void _PhiloFile1();
  virtual void _PhiloFile2();
  virtual void _PhiloFile3();
  virtual void _PhiloFile4();
  virtual void _PhiloFile5();
  virtual void _PhiloFile6();

  uint32 _reservedData[8];

 private:
  int get_fd() const;
  virtual void close_fd();

 private:

  uint32 fMode;
};
typedef enum {

 B_DESKTOP_DIRECTORY = 0,
 B_TRASH_DIRECTORY,


 B_SYSTEM_DIRECTORY = 1000,
 B_SYSTEM_ADDONS_DIRECTORY = 1002,
 B_SYSTEM_BOOT_DIRECTORY,
 B_SYSTEM_FONTS_DIRECTORY,
 B_SYSTEM_LIB_DIRECTORY,
 B_SYSTEM_SERVERS_DIRECTORY,
 B_SYSTEM_APPS_DIRECTORY,
 B_SYSTEM_BIN_DIRECTORY,
 B_SYSTEM_DOCUMENTATION_DIRECTORY = 1010,
 B_SYSTEM_PREFERENCES_DIRECTORY,
 B_SYSTEM_TRANSLATORS_DIRECTORY,
 B_SYSTEM_MEDIA_NODES_DIRECTORY,
 B_SYSTEM_SOUNDS_DIRECTORY,
 B_SYSTEM_DATA_DIRECTORY,
 B_SYSTEM_DEVELOP_DIRECTORY,
 B_SYSTEM_PACKAGES_DIRECTORY,
 B_SYSTEM_HEADERS_DIRECTORY,

 B_SYSTEM_ETC_DIRECTORY = 2008,
 B_SYSTEM_SETTINGS_DIRECTORY = 2010,
 B_SYSTEM_LOG_DIRECTORY = 2012,
 B_SYSTEM_SPOOL_DIRECTORY,
 B_SYSTEM_TEMP_DIRECTORY,
 B_SYSTEM_VAR_DIRECTORY,
 B_SYSTEM_CACHE_DIRECTORY = 2020,

 B_SYSTEM_NONPACKAGED_DIRECTORY = 2023,
 B_SYSTEM_NONPACKAGED_ADDONS_DIRECTORY,
 B_SYSTEM_NONPACKAGED_TRANSLATORS_DIRECTORY,
 B_SYSTEM_NONPACKAGED_MEDIA_NODES_DIRECTORY,
 B_SYSTEM_NONPACKAGED_BIN_DIRECTORY,
 B_SYSTEM_NONPACKAGED_DATA_DIRECTORY,
 B_SYSTEM_NONPACKAGED_FONTS_DIRECTORY,
 B_SYSTEM_NONPACKAGED_SOUNDS_DIRECTORY,
 B_SYSTEM_NONPACKAGED_DOCUMENTATION_DIRECTORY,
 B_SYSTEM_NONPACKAGED_LIB_DIRECTORY,
 B_SYSTEM_NONPACKAGED_HEADERS_DIRECTORY,
 B_SYSTEM_NONPACKAGED_DEVELOP_DIRECTORY,



 B_USER_DIRECTORY = 3000,
 B_USER_CONFIG_DIRECTORY,
 B_USER_ADDONS_DIRECTORY,
 B_USER_BOOT_DIRECTORY,
 B_USER_FONTS_DIRECTORY,
 B_USER_LIB_DIRECTORY,
 B_USER_SETTINGS_DIRECTORY,
 B_USER_DESKBAR_DIRECTORY,
 B_USER_PRINTERS_DIRECTORY,
 B_USER_TRANSLATORS_DIRECTORY,
 B_USER_MEDIA_NODES_DIRECTORY,
 B_USER_SOUNDS_DIRECTORY,
 B_USER_DATA_DIRECTORY,
 B_USER_CACHE_DIRECTORY,
 B_USER_PACKAGES_DIRECTORY,
 B_USER_HEADERS_DIRECTORY,
 B_USER_NONPACKAGED_DIRECTORY,
 B_USER_NONPACKAGED_ADDONS_DIRECTORY,
 B_USER_NONPACKAGED_TRANSLATORS_DIRECTORY,
 B_USER_NONPACKAGED_MEDIA_NODES_DIRECTORY,
 B_USER_NONPACKAGED_BIN_DIRECTORY,
 B_USER_NONPACKAGED_DATA_DIRECTORY,
 B_USER_NONPACKAGED_FONTS_DIRECTORY,
 B_USER_NONPACKAGED_SOUNDS_DIRECTORY,
 B_USER_NONPACKAGED_DOCUMENTATION_DIRECTORY,
 B_USER_NONPACKAGED_LIB_DIRECTORY,
 B_USER_NONPACKAGED_HEADERS_DIRECTORY,
 B_USER_NONPACKAGED_DEVELOP_DIRECTORY,
 B_USER_DEVELOP_DIRECTORY,
 B_USER_DOCUMENTATION_DIRECTORY,
 B_USER_SERVERS_DIRECTORY,
 B_USER_APPS_DIRECTORY,
 B_USER_BIN_DIRECTORY,
 B_USER_PREFERENCES_DIRECTORY,
 B_USER_ETC_DIRECTORY,
 B_USER_LOG_DIRECTORY,
 B_USER_SPOOL_DIRECTORY,
 B_USER_VAR_DIRECTORY,


 B_APPS_DIRECTORY = 4000,
 B_PREFERENCES_DIRECTORY,
 B_UTILITIES_DIRECTORY,
 B_PACKAGE_LINKS_DIRECTORY,


 B_BEOS_DIRECTORY = 1000,
 B_BEOS_SYSTEM_DIRECTORY,
 B_BEOS_ADDONS_DIRECTORY,
 B_BEOS_BOOT_DIRECTORY,
 B_BEOS_FONTS_DIRECTORY,
 B_BEOS_LIB_DIRECTORY,
 B_BEOS_SERVERS_DIRECTORY,
 B_BEOS_APPS_DIRECTORY,
 B_BEOS_BIN_DIRECTORY,
 B_BEOS_ETC_DIRECTORY,
 B_BEOS_DOCUMENTATION_DIRECTORY,
 B_BEOS_PREFERENCES_DIRECTORY,
 B_BEOS_TRANSLATORS_DIRECTORY,
 B_BEOS_MEDIA_NODES_DIRECTORY,
 B_BEOS_SOUNDS_DIRECTORY,
} directory_which;



enum {
 B_FIND_PATH_CREATE_DIRECTORY = 0x0001,
 B_FIND_PATH_CREATE_PARENT_DIRECTORY = 0x0002,
 B_FIND_PATH_EXISTING_ONLY = 0x0004,

 B_FIND_PATHS_SYSTEM_ONLY = 0x0010,
 B_FIND_PATHS_USER_ONLY = 0x0020,
};


typedef enum path_base_directory {
 B_FIND_PATH_INSTALLATION_LOCATION_DIRECTORY,
 B_FIND_PATH_ADD_ONS_DIRECTORY,
 B_FIND_PATH_APPS_DIRECTORY,
 B_FIND_PATH_BIN_DIRECTORY,
 B_FIND_PATH_BOOT_DIRECTORY,
 B_FIND_PATH_CACHE_DIRECTORY,
 B_FIND_PATH_DATA_DIRECTORY,
 B_FIND_PATH_DEVELOP_DIRECTORY,
 B_FIND_PATH_DEVELOP_LIB_DIRECTORY,
 B_FIND_PATH_DOCUMENTATION_DIRECTORY,
 B_FIND_PATH_ETC_DIRECTORY,
 B_FIND_PATH_FONTS_DIRECTORY,
 B_FIND_PATH_HEADERS_DIRECTORY,
 B_FIND_PATH_LIB_DIRECTORY,
 B_FIND_PATH_LOG_DIRECTORY,
 B_FIND_PATH_MEDIA_NODES_DIRECTORY,
 B_FIND_PATH_PACKAGES_DIRECTORY,
 B_FIND_PATH_PREFERENCES_DIRECTORY,
 B_FIND_PATH_SERVERS_DIRECTORY,
 B_FIND_PATH_SETTINGS_DIRECTORY,
 B_FIND_PATH_SOUNDS_DIRECTORY,
 B_FIND_PATH_SPOOL_DIRECTORY,
 B_FIND_PATH_TRANSLATORS_DIRECTORY,
 B_FIND_PATH_VAR_DIRECTORY,


 B_FIND_PATH_IMAGE_PATH = 1000,
 B_FIND_PATH_PACKAGE_PATH,
} path_base_directory;



extern "C" {




status_t find_directory(directory_which which, dev_t volume, bool createIt,
 char* pathString, int32 length);

status_t find_path(const void* codePointer, path_base_directory baseDirectory,
 const char* subPath, char* pathBuffer, size_t bufferSize);

status_t find_path_etc(const void* codePointer, const char* dependency,
 const char* architecture, path_base_directory baseDirectory,
 const char* subPath, uint32 flags, char* pathBuffer, size_t bufferSize);

status_t find_path_for_path(const char* path, path_base_directory baseDirectory,
 const char* subPath, char* pathBuffer, size_t bufferSize);

status_t find_path_for_path_etc(const char* path, const char* dependency,
 const char* architecture, path_base_directory baseDirectory,
 const char* subPath, uint32 flags, char* pathBuffer, size_t bufferSize);

status_t find_paths(path_base_directory baseDirectory, const char* subPath,
 char*** _paths, size_t* _pathCount);

status_t find_paths_etc(const char* architecture,
 path_base_directory baseDirectory, const char* subPath, uint32 flags,
 char*** _paths, size_t* _pathCount);



}



class BVolume;
class BPath;


status_t find_directory(directory_which which, BPath* path,
 bool createIt = false, BVolume* volume = __null);
class BDirectory;
class BEntry;
struct entry_ref;


class BPath : public BFlattenable {
public:
       BPath();
       BPath(const BPath& path);
       BPath(const entry_ref* ref);
       BPath(const BEntry* entry);
       BPath(const char* dir, const char* leaf = __null,
        bool normalize = false);
       BPath(const BDirectory* dir,
        const char* leaf = __null,
        bool normalize = false);

 virtual ~BPath();

   status_t InitCheck() const;

   status_t SetTo(const entry_ref* ref);
   status_t SetTo(const BEntry* entry);
   status_t SetTo(const char* path, const char* leaf = __null,
        bool normalize = false);
   status_t SetTo(const BDirectory* dir,
        const char* leaf = __null,
        bool normalize = false);
   void Unset();

   status_t Append(const char* path, bool normalize = false);

   const char* Path() const;
   const char* Leaf() const;
   status_t GetParent(BPath* path) const;
   bool IsAbsolute() const;

   bool operator==(const BPath& item) const;
   bool operator==(const char* path) const;
   bool operator!=(const BPath& item) const;
   bool operator!=(const char* path) const;
   BPath& operator=(const BPath& item);
   BPath& operator=(const char* path);


 virtual bool IsFixedSize() const;
 virtual type_code TypeCode() const;
 virtual ssize_t FlattenedSize() const;
 virtual status_t Flatten(void* buffer, ssize_t size) const;
 virtual bool AllowsTypeCode(type_code code) const;
 virtual status_t Unflatten(type_code code, const void* buffer,
        ssize_t size);

private:
 virtual void _WarPath1();
 virtual void _WarPath2();
 virtual void _WarPath3();

   status_t _SetPath(const char* path);
 static bool _MustNormalize(const char* path, status_t* _error);

   uint32 _reserved[4];

   char* fName;

   status_t fCStatus;

};





Preferences::Preferences()
{
 Load();
}


Preferences::~Preferences()
{

 Save();

}


void
Preferences::Update()
{
 Load();
}


void
Preferences::SetToDefault()
{
 SetToggleModMask(GetDefaultToggleModMask());
 SetClickKeyMask(GetDefaultClickKeyMask());
 SetEnabledToDefault();
 SetDefaultAcceleration();


 fCorner.x = 10000;
 fCorner.y = 10000;

}


BFile*
Preferences::OpenFile(uint32 openMode)
{
 BPath path;
 find_directory(B_USER_SETTINGS_DIRECTORY, &path);
 BDirectory dir(path.Path());
 BFile* file = new BFile(&dir, "KeyCursor", openMode);
 status_t err;
 err = file->InitCheck();

 if (err != 
           ((int)0)
               ) {
  delete file;
  return 0;
 }

 return file;
}


void
Preferences::Load()
{
 SetToDefault();

 BFile* file = OpenFile(
                       0x0000
                                  );

 if (!file)
  return;

 file->Read(&fToggleModMask, sizeof(uint32));
 file->Read(&fClickKeyMask, sizeof(uint32));
 file->Read(&fEnabled, sizeof(bool));
 file->Read(&fAcceleration, sizeof(float));


 if (file->Read(&fCorner, sizeof(BPoint)) != sizeof(BPoint)) {
  fCorner.x = 50;
  fCorner.y = 50;
 };


 delete file;
}




void
Preferences::Save()
{
 BFile* file = OpenFile(
                       0x0001 
                                    | 
                                      0x0200
                                                   );

 if (!file)
  return;

 file->Write(&fToggleModMask, sizeof(uint32));
 file->Write(&fClickKeyMask, sizeof(uint32));
 file->Write(&fEnabled, sizeof(bool));
 file->Write(&fAcceleration, sizeof(float));
 file->Write(&fCorner, sizeof(BPoint));

 delete file;
}


void
Preferences::SetWindowCorner(BPoint corner)
{
 fCorner = corner;
}
 
extern "C" {







typedef void* (*GetAccelerantHook)(uint32, void*);

void* get_accelerant_hook(uint32 feature, void* data);


enum {

 B_INIT_ACCELERANT = 0,
 B_ACCELERANT_CLONE_INFO_SIZE,
 B_GET_ACCELERANT_CLONE_INFO,
 B_CLONE_ACCELERANT,
 B_UNINIT_ACCELERANT,
 B_GET_ACCELERANT_DEVICE_INFO,
 B_ACCELERANT_RETRACE_SEMAPHORE,


 B_ACCELERANT_MODE_COUNT = 0x100,
 B_GET_MODE_LIST,
 B_PROPOSE_DISPLAY_MODE,
 B_SET_DISPLAY_MODE,
 B_GET_DISPLAY_MODE,
 B_GET_FRAME_BUFFER_CONFIG,
 B_GET_PIXEL_CLOCK_LIMITS,
 B_GET_TIMING_CONSTRAINTS,
 B_MOVE_DISPLAY,
 B_SET_INDEXED_COLORS,

 B_DPMS_CAPABILITIES,
 B_DPMS_MODE,
 B_SET_DPMS_MODE,
 B_GET_PREFERRED_DISPLAY_MODE,
 B_GET_MONITOR_INFO,
 B_GET_EDID_INFO,
 B_SET_BRIGHTNESS,
 B_GET_BRIGHTNESS,


 B_MOVE_CURSOR = 0x200,
 B_SET_CURSOR_SHAPE,
 B_SHOW_CURSOR,
 B_SET_CURSOR_BITMAP,


 B_ACCELERANT_ENGINE_COUNT = 0x300,
 B_ACQUIRE_ENGINE,
 B_RELEASE_ENGINE,
 B_WAIT_ENGINE_IDLE,
 B_GET_SYNC_TOKEN,
 B_SYNC_TO_TOKEN,


 B_SCREEN_TO_SCREEN_BLIT = 0x400,
 B_FILL_RECTANGLE,
 B_INVERT_RECTANGLE,
 B_FILL_SPAN,
 B_SCREEN_TO_SCREEN_TRANSPARENT_BLIT,
 B_SCREEN_TO_SCREEN_SCALED_FILTERED_BLIT,



 B_ACCELERANT_PRIVATE_START = (int)0x80000000
};


typedef struct {
 uint32 version;
 char name[32];

 char chipset[32];
 char serial_no[32];
 uint32 memory;

 uint32 dac_speed;
} accelerant_device_info;


typedef struct {
 uint32 pixel_clock;
 uint16 h_display;
 uint16 h_sync_start;
 uint16 h_sync_end;
 uint16 h_total;
 uint16 v_display;
 uint16 v_sync_start;
 uint16 v_sync_end;
 uint16 v_total;
 uint32 flags;
} display_timing;


typedef struct {
 display_timing timing;
 uint32 space;
 uint16 virtual_width;
 uint16 virtual_height;
 uint16 h_display_start;
 uint16 v_display_start;
 uint32 flags;

} display_mode;

typedef struct {
 void* frame_buffer;


 void* frame_buffer_dma;


 uint32 bytes_per_row;



} frame_buffer_config;


typedef struct {
 uint16 h_res;


 uint16 h_sync_min;


 uint16 h_sync_max;
 uint16 h_blank_min;


 uint16 h_blank_max;
 uint16 v_res;


 uint16 v_sync_min;


 uint16 v_sync_max;
 uint16 v_blank_min;


 uint16 v_blank_max;
} display_timing_constraints;



typedef struct {
 uint32 version;
 char vendor[128];
 char name[128];
 char serial_number[128];
 uint32 product_id;
 struct {
  uint16 week;
  uint16 year;
 } produced;
 float width;
 float height;
 uint32 min_horizontal_frequency;
 uint32 max_horizontal_frequency;
 uint32 min_vertical_frequency;
 uint32 max_vertical_frequency;
 uint32 max_pixel_clock;
} monitor_info;



enum {
 B_SCROLL = 1 << 0,
 B_8_BIT_DAC = 1 << 1,
 B_HARDWARE_CURSOR = 1 << 2,
 B_PARALLEL_ACCESS = 1 << 3,
 B_DPMS = 1 << 4,
 B_IO_FB_NA = 1 << 5
};



enum {
 B_DPMS_ON = 1 << 0,
 B_DPMS_STAND_BY = 1 << 1,
 B_DPMS_SUSPEND = 1 << 2,
 B_DPMS_OFF = 1 << 3
};



enum {
 B_BLANK_PEDESTAL = 1 << 27,
 B_TIMING_INTERLACED = 1 << 28,
 B_POSITIVE_HSYNC = 1 << 29,
 B_POSITIVE_VSYNC = 1 << 30,
 B_SYNC_ON_GREEN = 1 << 31
};


typedef struct {
 uint16 src_left;

 uint16 src_top;
 uint16 dest_left;
 uint16 dest_top;
 uint16 width;


 uint16 height;

} blit_params;


typedef struct {
 uint16 src_left;

 uint16 src_top;
 uint16 src_width;


 uint16 src_height;

 uint16 dest_left;
 uint16 dest_top;
 uint16 dest_width;

 uint16 dest_height;

} scaled_blit_params;


typedef struct {
 uint16 left;

 uint16 top;
 uint16 right;
 uint16 bottom;
} fill_rect_params;


typedef struct {
 uint32 engine_id;

 uint32 capability_mask;
 void* opaque;

} engine_token;


enum {
 B_2D_ACCELERATION = 1 << 0,
 B_3D_ACCELERATION = 1 << 1
};


typedef struct {
 uint64 counter;
 uint32 engine_id;
 char opaque[12];
} sync_token;
typedef status_t (*init_accelerant)(int fd);
typedef ssize_t (*accelerant_clone_info_size)(void);
typedef void (*get_accelerant_clone_info)(void* data);
typedef status_t (*clone_accelerant)(void* data);
typedef void (*uninit_accelerant)(void);
typedef status_t (*get_accelerant_device_info)(accelerant_device_info* adi);

typedef uint32 (*accelerant_mode_count)(void);
typedef status_t (*get_mode_list)(display_mode*);
typedef status_t (*propose_display_mode)(display_mode* target,
 display_mode* low, display_mode* high);
typedef status_t (*set_display_mode)(display_mode* modeToSet);
typedef status_t (*get_display_mode)(display_mode* currentMode);
typedef status_t (*get_frame_buffer_config)(frame_buffer_config* frameBuffer);
typedef status_t (*get_pixel_clock_limits)(display_mode* dm, uint32* low,
 uint32* high);
typedef status_t (*move_display_area)(uint16 hDisplayStart,
 uint16 vDisplayStart);
typedef status_t (*get_timing_constraints)(display_timing_constraints* dtc);
typedef void (*set_indexed_colors)(uint count, uint8 first,
 const uint8* colorData, uint32 flags);
typedef uint32 (*dpms_capabilities)(void);
typedef uint32 (*dpms_mode)(void);
typedef status_t (*set_dpms_mode)(uint32 dpms_flags);
typedef status_t (*get_preferred_display_mode)(display_mode* preferredMode);
typedef status_t (*get_monitor_info)(monitor_info* info);
typedef status_t (*get_edid_info)(void* info, uint32 size, uint32* _version);
typedef status_t (*set_brightness)(float brightness);
typedef status_t (*get_brightness)(float* brightness);

typedef sem_id (*accelerant_retrace_semaphore)(void);

typedef status_t (*set_cursor_shape)(uint16 width, uint16 height,
 uint16 hotX, uint16 hotY, const uint8* andMask, const uint8* xorMask);
typedef status_t (*set_cursor_bitmap)(uint16 width, uint16 height,
 uint16 hotX, uint16 hotY, color_space colorSpace, uint16 bytesPerRow,
 const uint8* bitmapData);
typedef void (*move_cursor)(uint16 x, uint16 y);
typedef void (*show_cursor)(bool isVisible);

typedef uint32 (*accelerant_engine_count)(void);
typedef status_t (*acquire_engine)(uint32 capabilities, uint32 maxWait,
 sync_token* st, engine_token** et);
typedef status_t (*release_engine)(engine_token* et, sync_token* st);
typedef void (*wait_engine_idle)(void);
typedef status_t (*get_sync_token)(engine_token* et, sync_token* st);
typedef status_t (*sync_to_token)(sync_token* st);

typedef void (*screen_to_screen_blit)(engine_token* et, blit_params* list,
 uint32 count);
typedef void (*fill_rectangle)(engine_token* et, uint32 color,
 fill_rect_params* list, uint32 count);
typedef void (*invert_rectangle)(engine_token* et, fill_rect_params* list,
 uint32 count);
typedef void (*screen_to_screen_transparent_blit)(engine_token* et,
 uint32 transparent_color, blit_params* list, uint32 count);
typedef void (*screen_to_screen_scaled_filtered_blit)(engine_token* et,
 scaled_blit_params* list, uint32 count);

typedef void (*fill_span)(engine_token* et, uint32 color, uint16* list,
 uint32 count);
}





class BBitmap;
class BWindow;

namespace BPrivate {
 class BPrivateScreen;
}


class BScreen {
public:
        BScreen(screen_id id = B_MAIN_SCREEN_ID);
        BScreen(BWindow* window);
        ~BScreen();

   bool IsValid();
   status_t SetToNext();

   color_space ColorSpace();
   BRect Frame();
   screen_id ID();

   status_t WaitForRetrace();
   status_t WaitForRetrace(bigtime_t timeout);

   uint8 IndexForColor(rgb_color color);
   uint8 IndexForColor(uint8 red, uint8 green,
         uint8 blue, uint8 alpha = 255);
   rgb_color ColorForIndex(uint8 index);
   uint8 InvertIndex(uint8 index);

   const color_map* ColorMap();

   status_t GetBitmap(BBitmap** _bitmap,
         bool drawCursor = true,
         BRect* frame = __null);
   status_t ReadBitmap(BBitmap* bitmap,
         bool drawCursor = true,
         BRect* frame = __null);

   rgb_color DesktopColor();
   rgb_color DesktopColor(uint32 workspace);
   void SetDesktopColor(rgb_color color,
         bool stick = true);
   void SetDesktopColor(rgb_color color,
         uint32 workspace, bool stick = true);

   status_t ProposeMode(display_mode* target,
         const display_mode* low,
         const display_mode* high);
   status_t GetModeList(display_mode** _modeList,
         uint32* _count);
   status_t GetMode(display_mode* mode);
   status_t GetMode(uint32 workspace,
         display_mode* mode);
   status_t SetMode(display_mode* mode,
         bool makeDefault = false);
   status_t SetMode(uint32 workspace,
         display_mode* mode,
         bool makeDefault = false);
   status_t GetDeviceInfo(accelerant_device_info* info);
   status_t GetMonitorInfo(monitor_info* info);
   status_t GetPixelClockLimits(display_mode* mode,
         uint32* _low, uint32* _high);
   status_t GetTimingConstraints(
         display_timing_constraints*
          timingConstraints);
   status_t SetDPMS(uint32 state);
   uint32 DPMSState();
   uint32 DPMSCapabilites();

   status_t GetBrightness(float* brightness);
   status_t SetBrightness(float brightness);

private:

        BScreen(const BScreen& other);
   BScreen& operator=(const BScreen& other);

   BPrivate::BPrivateScreen* private_screen();
   status_t ProposeDisplayMode(display_mode* target,
         const display_mode* low,
         const display_mode* high);
   void* BaseAddress();
   uint32 BytesPerRow();

private:
   BPrivate::BPrivateScreen* fScreen;
};


inline uint8
BScreen::IndexForColor(rgb_color color)
{
 return IndexForColor(color.red, color.green, color.blue, color.alpha);
}
class BSeparatorView : public BView {
public:
        BSeparatorView(orientation orientation,
         border_style border = B_PLAIN_BORDER);
        BSeparatorView(const char* name,
         const char* label,
         orientation orientation = B_HORIZONTAL,
         border_style border = B_FANCY_BORDER,
         const BAlignment& alignment
          = BAlignment(B_ALIGN_HORIZONTAL_CENTER,
           B_ALIGN_VERTICAL_CENTER));
        BSeparatorView(const char* name,
         BView* labelView,
         orientation orientation = B_HORIZONTAL,
         border_style border = B_FANCY_BORDER,
         const BAlignment& alignment
          = BAlignment(B_ALIGN_HORIZONTAL_CENTER,
           B_ALIGN_VERTICAL_CENTER));
        BSeparatorView(const char* label = __null,
         orientation orientation = B_HORIZONTAL,
         border_style border = B_FANCY_BORDER,
         const BAlignment& alignment
          = BAlignment(B_ALIGN_HORIZONTAL_CENTER,
           B_ALIGN_VERTICAL_CENTER));
        BSeparatorView(BView* labelView,
         orientation orientation = B_HORIZONTAL,
         border_style border = B_FANCY_BORDER,
         const BAlignment& alignment
          = BAlignment(B_ALIGN_HORIZONTAL_CENTER,
           B_ALIGN_VERTICAL_CENTER));

        BSeparatorView(BMessage* archive);

 virtual ~BSeparatorView();

 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* into,
         bool deep = true) const;

 virtual void Draw(BRect updateRect);

 virtual void GetPreferredSize(float* width, float* height);
 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();

   void SetOrientation(orientation orientation);
   void SetAlignment(const BAlignment& aligment);
   void SetBorderStyle(border_style border);

   void SetLabel(const char* label);
   void SetLabel(BView* view, bool deletePrevious);

 virtual status_t Perform(perform_code code, void* data);

protected:
 virtual void DoLayout();

private:

 virtual void _ReservedSeparatorView1();
 virtual void _ReservedSeparatorView2();
 virtual void _ReservedSeparatorView3();
 virtual void _ReservedSeparatorView4();
 virtual void _ReservedSeparatorView5();
 virtual void _ReservedSeparatorView6();
 virtual void _ReservedSeparatorView7();
 virtual void _ReservedSeparatorView8();
 virtual void _ReservedSeparatorView9();
 virtual void _ReservedSeparatorView10();

private:
   void _Init(const char* label, BView* labelView,
         orientation orientation,
         BAlignment alignment, border_style border);

   float _BorderSize() const;
   BRect _MaxLabelBounds() const;

private:
   BString fLabel;
   BView* fLabelView;

   orientation fOrientation;
   BAlignment fAlignment;
   border_style fBorder;

   uint32 _reserved[10];
};
enum hash_mark_location {
 B_HASH_MARKS_NONE = 0,
 B_HASH_MARKS_TOP = 1,
 B_HASH_MARKS_LEFT = 1,
 B_HASH_MARKS_BOTTOM = 2,
 B_HASH_MARKS_RIGHT = 2,
 B_HASH_MARKS_BOTH = 3
};

enum thumb_style {
 B_BLOCK_THUMB,
 B_TRIANGLE_THUMB
};


class BSlider : public BControl {
public:
        BSlider(BRect frame, const char* name,
         const char* label, BMessage* message,
         int32 minValue, int32 maxValue,
         thumb_style thumbType = B_BLOCK_THUMB,
         uint32 resizingMode = B_FOLLOW_LEFT_TOP,
         uint32 flags = B_NAVIGABLE | B_WILL_DRAW
          | B_FRAME_EVENTS);

        BSlider(BRect frame, const char* name,
         const char* label, BMessage* message,
         int32 minValue, int32 maxValue,
         orientation posture,
         thumb_style thumbType = B_BLOCK_THUMB,
         uint32 resizingMode = B_FOLLOW_LEFT_TOP,
         uint32 flags = B_NAVIGABLE | B_WILL_DRAW
          | B_FRAME_EVENTS);

        BSlider(const char* name, const char* label,
         BMessage* message, int32 minValue,
         int32 maxValue, orientation posture,
         thumb_style thumbType = B_BLOCK_THUMB,
         uint32 flags = B_NAVIGABLE | B_WILL_DRAW
          | B_FRAME_EVENTS);

        BSlider(BMessage* archive);
 virtual ~BSlider();

 static BArchivable* Instantiate(BMessage* archive);
 virtual status_t Archive(BMessage* archive,
         bool deep = true) const;
 virtual status_t Perform(perform_code code, void* data);

 virtual void WindowActivated(bool state);
 virtual void AttachedToWindow();
 virtual void AllAttached();
 virtual void AllDetached();
 virtual void DetachedFromWindow();

 virtual void MessageReceived(BMessage* message);
 virtual void FrameMoved(BPoint newPosition);
 virtual void FrameResized(float width, float height);
 virtual void KeyDown(const char* bytes, int32 numBytes);
 virtual void KeyUp(const char* bytes, int32 numBytes);
 virtual void MouseDown(BPoint point);
 virtual void MouseUp(BPoint point);
 virtual void MouseMoved(BPoint point, uint32 transit,
         const BMessage* dragMessage);
 virtual void Pulse();

 virtual void SetLabel(const char* label);
 virtual void SetLimitLabels(const char* minLabel,
         const char* maxLabel);
   const char* MinLimitLabel() const;
   const char* MaxLimitLabel() const;
 virtual void SetValue(int32 value);
 virtual int32 ValueForPoint(BPoint point) const;
 virtual void SetPosition(float);
   float Position() const;
 virtual void SetEnabled(bool on);
   void GetLimits(int32* minimum, int32* maximum) const;

 virtual void Draw(BRect updateRect);
 virtual void DrawSlider();
 virtual void DrawBar();
 virtual void DrawHashMarks();
 virtual void DrawThumb();
 virtual void DrawFocusMark();
 virtual void DrawText();
 virtual const char* UpdateText() const;
   void UpdateTextChanged();

 virtual BRect BarFrame() const;
 virtual BRect HashMarksFrame() const;
 virtual BRect ThumbFrame() const;

 virtual void SetFlags(uint32 flags);
 virtual void SetResizingMode(uint32 mode);

 virtual void GetPreferredSize(float* _width,
         float* _height);
 virtual void ResizeToPreferred();

 virtual status_t Invoke(BMessage* message = __null);
 virtual BHandler* ResolveSpecifier(BMessage* message,
         int32 index, BMessage* specifier,
         int32 form, const char* property);
 virtual status_t GetSupportedSuites(BMessage* data);

 virtual void SetModificationMessage(BMessage* message);
   BMessage* ModificationMessage() const;

 virtual void SetSnoozeAmount(int32 microSeconds);
   int32 SnoozeAmount() const;

 virtual void SetKeyIncrementValue(int32 value);
   int32 KeyIncrementValue() const;

 virtual void SetHashMarkCount(int32 count);
   int32 HashMarkCount() const;

 virtual void SetHashMarks(hash_mark_location where);
   hash_mark_location HashMarks() const;

 virtual void SetStyle(thumb_style style);
   thumb_style Style() const;

 virtual void SetBarColor(rgb_color color);
   rgb_color BarColor() const;
 virtual void UseFillColor(bool useFill,
         const rgb_color* color = __null);
   bool FillColor(rgb_color* color) const;

   BView* OffscreenView() const;

   orientation Orientation() const;
 virtual void SetOrientation(orientation);

   float BarThickness() const;
 virtual void SetBarThickness(float thickness);

 virtual void SetFont(const BFont* font,
         uint32 properties = B_FONT_ALL);

 virtual void SetLimits(int32 minimum, int32 maximum);

 virtual float MaxUpdateTextWidth();

 virtual BSize MinSize();
 virtual BSize MaxSize();
 virtual BSize PreferredSize();

 virtual status_t SetIcon(const BBitmap* icon, uint32 flags = 0);

protected:
 virtual void LayoutInvalidated(bool descendants);

private:
   void _DrawBlockThumb();
   void _DrawTriangleThumb();

   BPoint _Location() const;
   void _SetLocationForValue(int32 value);

   float _MinPosition() const;
   float _MaxPosition() const;
   bool _ConstrainPoint(BPoint& point,
         BPoint compare) const;

   BSize _ValidateMinSize();

   void _InitBarColor();
   void _InitObject();

private:

 virtual void _ReservedSlider6();
 virtual void _ReservedSlider7();
 virtual void _ReservedSlider8();
 virtual void _ReservedSlider9();
 virtual void _ReservedSlider10();
 virtual void _ReservedSlider11();
 virtual void _ReservedSlider12();

   BSlider& operator=(const BSlider& other);

private:
   BMessage* fModificationMessage;
   int32 fSnoozeAmount;

   rgb_color fBarColor;
   rgb_color fFillColor;
   bool fUseFillColor;

   char* fMinLimitLabel;
   char* fMaxLimitLabel;
   const char* fUpdateText;

   int32 fMinValue;
   int32 fMaxValue;
   int32 fKeyIncrementValue;

   int32 fHashMarkCount;
   hash_mark_location fHashMarks;

   BBitmap* fOffScreenBits;
   BView* fOffScreenView;

   thumb_style fStyle;

   BPoint fLocation;
   BPoint fInitialLocation;

   orientation fOrientation;
   float fBarThickness;

   BSize fMinSize;

   float fMaxUpdateTextWidth;

   uint32 _reserved[4];
};
       
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;

  using ::aligned_alloc;

  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) noexcept { return ldiv(__i, __j); }




}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}

using std::abort;
using std::atexit;
using std::exit;
  using std::_Exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;






SettingsWin::SettingsWin()
 :
 BWindow(BRect(100, 100, 500, 300), 
                                   B_CATKEY((
                                   "KeyCursor settings"
                                   ), 
                                   "SettingsWindow"
                                   )
                                                                    , B_TITLED_WINDOW,
  B_ASYNCHRONOUS_CONTROLS | B_NOT_RESIZABLE | B_NOT_ZOOMABLE | B_AUTO_UPDATE_SIZE_LIMITS)
{
 fEnabled = new BCheckBox("enable", 
                                   B_CATKEY((
                                   "Enable KeyCursor"
                                   ), 
                                   "SettingsWindow"
                                   )
                                                                  ,
  new BMessage('kcEC'));
 fEnabled->SetValue(fPrefs.GetEnabled());
 fEnabled->MakeFocus(true);

 fModBox = new ModifierBox(
                          B_CATKEY((
                          "Toggle keys"
                          ), 
                          "SettingsWindow"
                          )
                                                    , fPrefs.GetToggleModMask(),
  fPrefs.GetClickKeyMask());
 fModBox->SetDefaultModifierMask(fPrefs.GetDefaultClickKeyMask());
 fModBox->SetMessage(new BMessage('kcTC'));
 fModBox->SetTarget(this);
 fModBox->SetEnabled(fPrefs.GetEnabled());

 fAccelSlider = new BSlider("accel_slider", 
                                           B_CATKEY((
                                           "Acceleration"
                                           ), 
                                           "SettingsWindow"
                                           )
                                                                      ,
   new BMessage('kcAC'), 0, 40, B_HORIZONTAL);

 fAccelSlider->SetKeyIncrementValue(10);
 fAccelSlider->SetHashMarks(B_HASH_MARKS_BOTTOM);
 fAccelSlider->SetHashMarkCount(5);
 fAccelSlider->SetValue(fPrefs.GetAcceleration());
 fAccelSlider->SetLimitLabels(
                             B_CATKEY((
                             "Min"
                             ), 
                             "SettingsWindow"
                             )
                                               , 
                                                 B_CATKEY((
                                                 "Max"
                                                 ), 
                                                 "SettingsWindow"
                                                 )
                                                                   );
 fAccelSlider->SetEnabled(fPrefs.GetEnabled());

 BLayoutBuilder::Group<>(this, B_VERTICAL)
  .AddGroup(B_VERTICAL)
   .SetInsets(B_USE_WINDOW_INSETS, B_USE_WINDOW_INSETS, B_USE_WINDOW_INSETS, 0)
   .Add(fEnabled)
  .End()
  .Add(new BSeparatorView(B_HORIZONTAL))
  .AddGroup(B_VERTICAL)
   .SetInsets(B_USE_WINDOW_INSETS, 0, B_USE_WINDOW_INSETS, B_USE_WINDOW_INSETS)
   .Add(fModBox)
   .Add(fAccelSlider)
  .End();

 CenterOnScreen();
}


SettingsWin::~SettingsWin()
{
}


void
SettingsWin::MessageReceived(BMessage* message)
{
 switch (message->what) {
  case 'kcTC':
  {
   fPrefs.SetToggleModMask(fModBox->GetModifierMask());

   fPrefs.Save();
   SendUpdateMessage();
  } break;

  case 'kcEC':
  {
   fPrefs.SetEnabled(fEnabled->Value());
   fPrefs.Save();
   fModBox->SetEnabled(!fModBox->IsEnabled());
   fAccelSlider->SetEnabled(!fAccelSlider->IsEnabled());
   SendUpdateMessage();
  } break;

  case 'kcAC':
  {
   float rate = fAccelSlider->Value();
   if ((rate < 0) || (rate > 40))
    rate = 10;

   fPrefs.SetAcceleration(rate);
   fPrefs.Save();
   SendUpdateMessage();
  } break;

  default:
   BWindow::MessageReceived(message);
 }
}


bool
SettingsWin::QuitRequested()
{
 fPrefs.SetWindowCorner(BPoint(Frame().left, Frame().top));

 be_app_messenger.SendMessage(B_QUIT_REQUESTED);

 return true;
}


void
SettingsWin::SendUpdateMessage()
{
 port_id port = find_port("KeyCursor PrefsPort");

 if (port < 0)
  return;

 write_port(port, 'kcPC', 
                                __null
                                    , 0);
}
