/*
 * KeyCursorFilter.cpp
 *
 *	Copyright 2000, Be Incorporated.   All Rights Reserved.
 *	This file may be used under the terms of the Be Sample Code License.
 *
 *  Copyright 2004-2023, HaikuArchives Team
 *  Authors:
 * 		Nathan Schrenk
 *		Thomas Thiriez (code from his EasyMove app)
 *		Oscar Lesta
 *		Humdinger
 */

#include "KeyCursor.h"
#include "ReplicantView.h"

#include <Beep.h>
#include <Deskbar.h>
#include <InterfaceDefs.h>
#include <List.h>
#include <Message.h>
#include <OS.h>

#include <stdio.h>
#include <syslog.h>

#define kPrefsThreadPrio 1 // B_LOW_PRIORITY

extern "C"
{

	BInputServerFilter* instantiate_input_filter()
	{
		return new KeyCursorFilter();
	}

} /* extern "C" */


KeyCursorFilter::KeyCursorFilter()
{
	fPortID = -1;
	fPrefsThread = -1;
	fNecessaryMods = fPrefs.GetToggleModMask();
	fButtonPressed = 0;
	fLeftPressed = false;
	fRightPressed = false;
	fUpPressed = false;
	fDownPressed = false;
	fWheelUpPressed = false;
	fWheelDownPressed = false;
	fToggleMode = true;
	fToggleOn = false;

	fPrefsThread
		= spawn_thread(KeyCursorFilter::PrefsThreadFunc, "KeyCursorPrefs", kPrefsThreadPrio, this);

	if (fPrefsThread >= 0)
		resume_thread(fPrefsThread);

	bool enabled = fPrefs.GetReplicant();
	if (!enabled)
		return;

	BDeskbar deskbar;
	// wait up to 10 seconds for Deskbar to become available
	// in case it is not running (yet?)
	bool isDeskbarRunning = deskbar.IsRunning();
	int32 tries = 10;
	while (!isDeskbarRunning && --tries) {
		if (deskbar.IsRunning()) {
			isDeskbarRunning = true;
			break;
		}
		snooze(1000000);
	}

	if (!isDeskbarRunning) {
		syslog(LOG_INFO, "KeyCursorFilter: Deskbar isn't running.");
		return;
	}

	_AddToDeskbar();
	_SendStatus();
}


KeyCursorFilter::~KeyCursorFilter()
{
	BDeskbar deskbar;
	if (deskbar.HasItem(REPLICANT_VIEW_NAME))
		_RemoveFromDeskbar();

	if (fPrefsThread != -1)
		kill_thread(fPrefsThread);
}


status_t
KeyCursorFilter::InitCheck()
{
	return B_OK;
}


void
KeyCursorFilter::SendMessageToDevice(int32 what, int32 data)
{
	// locate the device looper if it hasn't been set yet
	if (fPortID < 0) {
		fPortID = find_port(KEY_CURSOR_DEVICE_PORT_NAME);
		if (fPortID < 0) {
			// no point in continuing if we can't send messages
			// to the device looper
			return;
		}
	}

	write_port(fPortID, what, &data, sizeof(data));
}


filter_result
KeyCursorFilter::Filter(BMessage* message, BList* /*outList*/)
{
	static bool toggleModPressedLast = false;
	filter_result result = B_DISPATCH_MESSAGE;

	// if (!fPrefs.GetEnabled())
		// return result;

	switch (message->what) {
		case B_UNMAPPED_KEY_DOWN:
		case B_UNMAPPED_KEY_UP:
		{
			// raw modifier state changes only concern us in toggle mode
			if (!fToggleMode)
				break;

			uint32 mods;
			message->FindInt32("modifiers", (int32*) &mods);
			mods = mods & (B_SHIFT_KEY | B_COMMAND_KEY | B_CONTROL_KEY | B_OPTION_KEY | B_MENU_KEY);

			if (message->what == B_UNMAPPED_KEY_DOWN)
				toggleModPressedLast = (mods == fNecessaryMods);
			else {
				// detect if the toggle modifier was pressed down and then
				// let up without any key events in between, and if so,
				// toggle the mode.  This is a B_UNMAPPED_KEY_UP event,
				// so the modifiers will not include the key this event
				// was generated by, but we know that if toggleModPressedLast==true,
				// releasing the toggle modifier must have been what caused this
				// event.  This code makes the assumption (probably incorrect) that
				// the only unmapped key events are generated by modifiers.
				if (toggleModPressedLast)
					_Toggle();

				toggleModPressedLast = false;
			}
		} break;

		case B_KEY_DOWN: // fall through
		case B_KEY_UP:
		{
			toggleModPressedLast = false;

			uchar ch;
			uint32 raw;
			uint32 mods;

			if ((message->FindInt8("byte", 0, (int8*) &ch) != B_OK)
				|| (message->FindInt32("raw_char", 0, (int32*) &raw) != B_OK)
				|| (message->FindInt32("modifiers", (int32*) &mods) != B_OK)) {
				break;
			}

			uint32 origMods = mods;
			mods = mods & (B_SHIFT_KEY | B_COMMAND_KEY | B_CONTROL_KEY | B_OPTION_KEY | B_MENU_KEY);

			if (fToggleMode && fToggleOn)
				mods = fNecessaryMods;

			switch (message->what) {
				case B_KEY_DOWN:
				{
					result = B_SKIP_MESSAGE;

					switch (raw) {
						case B_LEFT_ARROW:
							if (!fLeftPressed) {
								if (mods == fNecessaryMods) {
									fLeftPressed = true;
									SendMessageToDevice(LEFT_KEY_DOWN);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						case B_RIGHT_ARROW:
							if (!fRightPressed) {
								if (mods == fNecessaryMods) {
									fRightPressed = true;
									SendMessageToDevice(RIGHT_KEY_DOWN);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						case B_UP_ARROW:
							if (!fUpPressed) {
								if (mods == fNecessaryMods) {
									fUpPressed = true;
									SendMessageToDevice(UP_KEY_DOWN);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						case B_DOWN_ARROW:
							if (!fDownPressed) {
								if (mods == fNecessaryMods) {
									fDownPressed = true;
									SendMessageToDevice(DOWN_KEY_DOWN);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						case B_PAGE_UP:
							if (!fWheelUpPressed) {
								if (mods == fNecessaryMods) {
									fWheelUpPressed = true;
									SendMessageToDevice(PAGE_UP_KEY_DOWN);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						case B_PAGE_DOWN:
							if (!fWheelDownPressed) {
								if (mods == fNecessaryMods) {
									fWheelDownPressed = true;
									SendMessageToDevice(PAGE_DOWN_KEY_DOWN);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						case B_SPACE: // space bar is used to click
							if (fButtonPressed == 0) {
								if (mods == fNecessaryMods) {
									// space is button 1, shift-space is button 2
									fButtonPressed = (origMods & B_SHIFT_KEY) ? 2 : 1;
									SendMessageToDevice(BUTTON_DOWN, (int32) fButtonPressed);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						default:
							result = B_DISPATCH_MESSAGE;
							break;
					}
				} break;

				case B_KEY_UP:
				{
					// note: we don't care about modifiers on key up
					switch (raw) {
						case B_LEFT_ARROW:
							if (fLeftPressed) {
								fLeftPressed = false;
								SendMessageToDevice(LEFT_KEY_UP);
								result = B_SKIP_MESSAGE;
							}
							break;

						case B_RIGHT_ARROW:
							if (fRightPressed) {
								fRightPressed = false;
								SendMessageToDevice(RIGHT_KEY_UP);
								result = B_SKIP_MESSAGE;
							}
							break;

						case B_UP_ARROW:
							if (fUpPressed) {
								fUpPressed = false;
								SendMessageToDevice(UP_KEY_UP);
								result = B_SKIP_MESSAGE;
							}
							break;

						case B_DOWN_ARROW:
							if (fDownPressed) {
								fDownPressed = false;
								SendMessageToDevice(DOWN_KEY_UP);
								result = B_SKIP_MESSAGE;
							}
							break;

						case B_PAGE_UP:
							if (fWheelUpPressed) {
								fWheelUpPressed = false;
								SendMessageToDevice(PAGE_UP_KEY_UP);
								result = B_SKIP_MESSAGE;
							}
							break;

						case B_PAGE_DOWN:
							if (fWheelDownPressed) {
								fWheelDownPressed = false;
								SendMessageToDevice(PAGE_DOWN_KEY_UP);
								result = B_SKIP_MESSAGE;
							}
							break;

						case B_SPACE:
							if (fButtonPressed != 0) {
								SendMessageToDevice(BUTTON_UP, fButtonPressed);
								fButtonPressed = 0;
								result = B_SKIP_MESSAGE;
							}
							break;
					}
				} break;
			}
		} break;
	}

	return result;
}


int32
KeyCursorFilter::PrefsThreadFunc(void* cookie)
{
	port_id updatePrefsPort = create_port(1, KEY_CURSOR_PREFS_PORT_NAME);

	if (updatePrefsPort < 0)
		return updatePrefsPort;

	while (1) {
		int32 msg_code;
		status_t err = read_port(updatePrefsPort, &msg_code, NULL, 0);
		if (err < 0)
			return err;

		KeyCursorFilter* filter = (KeyCursorFilter*) cookie;
		if (msg_code == PREFS_CHANGED) {
			filter->fPrefs.Update();
			filter->fNecessaryMods = filter->fPrefs.GetToggleModMask();
			filter->SendMessageToDevice(PREFS_CHANGED);

			BDeskbar deskbar;
			bool enabled = filter->fPrefs.GetReplicant();
			if (!enabled)
				filter->_RemoveFromDeskbar();
			else if (!deskbar.HasItem(REPLICANT_VIEW_NAME)) {
				filter->_AddToDeskbar();
				filter->_SendStatus();
			}
		} else if (msg_code == STATE)
			filter->_SendStatus();
		else if (msg_code == TOGGLE)
			filter->_Toggle();
	}

	return B_OK;
}


void
KeyCursorFilter::_AddToDeskbar()
{
	BDeskbar deskbar;
	if (deskbar.HasItem(REPLICANT_VIEW_NAME))
		_RemoveFromDeskbar();

	float height = deskbar.MaxItemHeight();
	BRect rect(0, 0, height - 1, height - 1);
	ReplicantView* replicant = new ReplicantView(rect);
	status_t res = deskbar.AddItem(replicant);
	if (res != B_OK)
		syslog(LOG_INFO, "KeyCursorFilter: couldn't add replicant.");
}


void
KeyCursorFilter::_RemoveFromDeskbar()
{
	BDeskbar deskbar;
	int32 found_id;
	if (deskbar.GetItemInfo(REPLICANT_VIEW_NAME, &found_id) == B_OK) {
		status_t err = deskbar.RemoveItem(found_id);
		if (err != B_OK) {
			printf("KeyCursor: Error removing replicant id " "%" B_PRId32 ": %s\n",
				found_id, strerror(err));
		}
	}
}


void
KeyCursorFilter::_SendStatus()
{
	BMessage message(STATE);
	message.AddBool("status", fToggleOn);

	// Send current state to preference app
	BMessenger prefMessenger(APP_SIGNATURE);
	if (prefMessenger.IsValid())
		prefMessenger.SendMessage(&message);

	// Send current starte to deskbar replicant
	BMessenger* replMessenger = _ReplicantMessenger();
	if (replMessenger != NULL) {
		if (replMessenger->IsValid() == true)
			replMessenger->SendMessage(&message);
	}
}


void
KeyCursorFilter::_Toggle()
{
	fToggleOn = !fToggleOn;
	beep();

	// re-add replicant if it got lost, e.g. Deskbar was restarted
	BDeskbar deskbar;
	bool inDeskbar = deskbar.HasItem(REPLICANT_VIEW_NAME);
	bool enabled = fPrefs.GetReplicant();
	if (enabled && !inDeskbar)
		_AddToDeskbar();

	_SendStatus();
}


BMessenger*
KeyCursorFilter::_ReplicantMessenger()
{
	BMessage request(B_GET_PROPERTY);
	BMessenger to;
	BMessenger status;

	request.AddSpecifier("Messenger");
	request.AddSpecifier("Shelf");

	// In the Deskbar the Shelf is in the View "Status" in Window "Deskbar"
	request.AddSpecifier("View", "Status");
	request.AddSpecifier("Window", "Deskbar");
	to = BMessenger("application/x-vnd.Be-TSKB", -1);

	BMessage reply;

	if (to.SendMessage(&request, &reply) == B_OK
		&& reply.FindMessenger("result", &status) == B_OK) {
		// enum replicant in Status view
		int32 index = 0;
		int32 uid;
		while ((uid = _GetReplicantAt(status, index++)) >= B_OK) {
			BMessage replicantInfo;
			if (_GetReplicantName(status, uid, &replicantInfo) != B_OK)
				continue;
			const char *name;
			if (replicantInfo.FindString("result", &name) == B_OK
				&& !strcmp(name, REPLICANT_VIEW_NAME)) {
				BMessage replicant;
				if (_GetReplicantView(status, uid, &replicant) == B_OK) {
					BMessenger result;
					if (replicant.FindMessenger("result", &result) == B_OK)
						return(new BMessenger(result));
				}
			}
		}
	}
	return NULL;
}


int32
KeyCursorFilter::_GetReplicantAt(BMessenger target, int32 index) const
{
	// So here we want to get the Unique ID of the replicant at the given index
	// in the target Shelf.

	BMessage request(B_GET_PROPERTY);// We're getting the ID property
	BMessage reply;
	status_t err;

	request.AddSpecifier("ID"); // want the ID
	request.AddSpecifier("Replicant", index); // of the index'th replicant

	if ((err = target.SendMessage(&request, &reply)) != B_OK)
		return err;

	int32 uid;
	if ((err = reply.FindInt32("result", &uid)) != B_OK)
		return err;

	return uid;
}


status_t
KeyCursorFilter::_GetReplicantName(BMessenger target, int32 uid, BMessage* reply) const
{
	// We send a message to the target shelf, asking it for the Name of the
	// replicant with the given unique id.

	BMessage request(B_GET_PROPERTY);
	BMessage uid_specifier(B_ID_SPECIFIER); // specifying via ID
	status_t err;
	status_t e;

	request.AddSpecifier("Name"); // ask for the Name of the replicant

	// IDs are specified using code like the following 3 lines:
	uid_specifier.AddInt32("id", uid);
	uid_specifier.AddString("property", "Replicant");
	request.AddSpecifier(&uid_specifier);

	if ((err = target.SendMessage(&request, reply)) != B_OK)
		return err;

	if (((err = reply->FindInt32("error", &e)) != B_OK) || (e != B_OK))
		return err ? err : e;

	return B_OK;
}


status_t
KeyCursorFilter::_GetReplicantView(BMessenger target, int32 uid, BMessage* reply) const
{
	// We send a message to the target shelf, asking it for the Name of the
	// replicant with the given unique id.

	BMessage request(B_GET_PROPERTY);
	BMessage uid_specifier(B_ID_SPECIFIER);	// specifying via ID
	status_t err;
	status_t e;

	request.AddSpecifier("View"); // ask for the Name of the replicant

	// IDs are specified using code like the following 3 lines:
	uid_specifier.AddInt32("id", uid);
	uid_specifier.AddString("property", "Replicant");
	request.AddSpecifier(&uid_specifier);

	if ((err = target.SendMessage(&request, reply)) != B_OK)
		return err;

	if (((err = reply->FindInt32("error", &e)) != B_OK) || (e != B_OK))
		return err ? err : e;

	return B_OK;
}
