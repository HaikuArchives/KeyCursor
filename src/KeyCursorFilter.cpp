/*
 * KeyCursorFilter.cpp
 *
 *	Copyright 2000, Be Incorporated.   All Rights Reserved.
 *	This file may be used under the terms of the Be Sample Code License.
 *
 *  Copyright 2004-2023, HaikuArchives Team
 *  Authors:
 * 		Nathan Schrenk
 *		Thomas Thiriez (code from his EasyMove app)
 *		Oscar Lesta
 *		Humdinger
 */

#include "KeyCursor.h"
#include "ReplicantView.h"

#include <Beep.h>
#include <Deskbar.h>
#include <InterfaceDefs.h>
#include <List.h>
#include <Message.h>
#include <OS.h>

#include <stdio.h>
#include <syslog.h>

#define kPrefsThreadPrio 1 // B_LOW_PRIORITY

extern "C"
{

	BInputServerFilter* instantiate_input_filter()
	{
		return new KeyCursorFilter();
	}

} /* extern "C" */


KeyCursorFilter::KeyCursorFilter()
{
	fPortID = -1;
	fPrefsThread = -1;
	fNecessaryMods = fPrefs.GetToggleModMask();
	fButtonPressed = 0;
	fLeftPressed = false;
	fRightPressed = false;
	fUpPressed = false;
	fDownPressed = false;
	fWheelUpPressed = false;
	fWheelDownPressed = false;
	fToggleMode = true;
	fToggleOn = false;

	fPrefsThread
		= spawn_thread(KeyCursorFilter::PrefsThreadFunc, "KeyCursorPrefs", kPrefsThreadPrio, this);

	if (fPrefsThread >= 0)
		resume_thread(fPrefsThread);

	BDeskbar deskbar;
	// wait up to 10 seconds for Deskbar to become available
	// in case it is not running (yet?)
	bool isDeskbarRunning = deskbar.IsRunning();
	int32 tries = 10;
	while (!isDeskbarRunning && --tries) {
		if (deskbar.IsRunning()) {
			isDeskbarRunning = true;
			break;
		}
		snooze(1000000);
	}

	if (!isDeskbarRunning) {
		syslog(LOG_INFO, "KeyCursorFilter: Deskbar isn't running.");
		return;
	}

	if (deskbar.HasItem(REPLICANT_SIGNATURE))
		_RemoveFromDeskbar();

	float height = deskbar.MaxItemHeight();
	BRect rect(0, 0, height - 1, height - 1);
	ReplicantView* replicant = new ReplicantView(rect);
	status_t res = deskbar.AddItem(replicant);
	if (res != B_OK)
		syslog(LOG_INFO, "KeyCursorFilter: couldn't add replicant.");


}


KeyCursorFilter::~KeyCursorFilter()
{
	BDeskbar deskbar;
	if (deskbar.HasItem(REPLICANT_SIGNATURE))
		_RemoveFromDeskbar();

	if (fPrefsThread != -1)
		kill_thread(fPrefsThread);
}


status_t
KeyCursorFilter::InitCheck()
{
	return B_OK;
}


void
KeyCursorFilter::SendMessageToDevice(int32 what, int32 data)
{
	// locate the device looper if it hasn't been set yet
	if (fPortID < 0) {
		fPortID = find_port(KEY_CURSOR_DEVICE_PORT_NAME);
		if (fPortID < 0) {
			// no point in continuing if we can't send messages
			// to the device looper
			return;
		}
	}

	write_port(fPortID, what, &data, sizeof(data));
}


filter_result
KeyCursorFilter::Filter(BMessage* message, BList* /*outList*/)
{
	static bool toggleModPressedLast = false;
	filter_result result = B_DISPATCH_MESSAGE;

	if (!fPrefs.GetEnabled())
		return result;

	switch (message->what) {
		case B_UNMAPPED_KEY_DOWN:
		case B_UNMAPPED_KEY_UP:
		{
			// raw modifier state changes only concern us in toggle mode
			if (!fToggleMode)
				break;

			uint32 mods;
			message->FindInt32("modifiers", (int32*) &mods);
			mods = mods & (B_SHIFT_KEY | B_COMMAND_KEY | B_CONTROL_KEY | B_OPTION_KEY | B_MENU_KEY);

			if (message->what == B_UNMAPPED_KEY_DOWN)
				toggleModPressedLast = (mods == fNecessaryMods);
			else {
				// detect if the toggle modifier was pressed down and then
				// let up without any key events in between, and if so,
				// toggle the mode.  This is a B_UNMAPPED_KEY_UP event,
				// so the modifiers will not include the key this event
				// was generated by, but we know that if toggleModPressedLast==true,
				// releasing the toggle modifier must have been what caused this
				// event.  This code makes the assumption (probably incorrect) that
				// the only unmapped key events are generated by modifiers.
				if (toggleModPressedLast) {
					fToggleOn = !fToggleOn;
					beep();

					_SendStatus();
				}
				toggleModPressedLast = false;
			}
		} break;

		case B_KEY_DOWN: // fall through
		case B_KEY_UP:
		{
			toggleModPressedLast = false;

			uchar ch;
			uint32 raw;
			uint32 mods;

			if ((message->FindInt8("byte", 0, (int8*) &ch) != B_OK)
				|| (message->FindInt32("raw_char", 0, (int32*) &raw) != B_OK)
				|| (message->FindInt32("modifiers", (int32*) &mods) != B_OK)) {
				break;
			}

			uint32 origMods = mods;
			mods = mods & (B_SHIFT_KEY | B_COMMAND_KEY | B_CONTROL_KEY | B_OPTION_KEY | B_MENU_KEY);

			if (fToggleMode && fToggleOn)
				mods = fNecessaryMods;

			switch (message->what) {
				case B_KEY_DOWN:
				{
					result = B_SKIP_MESSAGE;

					switch (raw) {
						case B_LEFT_ARROW:
							if (!fLeftPressed) {
								if (mods == fNecessaryMods) {
									fLeftPressed = true;
									SendMessageToDevice(LEFT_KEY_DOWN);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						case B_RIGHT_ARROW:
							if (!fRightPressed) {
								if (mods == fNecessaryMods) {
									fRightPressed = true;
									SendMessageToDevice(RIGHT_KEY_DOWN);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						case B_UP_ARROW:
							if (!fUpPressed) {
								if (mods == fNecessaryMods) {
									fUpPressed = true;
									SendMessageToDevice(UP_KEY_DOWN);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						case B_DOWN_ARROW:
							if (!fDownPressed) {
								if (mods == fNecessaryMods) {
									fDownPressed = true;
									SendMessageToDevice(DOWN_KEY_DOWN);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						case B_PAGE_UP:
							if (!fWheelUpPressed) {
								if (mods == fNecessaryMods) {
									fWheelUpPressed = true;
									SendMessageToDevice(PAGE_UP_KEY_DOWN);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						case B_PAGE_DOWN:
							if (!fWheelDownPressed) {
								if (mods == fNecessaryMods) {
									fWheelDownPressed = true;
									SendMessageToDevice(PAGE_DOWN_KEY_DOWN);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						case B_SPACE: // space bar is used to click
							if (fButtonPressed == 0) {
								if (mods == fNecessaryMods) {
									// space is button 1, shift-space is button 2
									fButtonPressed = (origMods & B_SHIFT_KEY) ? 2 : 1;
									SendMessageToDevice(BUTTON_DOWN, (int32) fButtonPressed);
								} else {
									result = B_DISPATCH_MESSAGE;
								}
							}
							break;

						default:
							result = B_DISPATCH_MESSAGE;
							break;
					}
				} break;

				case B_KEY_UP:
				{
					// note: we don't care about modifiers on key up
					switch (raw) {
						case B_LEFT_ARROW:
							if (fLeftPressed) {
								fLeftPressed = false;
								SendMessageToDevice(LEFT_KEY_UP);
								result = B_SKIP_MESSAGE;
							}
							break;

						case B_RIGHT_ARROW:
							if (fRightPressed) {
								fRightPressed = false;
								SendMessageToDevice(RIGHT_KEY_UP);
								result = B_SKIP_MESSAGE;
							}
							break;

						case B_UP_ARROW:
							if (fUpPressed) {
								fUpPressed = false;
								SendMessageToDevice(UP_KEY_UP);
								result = B_SKIP_MESSAGE;
							}
							break;

						case B_DOWN_ARROW:
							if (fDownPressed) {
								fDownPressed = false;
								SendMessageToDevice(DOWN_KEY_UP);
								result = B_SKIP_MESSAGE;
							}
							break;

						case B_PAGE_UP:
							if (fWheelUpPressed) {
								fWheelUpPressed = false;
								SendMessageToDevice(PAGE_UP_KEY_UP);
								result = B_SKIP_MESSAGE;
							}
							break;

						case B_PAGE_DOWN:
							if (fWheelDownPressed) {
								fWheelDownPressed = false;
								SendMessageToDevice(PAGE_DOWN_KEY_UP);
								result = B_SKIP_MESSAGE;
							}
							break;

						case B_SPACE:
							if (fButtonPressed != 0) {
								SendMessageToDevice(BUTTON_UP, fButtonPressed);
								fButtonPressed = 0;
								result = B_SKIP_MESSAGE;
							}
							break;
					}
				} break;
			}
		} break;
	}

	return result;
}


int32
KeyCursorFilter::PrefsThreadFunc(void* cookie)
{
	port_id updatePrefsPort = create_port(1, KEY_CURSOR_PREFS_PORT_NAME);

	if (updatePrefsPort < 0)
		return updatePrefsPort;

	while (1) {
		int32 msg_code;
		status_t err = read_port(updatePrefsPort, &msg_code, NULL, 0);
		if (err < 0)
			return err;

		KeyCursorFilter* filter = (KeyCursorFilter*) cookie;
		if (msg_code == PREFS_CHANGED) {
			filter->fPrefs.Update();
			filter->fNecessaryMods = filter->fPrefs.GetToggleModMask();

			filter->SendMessageToDevice(PREFS_CHANGED);
		} else if (msg_code == STATE)
			filter->_SendStatus();
	}

	return B_OK;
}


void
KeyCursorFilter::_RemoveFromDeskbar()
{
	BDeskbar deskbar;
	int32 found_id;
	if (deskbar.GetItemInfo(REPLICANT_SIGNATURE, &found_id) == B_OK) {
		status_t err = deskbar.RemoveItem(found_id);
		if (err != B_OK) {
			printf("KeyCursor: Error removing replicant id " "%" B_PRId32 ": %s\n",
				found_id, strerror(err));
		}
	}
}


void
KeyCursorFilter::_SendStatus()
{
	BMessenger messenger(APP_SIGNATURE);
	BMessage message(STATE);
	message.AddBool("status", fToggleOn);
	messenger.SendMessage(&message);
}
